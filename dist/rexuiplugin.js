(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.rexuiplugin = factory());
})(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function set$1(target, property, value, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.set) {
      set$1 = Reflect.set;
    } else {
      set$1 = function set(target, property, value, receiver) {
        var base = _superPropBase(target, property);

        var desc;

        if (base) {
          desc = Object.getOwnPropertyDescriptor(base, property);

          if (desc.set) {
            desc.set.call(receiver, value);
            return true;
          } else if (!desc.writable) {
            return false;
          }
        }

        desc = Object.getOwnPropertyDescriptor(receiver, property);

        if (desc) {
          if (!desc.writable) {
            return false;
          }

          desc.value = value;
          Object.defineProperty(receiver, property, desc);
        } else {
          _defineProperty(receiver, property, value);
        }

        return true;
      };
    }

    return set$1(target, property, value, receiver);
  }

  function _set(target, property, value, receiver, isStrict) {
    var s = set$1(target, property, value, receiver || target);

    if (!s && isStrict) {
      throw new Error('failed to set property');
    }

    return value;
  }

  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var ObjectFactory = /*#__PURE__*/function () {
    function ObjectFactory(scene) {
      _classCallCheck(this, ObjectFactory);

      this.scene = scene;
      this.displayList = scene.sys.displayList;
      this.updateList = scene.sys.updateList;
      scene.events.once('destroy', this.destroy, this);
    }

    _createClass(ObjectFactory, [{
      key: "destroy",
      value: function destroy() {
        this.scene = null;
        this.displayList = null;
        this.updateList = null;
      }
    }], [{
      key: "register",
      value: function register(type, callback) {
        ObjectFactory.prototype[type] = callback;
      }
    }]);

    return ObjectFactory;
  }();

  var SetGetFrameNameCallback = function SetGetFrameNameCallback(callback) {
    if (callback === undefined) {
      callback = DefaultGetFrameNameCallback;
    }

    this.getFrameNameCallback = callback;
    return this;
  };

  var DefaultGetFrameNameCallback = function DefaultGetFrameNameCallback(colIndex, rowIndex, baseFrameName) {
    if (baseFrameName === '__BASE') {
      return "".concat(colIndex, ",").concat(rowIndex);
    } else {
      return "".concat(baseFrameName, "_").concat(colIndex, ",").concat(rowIndex);
    }
  };

  var DeepClone = function DeepClone(inObject) {
    var outObject;
    var value;
    var key;

    if (_typeof(inObject) !== 'object' || inObject === null) {
      //  inObject is not an object
      return inObject;
    } //  Create an array or object to hold the values


    outObject = Array.isArray(inObject) ? [] : {};

    for (key in inObject) {
      value = inObject[key]; //  Recursively (deep) copy for nested objects, including arrays

      outObject[key] = DeepClone(value);
    }

    return outObject;
  };

  var SetTexture$2 = function SetTexture(key, baseFrameName, columns, rows) {
    if (Array.isArray(baseFrameName)) {
      rows = columns;
      columns = baseFrameName;
      baseFrameName = undefined;
    }

    if (baseFrameName === undefined) {
      baseFrameName = '__BASE';
    }

    columns = DeepClone(columns);
    rows = DeepClone(rows);
    this.textureKey = key;
    this.baseFrameName = baseFrameName;
    this.columns.data = columns;
    this.columns.count = columns ? columns.length : 0;
    this.columns.stretch = 0;
    this.columns.minWidth = 0;
    this.columns.scale = 1;
    this.rows.data = rows;
    this.rows.count = rows ? rows.length : 0;
    this.rows.stretch = 0;
    this.rows.minHeight = 0;
    this.rows.scale = 1;
    var texture = this.scene.sys.textures.get(key);

    if (!texture) {
      this.clear();
      return this;
    }

    if (!columns || !rows) {
      this.clear();
      return this;
    } // Get remainder width/height for unknown width/height


    var baseFrame = texture.frames[baseFrameName];
    var remainderTextureWidth = baseFrame.width;
    var unknownColumnWidthCount = 0;

    for (var i = 0, cnt = columns.length; i < cnt; i++) {
      if (columns[i] === undefined) {
        unknownColumnWidthCount++;
      } else if (typeof columns[i] === 'number') {
        remainderTextureWidth -= columns[i];
      } else {
        remainderTextureWidth -= columns[i].width;
      }
    }

    var unknownColumnWidth = remainderTextureWidth / unknownColumnWidthCount;
    var remainderTextureHeight = baseFrame.height;
    var unknownRowHeightCount = 0;

    for (var i = 0, cnt = rows.length; i < cnt; i++) {
      if (rows[i] === undefined) {
        unknownRowHeightCount++;
      } else if (typeof rows[i] === 'number') {
        remainderTextureHeight -= rows[i];
      } else {
        remainderTextureHeight -= rows[i].width;
      }
    }

    var unknownRowHeight = remainderTextureHeight / unknownRowHeightCount;
    var row, col, rowHeight, colWidth, frameName;
    var offsetX = 0,
        offsetY = 0;

    for (var j = 0, jcnt = rows.length; j < jcnt; j++) {
      // Unknown height
      if (rows[j] === undefined) {
        rows[j] = unknownRowHeight;
      }

      if (typeof rows[j] === 'number') {
        rows[j] = {
          height: rows[j],
          stretch: j % 2
        };
      }

      row = rows[j];
      rowHeight = row.height;
      this.rows.stretch += row.stretch | 0;
      this.rows.minHeight += row.stretch > 0 ? 0 : rowHeight;
      offsetX = 0;

      for (var i = 0, icnt = columns.length; i < icnt; i++) {
        // Unknown width
        if (columns[i] === undefined) {
          columns[i] = unknownColumnWidth;
        }

        if (typeof columns[i] === 'number') {
          columns[i] = {
            width: columns[i],
            stretch: i % 2
          };
        }

        col = columns[i];
        colWidth = col.width;

        if (j === 0) {
          this.columns.stretch += col.stretch | 0;
          this.columns.minWidth += col.stretch > 0 ? 0 : colWidth;
        }

        if (colWidth >= 1 && rowHeight >= 1) {
          frameName = this.getFrameNameCallback(i, j, baseFrameName);

          var frameNameType = _typeof(frameName);

          if (frameNameType === 'string' || frameNameType === 'number') {
            texture.add(frameName, 0, offsetX + baseFrame.cutX, offsetY + baseFrame.cutY, colWidth, rowHeight); // Do nothing if frameName is existed
          }
        }

        offsetX += colWidth;
      }

      offsetY += rowHeight;
    }

    this.updateTexture();
    return this;
  };

  var UpdateTexture = function UpdateTexture() {
    this.clear();

    if (this.textureKey === undefined) {
      return this;
    }

    var texture = this.scene.sys.textures.get(this.textureKey);

    if (!texture) {
      return this;
    }

    var minWidth = this.columns.minWidth * this.maxFixedPartScaleX; // Fixed-part width

    var minHeight = this.rows.minHeight * this.maxFixedPartScaleY; // Fixed-part height

    var stretchWidth = this.width - minWidth;
    var stretchHeight = this.height - minHeight;
    var fixedPartScaleX = stretchWidth >= 0 ? this.maxFixedPartScaleX : this.width / minWidth;
    var fixedPartScaleY = stretchHeight >= 0 ? this.maxFixedPartScaleY : this.height / minHeight;

    if (this.preserveRatio) {
      var minScale = Math.min(fixedPartScaleX, fixedPartScaleY);

      if (fixedPartScaleX > minScale) {
        var compensationWidth = (fixedPartScaleX - minScale) * minWidth;

        if (stretchWidth >= 0) {
          stretchWidth += compensationWidth;
        } else {
          stretchWidth = compensationWidth;
        }

        fixedPartScaleX = minScale;
      }

      if (fixedPartScaleY > minScale) {
        var compensationHeight = (fixedPartScaleY - minScale) * minHeight;

        if (stretchHeight >= 0) {
          stretchHeight += compensationHeight;
        } else {
          stretchHeight = compensationHeight;
        }

        fixedPartScaleY = minScale;
      }
    }

    this.columns.scale = fixedPartScaleX;
    this.rows.scale = fixedPartScaleY;
    var proportionWidth;

    if (stretchWidth > 0) {
      proportionWidth = this.columns.stretch > 0 ? stretchWidth / this.columns.stretch : 0;
    } else {
      proportionWidth = 0;
    }

    var proportionHeight;

    if (stretchHeight > 0) {
      proportionHeight = this.rows.stretch > 0 ? stretchHeight / this.rows.stretch : 0;
    } else {
      proportionHeight = 0;
    }

    var frameName, col, row, colWidth, rowHeight;
    var offsetX = 0,
        offsetY = 0;
    var imageType;

    for (var j = 0, jcnt = this.rows.count; j < jcnt; j++) {
      row = this.rows.data[j];
      rowHeight = row.stretch === 0 ? row.height * fixedPartScaleY : proportionHeight * row.stretch;
      offsetX = 0;

      for (var i = 0, icnt = this.columns.count; i < icnt; i++) {
        col = this.columns.data[i];
        colWidth = col.stretch === 0 ? col.width * fixedPartScaleX : proportionWidth * col.stretch;
        frameName = this.getFrameNameCallback(i, j, this.baseFrameName);

        if (texture.has(frameName) && colWidth > 0 && rowHeight > 0) {
          if (row.stretch === 0 && col.stretch === 0) {
            // Fixed parts
            imageType = 0; // Draw image
          } else {
            // Stretchable parts
            if (this.getStretchMode(i, j) === 0) {
              // Scaled image
              imageType = 0; // Draw scaled image
            } else {
              // Repeat tile-sprite
              imageType = 1; // Draw tile-sprite
            }
          }

          if (imageType === 0) {
            this._drawImage(this.textureKey, frameName, offsetX, offsetY, colWidth, rowHeight);
          } else {
            this._drawTileSprite(this.textureKey, frameName, offsetX, offsetY, colWidth, rowHeight);
          }
        }

        offsetX += colWidth;
      }

      offsetY += rowHeight;
    }
  };

  var IsPlainObject$y = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$2I = Phaser.Utils.Objects.GetValue;

  var SetStretchMode = function SetStretchMode(mode) {
    if (IsPlainObject$y(mode)) {
      this.stretchMode.edge = parseMode(GetValue$2I(mode, 'edge', 0));
      this.stretchMode.internal = parseMode(GetValue$2I(mode, 'internal', 0));
    } else {
      mode = parseMode(mode);
      this.stretchMode.edge = mode;
      this.stretchMode.internal = mode;
    }

    return this;
  };

  var parseMode = function parseMode(mode) {
    if (typeof mode === 'string') {
      mode = EXTENDMODE[mode];
    }

    return mode;
  };

  var EXTENDMODE = {
    scale: 0,
    repeat: 1
  };

  var IsEdge = function IsEdge(colIndex, rowIndex) {
    return colIndex === 0 || colIndex === this.columns.count - 1 || rowIndex === 0 || rowIndex === this.rows.count - 1;
  };

  var GetStretchMode = function GetStretchMode(colIndex, rowIndex) {
    return IsEdge.call(this, colIndex, rowIndex) ? this.stretchMode.edge : this.stretchMode.internal;
  };

  var SetPreserveRatio = function SetPreserveRatio(enable) {
    if (enable == undefined) {
      enable = true;
    }

    this.preserveRatio = enable;
    return this;
  };

  var SetMaxFixedPartScale = function SetMaxFixedPartScale(scaleX, scaleY) {
    if (scaleY === undefined) {
      scaleY = scaleX;
    }

    this.maxFixedPartScaleX = scaleX;
    this.maxFixedPartScaleY = scaleY;
    return this;
  };

  var NOOP = function NOOP() {//  NOOP
  };

  var Methods$a = {
    _drawImage: NOOP,
    _drawTileSprite: NOOP,
    setGetFrameNameCallback: SetGetFrameNameCallback,
    setTexture: SetTexture$2,
    updateTexture: UpdateTexture,
    setStretchMode: SetStretchMode,
    getStretchMode: GetStretchMode,
    setPreserveRatio: SetPreserveRatio,
    setMaxFixedPartScale: SetMaxFixedPartScale
  };

  var IsPlainObject$x = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$2H = Phaser.Utils.Objects.GetValue;

  var NinePatchBase = function NinePatchBase(GOClass, type) {
    var NinePatch = /*#__PURE__*/function (_GOClass) {
      _inherits(NinePatch, _GOClass);

      var _super = _createSuper(NinePatch);

      function NinePatch(scene, x, y, width, height, key, baseFrame, columns, rows, config) {
        var _this;

        _classCallCheck(this, NinePatch);

        if (IsPlainObject$x(x)) {
          config = x;
          x = GetValue$2H(config, 'x', 0);
          y = GetValue$2H(config, 'y', 0);
          width = GetValue$2H(config, 'width', 1);
          height = GetValue$2H(config, 'height', 1);
          key = GetValue$2H(config, 'key', undefined);
          baseFrame = GetValue$2H(config, 'baseFrame', undefined);
          columns = GetValue$2H(config, 'columns', undefined);
          rows = GetValue$2H(config, 'rows', undefined);
        } else if (IsPlainObject$x(width)) {
          config = width;
          width = GetValue$2H(config, 'width', 1);
          height = GetValue$2H(config, 'height', 1);
          key = GetValue$2H(config, 'key', undefined);
          baseFrame = GetValue$2H(config, 'baseFrame', undefined);
          columns = GetValue$2H(config, 'columns', undefined);
          rows = GetValue$2H(config, 'rows', undefined);
        } else if (IsPlainObject$x(key)) {
          config = key;
          key = GetValue$2H(config, 'key', undefined);
          baseFrame = GetValue$2H(config, 'baseFrame', undefined);
          columns = GetValue$2H(config, 'columns', undefined);
          rows = GetValue$2H(config, 'rows', undefined);
        } else if (IsPlainObject$x(baseFrame)) {
          config = baseFrame;
          baseFrame = GetValue$2H(config, 'baseFrame', undefined);
          columns = GetValue$2H(config, 'columns', undefined);
          rows = GetValue$2H(config, 'rows', undefined);
        } else if (Array.isArray(baseFrame)) {
          config = rows;
          rows = columns;
          columns = baseFrame;
          baseFrame = GetValue$2H(config, 'baseFrame', undefined);
        } else if (IsPlainObject$x(columns)) {
          config = columns;
          columns = GetValue$2H(config, 'columns', undefined);
          rows = GetValue$2H(config, 'rows', undefined);
        }

        _this = _super.call(this, scene);
        _this.type = type;

        _this.setPosition(x, y).setSize(width, height).setOrigin(0.5, 0.5);

        _this.columns = {};
        _this.rows = {};
        _this.stretchMode = {};
        _this._tileSprite = undefined; // Reserved for drawing image

        _this._image = undefined; // Reserved for drawing image

        _this.setGetFrameNameCallback(GetValue$2H(config, 'getFrameNameCallback', undefined));

        _this.setStretchMode(GetValue$2H(config, 'stretchMode', 0));

        _this.setPreserveRatio(GetValue$2H(config, 'preserveRatio', true));

        var maxFixedPartScale = GetValue$2H(config, 'maxFixedPartScale', 1);
        var maxFixedPartScaleX = GetValue$2H(config, 'maxFixedPartScaleX', maxFixedPartScale);
        var maxFixedPartScaleY = GetValue$2H(config, 'maxFixedPartScaleY', undefined);

        _this.setMaxFixedPartScale(maxFixedPartScaleX, maxFixedPartScaleY);

        _this.setTexture(key, baseFrame, columns, rows);

        return _this;
      }

      _createClass(NinePatch, [{
        key: "minWidth",
        get: function get() {
          return this.columns.minWidth;
        }
      }, {
        key: "minHeight",
        get: function get() {
          return this.rows.minHeight;
        }
      }, {
        key: "fixedPartScaleX",
        get: function get() {
          return this.columns.scale;
        }
      }, {
        key: "fixedPartScaleY",
        get: function get() {
          return this.rows.scale;
        }
      }, {
        key: "resize",
        value: function resize(width, height) {
          if (this.width === width && this.height === height) {
            return this;
          }

          _get(_getPrototypeOf(NinePatch.prototype), "resize", this).call(this, width, height);

          this.updateTexture();
          return this;
        }
      }]);

      return NinePatch;
    }(GOClass);

    Object.assign(NinePatch.prototype, Methods$a);
    return NinePatch;
  };

  var MakeChildImageGameObject = function MakeChildImageGameObject(parent, key, className) {
    if (className === undefined) {
      className = 'image';
    }

    if (!parent[key]) {
      parent[key] = parent.scene.make[className]({
        add: false,
        origin: {
          x: 0,
          y: 0
        }
      });
      parent.once('destroy', function () {
        if (parent[key]) {
          parent[key].destroy();
          parent[key] = undefined;
        }
      });
    }

    return parent[key];
  };

  var DrawImage$2 = function DrawImage(key, frame, x, y, width, height) {
    var gameObject = MakeChildImageGameObject(this, '_image', 'image').setTexture(key, frame).setDisplaySize(width, height);
    this.draw(gameObject, x, y);
  };

  var DrawTileSprite$1 = function DrawTileSprite(key, frame, x, y, width, height) {
    var gameObject = MakeChildImageGameObject(this, '_tileSprite', 'tileSprite').setTexture(key, frame).setSize(width, height);
    this.draw(gameObject, x, y);
  };

  var Methods$9 = {
    _drawImage: DrawImage$2,
    _drawTileSprite: DrawTileSprite$1
  };

  var RenderTexture$1 = Phaser.GameObjects.RenderTexture;

  var NinePatch$1 = /*#__PURE__*/function (_NinePatchBase) {
    _inherits(NinePatch, _NinePatchBase);

    var _super = _createSuper(NinePatch);

    function NinePatch() {
      _classCallCheck(this, NinePatch);

      return _super.apply(this, arguments);
    }

    return _createClass(NinePatch);
  }(NinePatchBase(RenderTexture$1, 'rexNinePatch'));

  Object.assign(NinePatch$1.prototype, Methods$9);

  var IsInValidKey = function IsInValidKey(keys) {
    return keys == null || keys === '' || keys.length === 0;
  };

  var GetEntry = function GetEntry(target, keys, defaultEntry) {
    var entry = target;

    if (IsInValidKey(keys)) ; else {
      if (typeof keys === 'string') {
        keys = keys.split('.');
      }

      var key;

      for (var i = 0, cnt = keys.length; i < cnt; i++) {
        key = keys[i];

        if (entry[key] == null || _typeof(entry[key]) !== 'object') {
          var newEntry;

          if (i === cnt - 1) {
            if (defaultEntry === undefined) {
              newEntry = {};
            } else {
              newEntry = defaultEntry;
            }
          } else {
            newEntry = {};
          }

          entry[key] = newEntry;
        }

        entry = entry[key];
      }
    }

    return entry;
  };

  var SetValue = function SetValue(target, keys, value, delimiter) {
    if (delimiter === undefined) {
      delimiter = '.';
    } // no object


    if (_typeof(target) !== 'object') {
      return;
    } // invalid key
    else if (IsInValidKey(keys)) {
      // don't erase target
      if (value == null) {
        return;
      } // set target to another object
      else if (_typeof(value) === 'object') {
        target = value;
      }
    } else {
      if (typeof keys === 'string') {
        keys = keys.split(delimiter);
      }

      var lastKey = keys.pop();
      var entry = GetEntry(target, keys);
      entry[lastKey] = value;
    }

    return target;
  };

  ObjectFactory.register('ninePatch', function (x, y, width, height, key, columns, rows, config) {
    var gameObject = new NinePatch$1(this.scene, x, y, width, height, key, columns, rows, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.NinePatch', NinePatch$1);

  var GetCalcMatrix$2 = Phaser.GameObjects.GetCalcMatrix;

  var WebGLRenderer$3 = function WebGLRenderer(renderer, src, camera, parentMatrix) {
    var bobs = src.getRenderList();

    if (bobs.length === 0) {
      return;
    }

    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var texture = src.frame.glTexture;
    var textureUnit = pipeline.setGameObject(src);
    var roundPixels = camera.roundPixels;
    var result = GetCalcMatrix$2(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);

    for (var i = 0, cnt = bobs.length; i < cnt; i++) {
      bobs[i].webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels);
    }

    renderer.pipelines.postBatch(src);
  };

  var SetTransform$2 = Phaser.Renderer.Canvas.SetTransform;

  var CanvasRenderer$3 = function CanvasRenderer(renderer, src, camera, parentMatrix) {
    var ctx = renderer.currentContext;
    var bobs = src.getRenderList();

    if (bobs.length === 0 || !SetTransform$2(renderer, ctx, src, camera, parentMatrix)) {
      return;
    }

    camera.addToRenderList(src);
    var roundPixels = camera.roundPixels;
    var dx = -src._displayOriginX,
        dy = -src._displayOriginY;
    ctx.translate(dx, dy);

    for (var i = 0, cnt = bobs.length; i < cnt; i++) {
      bobs[i].canvasRender(ctx, dx, dy, roundPixels);
    } //  Restore the context saved in SetTransform


    ctx.restore();
  };

  var Render$4 = {
    renderWebGL: WebGLRenderer$3,
    renderCanvas: CanvasRenderer$3
  };

  var SetTexture$1 = function SetTexture(key, frame) {
    this.texture = this.scene.sys.textures.get(key);
    this.frame = this.texture.get(frame);
    return this;
  };

  var Resize$1 = function Resize(width, height) {
    if (this.width === width && this.height === height) {
      return this;
    }

    this.width = width;
    this.height = height;
    this.updateDisplayOrigin();
    var input = this.input;

    if (input && !input.customHitArea) {
      input.hitArea.width = width;
      input.hitArea.height = height;
    }

    return this;
  };

  var AddChild$3 = function AddChild(bob) {
    this.lastAppendedChildren.length = 0;

    if (Array.isArray(bob)) {
      var _this$lastAppendedChi;

      this.children.add(bob);

      (_this$lastAppendedChi = this.lastAppendedChildren).push.apply(_this$lastAppendedChi, _toConsumableArray(bob));
    } else {
      this.children.add(bob);
      this.lastAppendedChildren.push(bob);
    }

    return this;
  };

  var RemoveItem$b = Phaser.Utils.Array.Remove;

  var RemoveChild$3 = function RemoveChild(bob) {
    if (this.poolManager) {
      // Free this bob (bob.onFree())
      this.poolManager.free(bob);
    } // Remove this bob from blitter


    RemoveItem$b(this.children.list, bob);
    this.lastAppendedChildren.length = 0;
    this.dirty = true;
    return this;
  };

  var RemoveChildren$1 = function RemoveChildren() {
    if (this.poolManager) {
      // Free all bobs (bob.onFree())
      this.poolManager.freeMultiple(this.children.list);
    } // Remove all bobs from blitter


    this.children.list.length = 0;
    this.lastAppendedChildren.length = 0;
    this.dirty = true;
    return this;
  };

  var GetLastAppendedChildren$1 = function GetLastAppendedChildren() {
    return this.lastAppendedChildren;
  };

  var GetChildren$1 = function GetChildren() {
    return this.children.list;
  };

  var TintMethods = {
    setTint: function setTint(tint) {
      // 0: Solid tint + texture alpha
      this.tint = tint;
      this.tintFill = false;
      return this;
    },
    setTintFill: function setTintFill(tint) {
      // 1: Solid tint, no texture
      this.tint = tint;
      this.tintFill = true;
      return this;
    },
    clearTint: function clearTint() {
      this.setTint(0xffffff);
      return this;
    }
  };

  var methods$o = {
    setTexture: SetTexture$1,
    resize: Resize$1,
    setSize: Resize$1,
    addChild: AddChild$3,
    removeChild: RemoveChild$3,
    removeChildren: RemoveChildren$1,
    clear: RemoveChildren$1,
    getLastAppendedChildren: GetLastAppendedChildren$1,
    getChildren: GetChildren$1
  };
  Object.assign(methods$o, TintMethods);

  var Stack = /*#__PURE__*/function () {
    function Stack() {
      _classCallCheck(this, Stack);

      this.items = [];
    }

    _createClass(Stack, [{
      key: "destroy",
      value: function destroy() {
        this.clear();
        this.items = undefined;
      }
    }, {
      key: "pop",
      value: function pop() {
        return this.items.length > 0 ? this.items.pop() : null;
      }
    }, {
      key: "push",
      value: function push(l) {
        this.items.push(l);
        return this;
      }
    }, {
      key: "pushMultiple",
      value: function pushMultiple(arr) {
        this.items.push.apply(this.items, arr);
        arr.length = 0;
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.items.length = 0;
        return this;
      }
    }]);

    return Stack;
  }();

  var GetValue$2G = Phaser.Utils.Objects.GetValue;
  var Pools$1 = {};

  var PoolManager$1 = /*#__PURE__*/function () {
    function PoolManager(config) {
      _classCallCheck(this, PoolManager);

      this.pools = GetValue$2G(config, 'pools', Pools$1);
    }

    _createClass(PoolManager, [{
      key: "destroy",
      value: function destroy() {
        this.pools = undefined;
      }
    }, {
      key: "free",
      value: function free(bob) {
        if (!this.pools) {
          return this;
        }

        var bobType = bob.type;

        if (!this.pools.hasOwnProperty(bobType)) {
          this.pools[bobType] = new Stack();
        }

        this.pools[bobType].push(bob);
        bob.onFree();
        return this;
      }
    }, {
      key: "freeMultiple",
      value: function freeMultiple(bobs) {
        if (!this.pools) {
          return this;
        }

        for (var i = 0, cnt = bobs.length; i < cnt; i++) {
          this.free(bobs[i]);
        }

        return this;
      }
    }, {
      key: "allocate",
      value: function allocate(bobType) {
        if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
          return null;
        }

        return this.pools[bobType].pop();
      }
    }]);

    return PoolManager;
  }();

  var GameObject$2 = Phaser.GameObjects.GameObject;
  var IsPlainObject$w = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$2F = Phaser.Utils.Objects.GetValue;
  var List = Phaser.Structs.List;
  var StableSort = Phaser.Utils.Array.StableSort;

  var Blitter = /*#__PURE__*/function (_GameObject) {
    _inherits(Blitter, _GameObject);

    var _super = _createSuper(Blitter);

    function Blitter(scene, x, y, texture, frame, config) {
      var _this;

      _classCallCheck(this, Blitter);

      if (IsPlainObject$w(x)) {
        config = x;
        x = GetValue$2F(config, 'x', 0);
        y = GetValue$2F(config, 'y', 0);
        texture = GetValue$2F(config, 'texture');
        frame = GetValue$2F(config, 'frame');
      }

      if (x === undefined) {
        x = 0;
      }

      if (y === undefined) {
        y = 0;
      }

      _this = _super.call(this, scene, 'rexBlitter');
      _this.children = new List();
      _this.renderList = [];
      _this.displayListDirty = false;
      _this.lastAppendedChildren = [];
      var reuseBob = GetValue$2F(config, 'reuseBob', true);
      _this.poolManager = reuseBob ? new PoolManager$1(config) : undefined;

      _this.setTexture(texture, frame).setPosition(x, y).setOrigin(0, 0).clearTint().initPipeline();

      return _this;
    }

    _createClass(Blitter, [{
      key: "preDestroy",
      value: function preDestroy() {
        this.removeChildren();
        this.children.destroy();
        this.renderList.length = 0;

        if (this.poolManager) {
          this.poolManager.destroy();
        }
      }
    }, {
      key: "getRenderList",
      value: function getRenderList() {
        if (this.displayListDirty) {
          this.renderList.length = 0;
          var needDepthSort = false;
          var children = this.children.list;

          for (var i = 0, cnt = children.length; i < cnt; i++) {
            var child = children[i];

            if (ChildCanRender(child)) {
              this.renderList.push(child);

              if (!needDepthSort) {
                needDepthSort = child.depth !== 0;
              }
            }
          }

          if (needDepthSort) {
            StableSort(this.renderList, SortByDepth);
          }

          this.displayListDirty = false;
        }

        return this.renderList;
      }
    }]);

    return Blitter;
  }(GameObject$2);

  var ChildCanRender = function ChildCanRender(child) {
    return child.active && child.visible && child.alpha > 0;
  };

  var SortByDepth = function SortByDepth(childA, childB) {
    return childA._depth - childB._depth;
  };

  var Components$3 = Phaser.GameObjects.Components;
  Phaser.Class.mixin(Blitter, [Components$3.Alpha, Components$3.BlendMode, Components$3.ComputedSize, Components$3.Depth, Components$3.GetBounds, Components$3.Mask, Components$3.Origin, Components$3.Pipeline, Components$3.ScrollFactor, Components$3.Transform, Components$3.Visible, Render$4, methods$o]);

  var ImageTypeName$1 = 'image';

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  //  Source object
  //  The key as a string, or an array of keys, i.e. 'banner', or 'banner.hideBanner'
  //  The default value to use if the key doesn't exist

  /**
   * Retrieves a value from an object.
   *
   * @function Phaser.Utils.Objects.GetValue
   * @since 3.0.0
   *
   * @param {object} source - The object to retrieve the value from.
   * @param {string} key - The name of the property to retrieve from the object. If a property is nested, the names of its preceding properties should be separated by a dot (`.`) - `banner.hideBanner` would return the value of the `hideBanner` property from the object stored in the `banner` property of the `source` object.
   * @param {*} defaultValue - The value to return if the `key` isn't found in the `source` object.
   *
   * @return {*} The value of the requested key.
   */
  var GetValue$2E = function GetValue(source, key, defaultValue) {
    if (!source || typeof source === 'number') {
      return defaultValue;
    } else if (source.hasOwnProperty(key)) {
      return source[key];
    } else if (key.indexOf('.') !== -1) {
      var keys = key.split('.');
      var parent = source;
      var value = defaultValue; //  Use for loop here so we can break early

      for (var i = 0; i < keys.length; i++) {
        if (parent.hasOwnProperty(keys[i])) {
          //  Yes it has a key property, let's carry on down
          value = parent[keys[i]];
          parent = parent[keys[i]];
        } else {
          //  Can't go any further, so reset to default
          value = defaultValue;
          break;
        }
      }

      return value;
    } else {
      return defaultValue;
    }
  };

  var Clear = function Clear(obj) {
    if (_typeof(obj) !== 'object' || obj === null) {
      return obj;
    }

    if (Array.isArray(obj)) {
      obj.length = 0;
    } else {
      for (var key in obj) {
        delete obj[key];
      }
    }

    return obj;
  };

  /**
   * Shallow Object Clone. Will not out nested objects.
   * @param {object} obj JSON object
   * @param {object} ret JSON object to return, set null to return a new object
   * @returns {object} this object
   */

  var Clone = function Clone(obj, out) {
    var objIsArray = Array.isArray(obj);

    if (out === undefined) {
      out = objIsArray ? [] : {};
    } else {
      Clear(out);
    }

    if (objIsArray) {
      out.length = obj.length;

      for (var i = 0, cnt = obj.length; i < cnt; i++) {
        out[i] = obj[i];
      }
    } else {
      for (var key in obj) {
        out[key] = obj[key];
      }
    }

    return out;
  };

  var DataMethods = {
    enableData: function enableData() {
      if (this.data === undefined) {
        this.data = {};
      }

      return this;
    },
    getData: function getData(key, defaultValue) {
      this.enableData();
      return key === undefined ? this.data : GetValue$2E(this.data, key, defaultValue);
    },
    setData: function setData(key, value) {
      this.enableData();

      if (arguments.length === 1) {
        var data = key;

        for (key in data) {
          this.data[key] = data[key];
        }
      } else {
        this.data[key] = value;
      }

      return this;
    },
    incData: function incData(key, inc, defaultValue) {
      if (defaultValue === undefined) {
        defaultValue = 0;
      }

      this.enableData();
      this.setData(key, this.getData(key, defaultValue) + inc);
      return this;
    },
    mulData: function mulData(key, mul, defaultValue) {
      if (defaultValue === undefined) {
        defaultValue = 0;
      }

      this.enableData();
      this.setData(key, this.getData(key, defaultValue) * mul);
      return this;
    },
    clearData: function clearData() {
      if (this.data) {
        Clear(this.data);
      }

      return this;
    }
  };

  var Base$3 = /*#__PURE__*/function () {
    function Base(parent, type) {
      _classCallCheck(this, Base);

      this.type = type;
      this.data = undefined;
      this.setParent(parent).reset().setActive();
    }

    _createClass(Base, [{
      key: "destroy",
      value: function destroy() {
        if (this.parent) {
          this.parent.removeChild(this); // Remove this bob from blitter, and free it (bob.onFree())
          // Will set this.parent to undefined
        }
      }
    }, {
      key: "setParent",
      value: function setParent(parent) {
        this.parent = parent;
        return this;
      } // get scene() {
      //     if (this.parent) {
      //         return this.parent.scene;
      //     } else {
      //         return null;
      //     }
      // }

    }, {
      key: "setDisplayListDirty",
      value: function setDisplayListDirty(displayListDirty) {
        if (displayListDirty && this.parent) {
          this.parent.displayListDirty = true;
        }

        return this;
      }
    }, {
      key: "active",
      get: function get() {
        return this._active;
      },
      set: function set(value) {
        this.setDisplayListDirty(this._active != value);
        this._active = value;
      }
    }, {
      key: "setActive",
      value: function setActive(active) {
        if (active === undefined) {
          active = true;
        }

        this.active = active;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        return this;
      } // Override

    }, {
      key: "reset",
      value: function reset() {
        this.clearData();
      } // Override

    }, {
      key: "onFree",
      value: function onFree() {
        this.reset().setActive(false).setParent();
      }
    }]);

    return Base;
  }();

  Object.assign(Base$3.prototype, DataMethods);

  var DegToRad$b = Phaser.Math.DegToRad;
  var RadToDeg$6 = Phaser.Math.RadToDeg;
  var GetValue$2D = Phaser.Utils.Objects.GetValue;

  var RenderBase$1 = /*#__PURE__*/function (_Base) {
    _inherits(RenderBase, _Base);

    var _super = _createSuper(RenderBase);

    function RenderBase() {
      _classCallCheck(this, RenderBase);

      return _super.apply(this, arguments);
    }

    _createClass(RenderBase, [{
      key: "visible",
      get: function get() {
        return this._visible;
      },
      set: function set(value) {
        this.setDisplayListDirty(this._visible != value);
        this._visible = value;
      }
    }, {
      key: "setVisible",
      value: function setVisible(visible) {
        if (visible === undefined) {
          visible = true;
        }

        this.visible = visible;
        return this;
      }
    }, {
      key: "alpha",
      get: function get() {
        return this._alpha;
      },
      set: function set(value) {
        this.setDisplayListDirty(!!this._alpha !== !!value);
        this._alpha = value;
      }
    }, {
      key: "setAlpha",
      value: function setAlpha(alpha) {
        this.alpha = alpha;
        return this;
      }
    }, {
      key: "setX",
      value: function setX(x) {
        this.x = x;
        return this;
      }
    }, {
      key: "setY",
      value: function setY(y) {
        this.y = y;
        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "setRotation",
      value: function setRotation(rotation) {
        this.rotation = rotation;
        return this;
      }
    }, {
      key: "angle",
      get: function get() {
        return RadToDeg$6(this.rotation);
      },
      set: function set(value) {
        this.rotation = DegToRad$b(value);
      }
    }, {
      key: "setAngle",
      value: function setAngle(angle) {
        this.angle = angle;
        return this;
      }
    }, {
      key: "setScaleX",
      value: function setScaleX(scaleX) {
        this.scaleX = scaleX;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this._width = value;
      }
    }, {
      key: "setWidth",
      value: function setWidth(width, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }

        this.width = width;

        if (keepAspectRatio) {
          this.scaleY = this.scaleX;
        }

        return this;
      }
    }, {
      key: "setScaleY",
      value: function setScaleY(scaleY) {
        this.scaleY = scaleY;
        return this;
      }
    }, {
      key: "setScale",
      value: function setScale(scaleX, scaleY) {
        if (scaleY === undefined) {
          scaleY = scaleX;
        }

        this.scaleX = scaleX;
        this.scaleY = scaleY;
        return this;
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this._height = value;
      }
    }, {
      key: "setHeight",
      value: function setHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }

        this.height = height;

        if (keepAspectRatio) {
          this.scaleX = this.scaleY;
        }

        return this;
      }
    }, {
      key: "displayWidth",
      get: function get() {
        return this._width * this.scaleX;
      },
      set: function set(value) {
        this.scaleX = value / this._width;
      }
    }, {
      key: "setDisplayWidth",
      value: function setDisplayWidth(width, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }

        this.displayWidth = width;

        if (keepAspectRatio) {
          this.scaleY = this.scaleX;
        }

        return this;
      }
    }, {
      key: "displayHeight",
      get: function get() {
        return this._height * this.scaleY;
      },
      set: function set(value) {
        this.scaleY = value / this._height;
      }
    }, {
      key: "setDisplayHeight",
      value: function setDisplayHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }

        this.displayHeight = height;

        if (keepAspectRatio) {
          this.scaleX = this.scaleY;
        }

        return this;
      }
    }, {
      key: "setOriginX",
      value: function setOriginX(originX) {
        this.originX = originX;
        this._displayOriginX = this.width * originX;
        return this;
      }
    }, {
      key: "setOriginY",
      value: function setOriginY(originY) {
        this.originY = originY;
        this._displayOriginY = this.height * originY;
        return this;
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(originX, originY) {
        if (originY === undefined) {
          originY = originX;
        }

        this.setOriginX(originX).setOriginY(originY);
        return this;
      }
    }, {
      key: "depth",
      get: function get() {
        return this._depth;
      },
      set: function set(value) {
        this.setDisplayListDirty(this._depth != value);
        this._depth = value;
      }
    }, {
      key: "setDepth",
      value: function setDepth(depth) {
        if (depth === undefined) {
          depth = 0;
        }

        this.depth = depth;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        if (!o) {
          return this;
        }

        if (o.hasOwnProperty('x')) {
          this.setX(o.x);
        }

        if (o.hasOwnProperty('y')) {
          this.setY(o.y);
        }

        if (o.hasOwnProperty('rotation')) {
          this.setRotation(o.rotation);
        } else if (o.hasOwnProperty('angle')) {
          this.setAngle(o.angle);
        }

        if (o.hasOwnProperty('alpha')) {
          this.setAlpha(o.alpha);
        } // ScaleX, ScaleY


        var width = GetValue$2D(o, 'width', undefined);
        var height = GetValue$2D(o, 'height', undefined);
        var scale = GetValue$2D(o, 'scale', undefined);
        var scaleX = GetValue$2D(o, 'scaleX', scale);
        var scaleY = GetValue$2D(o, 'scaleY', scale);

        if (width !== undefined) {
          if (height === undefined && scaleY === undefined) {
            this.setWidth(width, true);
          } else {
            this.setWidth(width);
          }
        } else if (scaleX !== undefined) {
          this.setScaleX(scaleX);
        } else if (o.hasOwnProperty('displayWidth')) {
          this.setDisplayWidth(o.displayWidth);
        }

        if (height !== undefined) {
          if (width === undefined && scaleX === undefined) {
            this.setHeight(height, true);
          } else {
            this.setHeight(height);
          }
        } else if (scaleY !== undefined) {
          this.setScaleY(scaleY);
        } else if (o.hasOwnProperty('displayHeight')) {
          this.setDisplayHeight(o.displayHeight);
        }

        var origin = GetValue$2D(o, 'origin', undefined);

        if (origin !== undefined) {
          this.setOrigin(origin);
        } else {
          if (o.hasOwnProperty('originX')) {
            this.setOriginX(o.originX);
          }

          if (o.hasOwnProperty('originY')) {
            this.setOriginY(o.originY);
          }
        }

        if (o.hasOwnProperty('depth')) {
          this.setDepth(o.depth);
        }

        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(RenderBase.prototype), "reset", this).call(this);

        this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setOrigin(0).setDepth(0);
        return this;
      } // Override

    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {} // Override

    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy, roundPixels) {}
    }]);

    return RenderBase;
  }(Base$3);

  var TransformMatrix = Phaser.GameObjects.Components.TransformMatrix;
  var GetTint$2 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;
  var FrameMatrix = new TransformMatrix();

  var WebglRender = function WebglRender(pipeline, calcMatrix, alpha, dx, dy, texture, textureUnit, roundPixels) {
    var width = this._width,
        height = this._height;
    var displayOriginX = width * this.originX,
        displayOriginY = height * this.originY;
    var x = this.x - dx,
        y = this.y - dy;
    var flipX = 1;
    var flipY = 1;

    if (this.flipX) {
      x += width - displayOriginX * 2;
      flipX = -1;
    }

    if (this.flipY) {
      y += height - displayOriginY * 2;
      flipY = -1;
    }

    FrameMatrix.applyITRS(x, y, this.rotation, this.scaleX * flipX, this.scaleY * flipY);
    calcMatrix.multiply(FrameMatrix, FrameMatrix);
    var tx = -displayOriginX;
    var ty = -displayOriginY;
    var tw = tx + width;
    var th = ty + height;
    var tx0 = FrameMatrix.getXRound(tx, ty, roundPixels);
    var tx1 = FrameMatrix.getXRound(tx, th, roundPixels);
    var tx2 = FrameMatrix.getXRound(tw, th, roundPixels);
    var tx3 = FrameMatrix.getXRound(tw, ty, roundPixels);
    var ty0 = FrameMatrix.getYRound(tx, ty, roundPixels);
    var ty1 = FrameMatrix.getYRound(tx, th, roundPixels);
    var ty2 = FrameMatrix.getYRound(tw, th, roundPixels);
    var ty3 = FrameMatrix.getYRound(tw, ty, roundPixels);
    var u0 = this.frame.u0;
    var v0 = this.frame.v0;
    var u1 = this.frame.u1;
    var v1 = this.frame.v1;
    var tint = GetTint$2(this.tint, this.alpha * alpha);
    pipeline.batchQuad(this.parent, tx0, ty0, tx1, ty1, tx2, ty2, tx3, ty3, u0, v0, u1, v1, tint, tint, tint, tint, this.tintFill, texture, textureUnit);
  };

  var CanvasRender = function CanvasRender(ctx, dx, dy, roundPixels) {
    ctx.save();
    var width = this._width,
        height = this._height;
    var displayOriginX = width * this.originX,
        displayOriginY = height * this.originY;
    var x = this.x - displayOriginX,
        y = this.y - displayOriginY;
    var flipX = 1;
    var flipY = 1;

    if (this.flipX) {
      x += width;
      flipX = -1;
    }

    if (this.flipY) {
      y += height;
      flipY = -1;
    }

    if (roundPixels) {
      x = Math.round(x);
      y = Math.round(y);
    }

    ctx.translate(x, y);
    ctx.rotate(this.rotation);
    ctx.scale(this.scaleX * flipX, this.scaleY * flipY);
    var frame = this.frame;
    ctx.drawImage(frame.source.image, frame.cutX, frame.cutY, width, height, 0, 0, width, height);
    ctx.restore();
  };

  var IsPlainObject$v = Phaser.Utils.Objects.IsPlainObject;

  var ImageData$1 = /*#__PURE__*/function (_RenderBase) {
    _inherits(ImageData, _RenderBase);

    var _super = _createSuper(ImageData);

    function ImageData(parent, frame) {
      var _this;

      _classCallCheck(this, ImageData);

      _this = _super.call(this, parent, ImageTypeName$1);

      _this.setFrame(frame);

      return _this;
    }

    _createClass(ImageData, [{
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {}
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {}
    }, {
      key: "setFrame",
      value: function setFrame(frame) {
        if (arguments.length > 0 && !IsPlainObject$v(frame)) {
          frame = this.parent.texture.get(frame);
        }

        this.frame = frame;
        this._width = frame ? frame.width : 0;
        this._height = frame ? frame.height : 0;
        return this;
      }
    }, {
      key: "setFlipX",
      value: function setFlipX(flipX) {
        if (flipX === undefined) {
          flipX = true;
        }

        this.flipX = flipX;
        return this;
      }
    }, {
      key: "setFlipY",
      value: function setFlipY(flipY) {
        if (flipY === undefined) {
          flipY = true;
        }

        this.flipY = flipY;
        return this;
      }
    }, {
      key: "resetFlip",
      value: function resetFlip() {
        this.flipX = false;
        this.flipY = false;
        return this;
      }
    }, {
      key: "tint",
      get: function get() {
        if (this._tint === undefined) {
          return this.parent.tint;
        } else {
          return this._tint;
        }
      },
      set: function set(value) {
        this._tint = value;
      }
    }, {
      key: "setTint",
      value: function setTint(value) {
        this.tint = value;
        this.tintFill = false;
        return this;
      }
    }, {
      key: "setTintFill",
      value: function setTintFill(value) {
        this.tint = value;
        this.tintFill = true;
        return this;
      }
    }, {
      key: "clearTint",
      value: function clearTint() {
        this.setTint(0xffffff);
        return this;
      }
    }, {
      key: "resetTint",
      value: function resetTint() {
        this.tint = undefined;
        this.tintFill = undefined;
        return this;
      }
    }, {
      key: "tintFill",
      get: function get() {
        if (this._tintFill === undefined) {
          return this.parent.tintFill;
        } else {
          return this._tintFill;
        }
      },
      set: function set(value) {
        this._tintFill = value;
      }
    }, {
      key: "reset",
      value: function reset() {
        _get(_getPrototypeOf(ImageData.prototype), "reset", this).call(this);

        this.resetFlip().resetTint().setFrame();
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        if (!o) {
          return this;
        } // Size of Image is equal to frame size,
        // Move width, height properties to displayWidth,displayHeight


        if (o.hasOwnProperty('width')) {
          o.displayWidth = o.width;
          delete o.width;
        }

        if (o.hasOwnProperty('height')) {
          o.displayHeight = o.height;
          delete o.height;
        }

        if (o.hasOwnProperty('frame')) {
          this.setFrame(o.frame);
        }

        _get(_getPrototypeOf(ImageData.prototype), "modifyPorperties", this).call(this, o);

        if (o.hasOwnProperty('flipX')) {
          this.setFlipX(o.flipX);
        }

        if (o.hasOwnProperty('flipY')) {
          this.setFlipY(o.flipY);
        }

        if (o.hasOwnProperty('tint')) {
          this.setTint(o.tint);
        }

        if (o.hasOwnProperty('tintFill')) {
          this.setTintFill(o.tintFill);
        }

        return this;
      }
    }]);

    return ImageData;
  }(RenderBase$1);

  var methods$n = {
    webglRender: WebglRender,
    canvasRender: CanvasRender
  };
  Object.assign(ImageData$1.prototype, methods$n);

  var AddImage$2 = function AddImage(blitter, config) {
    if (typeof config === 'string') {
      config = {
        frame: config
      };
    }

    var bob = blitter.poolManager ? blitter.poolManager.allocate(ImageTypeName$1) : null;

    if (bob === null) {
      bob = new ImageData$1(blitter);
    } else {
      bob.setParent(blitter).setActive();
    }

    bob.modifyPorperties(config);
    blitter.addChild(bob);
    return bob;
  };

  var DrawImage$1 = function DrawImage(key, frame, x, y, width, height) {
    AddImage$2(this, {
      frame: frame,
      x: x,
      y: y,
      width: width,
      height: height
    });
  };

  var DrawTileSprite = function DrawTileSprite(key, frame, x, y, width, height) {
    var frameObj = this.texture.get(frame);
    var frameWidth = frameObj.width,
        frameHeight = frameObj.height;
    var colCount = Math.floor(width / frameWidth),
        rowCount = Math.floor(height / frameHeight); // Align images at center

    x += (width - colCount * frameWidth) / 2;
    y += (height - rowCount * frameHeight) / 2;

    for (var colIndex = 0; colIndex < colCount; colIndex++) {
      for (var rowIndex = 0; rowIndex < rowCount; rowIndex++) {
        AddImage$2(this, {
          frame: frame,
          x: x + colIndex * frameWidth,
          y: y + rowIndex * frameHeight
        });
      }
    }
  };

  var Methods$8 = {
    _drawImage: DrawImage$1,
    _drawTileSprite: DrawTileSprite
  };

  var NinePatch = /*#__PURE__*/function (_NinePatchBase) {
    _inherits(NinePatch, _NinePatchBase);

    var _super = _createSuper(NinePatch);

    function NinePatch() {
      _classCallCheck(this, NinePatch);

      return _super.apply(this, arguments);
    }

    _createClass(NinePatch, [{
      key: "setTexture",
      value: function setTexture(key, baseFrameName, columns, rows) {
        SetTexture$1.call(this, key, '__BASE'); // Not initialized yet

        if (!this.columns) {
          return this;
        }

        _get(_getPrototypeOf(NinePatch.prototype), "setTexture", this).call(this, key, baseFrameName, columns, rows);

        return this;
      }
    }]);

    return NinePatch;
  }(NinePatchBase(Blitter, 'rexNinePatch2'));

  Object.assign(NinePatch.prototype, Methods$8);

  ObjectFactory.register('ninePatch2', function (x, y, width, height, key, columns, rows, config) {
    var gameObject = new NinePatch(this.scene, x, y, width, height, key, columns, rows, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.NinePatch2', NinePatch);

  var GetValue$2C = Phaser.Utils.Objects.GetValue;

  var RoundRectangle$2 = /*#__PURE__*/function () {
    function RoundRectangle(x, y, width, height, radiusConfig) {
      _classCallCheck(this, RoundRectangle);

      this.cornerRadius = {};
      this._width = 0;
      this._height = 0;
      this.setTo(x, y, width, height, radiusConfig);
    }

    _createClass(RoundRectangle, [{
      key: "setTo",
      value: function setTo(x, y, width, height, radiusConfig) {
        this.setPosition(x, y);
        this.setRadius(radiusConfig);
        this.setSize(width, height);
        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(x, y) {
        if (x === undefined) {
          x = 0;
        }

        if (y === undefined) {
          y = x;
        }

        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "setRadius",
      value: function setRadius(value) {
        if (value === undefined) {
          value = 0;
        }

        this.radius = value;
        return this;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.width = width;
        this.height = height;
        return this;
      }
    }, {
      key: "minWidth",
      get: function get() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.x + radius.tr.x, radius.bl.x + radius.br.x);
      }
    }, {
      key: "minHeight",
      get: function get() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.y + radius.bl.y, radius.tr.y + radius.br.y);
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        if (value == null) {
          value = 0;
        }

        this._width = Math.max(value, this.minWidth);
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        if (value == null) {
          value = 0;
        }

        this._height = Math.max(value, this.minHeight);
      }
    }, {
      key: "radius",
      get: function get() {
        var radius = this.cornerRadius;
        return Math.max(radius.tl.x, radius.tl.y, radius.tr.x, radius.tr.y, radius.bl.x, radius.bl.y, radius.br.x, radius.br.y);
      },
      set: function set(value) {
        var defaultRadiusX, defaultRadiusY;

        if (typeof value === 'number') {
          defaultRadiusX = value;
          defaultRadiusY = value;
        } else {
          defaultRadiusX = GetValue$2C(value, 'x', 0);
          defaultRadiusY = GetValue$2C(value, 'y', 0);
        }

        var radius = this.cornerRadius;
        radius.tl = GetRadius(GetValue$2C(value, 'tl', undefined), defaultRadiusX, defaultRadiusY);
        radius.tr = GetRadius(GetValue$2C(value, 'tr', undefined), defaultRadiusX, defaultRadiusY);
        radius.bl = GetRadius(GetValue$2C(value, 'bl', undefined), defaultRadiusX, defaultRadiusY);
        radius.br = GetRadius(GetValue$2C(value, 'br', undefined), defaultRadiusX, defaultRadiusY);
      }
    }, {
      key: "radiusTL",
      get: function get() {
        var radius = this.cornerRadius.tl;
        return Math.max(radius.x, radius.y);
      },
      set: function set(value) {
        SetRadius(this.cornerRadius.tl, value);
      }
    }, {
      key: "radiusTR",
      get: function get() {
        var radius = this.cornerRadius.tr;
        return Math.max(radius.x, radius.y);
      },
      set: function set(value) {
        SetRadius(this.cornerRadius.tr, value);
      }
    }, {
      key: "radiusBL",
      get: function get() {
        var radius = this.cornerRadius.bl;
        return Math.max(radius.x, radius.y);
      },
      set: function set(value) {
        SetRadius(this.cornerRadius.bl, value);
      }
    }, {
      key: "radiusBR",
      get: function get() {
        var radius = this.cornerRadius.br;
        return Math.max(radius.x, radius.y);
      },
      set: function set(value) {
        SetRadius(this.cornerRadius.br, value);
      }
    }]);

    return RoundRectangle;
  }();

  var GetRadius = function GetRadius(radius, defaultRadiusX, defaultRadiusY) {
    if (radius === undefined) {
      return {
        x: defaultRadiusX,
        y: defaultRadiusY
      };
    } else if (typeof radius === 'number') {
      return {
        x: radius,
        y: radius
      };
    } else {
      return radius;
    }
  };

  var SetRadius = function SetRadius(radius, value) {
    if (typeof value === 'number') {
      radius.x = value;
      radius.y = value;
    } else {
      radius.x = GetValue$2C(value, 'x', 0);
      radius.y = GetValue$2C(value, 'y', 0);
    }
  };

  var LineTo = function LineTo(x, y, pathData) {
    var cnt = pathData.length;

    if (cnt >= 2) {
      var lastX = pathData[cnt - 2];
      var lastY = pathData[cnt - 1];

      if (x === lastX && y === lastY) {
        return pathData;
      }
    }

    pathData.push(x, y);
    return pathData;
  };

  var DegToRad$a = Phaser.Math.DegToRad;

  var ArcTo$1 = function ArcTo(centerX, centerY, radiusX, radiusY, startAngle, endAngle, antiClockWise, iteration, pathData) {
    // startAngle, endAngle: 0 ~ 360
    if (antiClockWise && endAngle > startAngle) {
      endAngle -= 360;
    } else if (!antiClockWise && endAngle < startAngle) {
      endAngle += 360;
    }

    var deltaAngle = endAngle - startAngle;
    var step = DegToRad$a(deltaAngle) / iteration;
    startAngle = DegToRad$a(startAngle);

    for (var i = 0; i <= iteration; i++) {
      var angle = startAngle + step * i;
      var x = centerX + radiusX * Math.cos(angle);
      var y = centerY + radiusY * Math.sin(angle);
      LineTo(x, y, pathData);
    }

    return pathData;
  };

  /*
  src: {
      fillColor, 
      fillAlpha, 
      pathData, 
      pathIndexes  // Earcut(pathData)
  }
  */
  var Utils$3 = Phaser.Renderer.WebGL.Utils;

  var FillPathWebGL = function FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy) {
    var fillTintColor = Utils$3.getTintAppendFloatAlpha(src.fillColor, src.fillAlpha * alpha);
    var path = src.pathData;
    var pathIndexes = src.pathIndexes;

    for (var i = 0; i < pathIndexes.length; i += 3) {
      var p0 = pathIndexes[i] * 2;
      var p1 = pathIndexes[i + 1] * 2;
      var p2 = pathIndexes[i + 2] * 2;
      var x0 = path[p0 + 0] - dx;
      var y0 = path[p0 + 1] - dy;
      var x1 = path[p1 + 0] - dx;
      var y1 = path[p1 + 1] - dy;
      var x2 = path[p2 + 0] - dx;
      var y2 = path[p2 + 1] - dy;
      var tx0 = calcMatrix.getX(x0, y0);
      var ty0 = calcMatrix.getY(x0, y0);
      var tx1 = calcMatrix.getX(x1, y1);
      var ty1 = calcMatrix.getY(x1, y1);
      var tx2 = calcMatrix.getX(x2, y2);
      var ty2 = calcMatrix.getY(x2, y2);
      pipeline.batchTri(src, tx0, ty0, tx1, ty1, tx2, ty2, 0, 0, 1, 1, fillTintColor, fillTintColor, fillTintColor, 2);
    }
  };

  /*
  src: {
      strokeColor,
      strokeAlpha,
      pathData,
      lineWidth,
      closePath
  }
  */
  var Utils$2 = Phaser.Renderer.WebGL.Utils;

  var StrokePathWebGL = function StrokePathWebGL(pipeline, src, alpha, dx, dy) {
    var strokeTint = pipeline.strokeTint;
    var strokeTintColor = Utils$2.getTintAppendFloatAlpha(src.strokeColor, src.strokeAlpha * alpha);
    strokeTint.TL = strokeTintColor;
    strokeTint.TR = strokeTintColor;
    strokeTint.BL = strokeTintColor;
    strokeTint.BR = strokeTintColor;
    var path = src.pathData;
    var pathLength = path.length - 1;
    var lineWidth = src.lineWidth;
    var halfLineWidth = lineWidth / 2;
    var px1 = path[0] - dx;
    var py1 = path[1] - dy;

    if (!src.closePath) {
      pathLength -= 2;
    }

    for (var i = 2; i < pathLength; i += 2) {
      var px2 = path[i] - dx;
      var py2 = path[i + 1] - dy;
      pipeline.batchLine(px1, py1, px2, py2, halfLineWidth, halfLineWidth, lineWidth, i - 2, src.closePath ? i === pathLength - 1 : false);
      px1 = px2;
      py1 = py2;
    }
  };

  var GetCalcMatrix$1 = Phaser.GameObjects.GetCalcMatrix;

  var PolygonWebGLRenderer = function PolygonWebGLRenderer(renderer, src, camera, parentMatrix) {
    if (src.dirty) {
      src.updateData();
      src.dirty = false;
    }

    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix$1(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);

    if (src.isFilled) {
      FillPathWebGL(pipeline, calcMatrix, src, alpha, dx, dy);
    }

    if (src.isStroked) {
      StrokePathWebGL(pipeline, src, alpha, dx, dy);
    }

    renderer.pipelines.postBatch(src);
  };

  var FillStyleCanvas = function FillStyleCanvas(ctx, src, altColor, altAlpha) {
    var fillColor = altColor ? altColor : src.fillColor;
    var fillAlpha = altAlpha ? altAlpha : src.fillAlpha;
    var red = (fillColor & 0xFF0000) >>> 16;
    var green = (fillColor & 0xFF00) >>> 8;
    var blue = fillColor & 0xFF;
    ctx.fillStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + fillAlpha + ')';
  };

  var LineStyleCanvas = function LineStyleCanvas(ctx, src, altColor, altAlpha) {
    var strokeColor = altColor ? altColor : src.strokeColor;
    var strokeAlpha = altAlpha ? altAlpha : src.strokeAlpha;
    var red = (strokeColor & 0xFF0000) >>> 16;
    var green = (strokeColor & 0xFF00) >>> 8;
    var blue = strokeColor & 0xFF;
    ctx.strokeStyle = 'rgba(' + red + ',' + green + ',' + blue + ',' + strokeAlpha + ')';
    ctx.lineWidth = src.lineWidth;
  };

  var SetTransform$1 = Phaser.Renderer.Canvas.SetTransform;

  var PolygonCanvasRenderer = function PolygonCanvasRenderer(renderer, src, camera, parentMatrix) {
    if (src.dirty) {
      src.updateData();
      src.dirty = false;
    }

    camera.addToRenderList(src);
    var ctx = renderer.currentContext;

    if (SetTransform$1(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var path = src.pathData;
      var pathLength = path.length - 1;
      var px1 = path[0] - dx;
      var py1 = path[1] - dy;
      ctx.beginPath();
      ctx.moveTo(px1, py1);

      if (!src.closePath) {
        pathLength -= 2;
      }

      for (var i = 2; i < pathLength; i += 2) {
        var px2 = path[i] - dx;
        var py2 = path[i + 1] - dy;
        ctx.lineTo(px2, py2);
      }

      ctx.closePath();

      if (src.isFilled) {
        FillStyleCanvas(ctx, src);
        ctx.fill();
      }

      if (src.isStroked) {
        LineStyleCanvas(ctx, src);
        ctx.stroke();
      } //  Restore the context saved in SetTransform


      ctx.restore();
    }
  };

  var Render$3 = {
    renderWebGL: PolygonWebGLRenderer,
    renderCanvas: PolygonCanvasRenderer
  };

  var Shape$1 = Phaser.GameObjects.Shape;
  var GetValue$2B = Phaser.Utils.Objects.GetValue;
  var Earcut$1 = Phaser.Geom.Polygon.Earcut;

  var RoundRectangle$1 = /*#__PURE__*/function (_Shape) {
    _inherits(RoundRectangle, _Shape);

    var _super = _createSuper(RoundRectangle);

    function RoundRectangle(scene, x, y, width, height, radiusConfig, fillColor, fillAlpha) {
      var _this;

      _classCallCheck(this, RoundRectangle);

      if (x === undefined) {
        x = 0;
      }

      if (y === undefined) {
        y = 0;
      }

      var geom = new RoundRectangle$2(); // Configurate it later

      _this = _super.call(this, scene, 'rexRoundRectangleShape', geom);
      var radius = GetValue$2B(radiusConfig, 'radius', radiusConfig);
      geom.setTo(0, 0, width, height, radius);
      var iteration = GetValue$2B(radiusConfig, 'iteration', undefined);

      _this.setIteration(iteration);

      _this.setPosition(x, y);

      if (fillColor !== undefined) {
        _this.setFillStyle(fillColor, fillAlpha);
      }

      _this.updateDisplayOrigin();

      _this.dirty = true;
      return _this;
    }

    _createClass(RoundRectangle, [{
      key: "updateData",
      value: function updateData() {
        var geom = this.geom;
        var pathData = this.pathData;
        pathData.length = 0;
        var cornerRadius = geom.cornerRadius,
            radius,
            iteration = this.iteration + 1; // bottom-right

        radius = cornerRadius.br;

        if (isArcCorner(radius)) {
          var centerX = geom.width - radius.x;
          var centerY = geom.height - radius.y;
          ArcTo$1(centerX, centerY, radius.x, radius.y, 0, 90, false, iteration, pathData);
        } else {
          LineTo(geom.width, geom.height, pathData);
        } // bottom-left


        radius = cornerRadius.bl;

        if (isArcCorner(radius)) {
          var centerX = radius.x;
          var centerY = geom.height - radius.y;
          ArcTo$1(centerX, centerY, radius.x, radius.y, 90, 180, false, iteration, pathData);
        } else {
          LineTo(0, geom.height, pathData);
        } // top-left


        radius = cornerRadius.tl;

        if (isArcCorner(radius)) {
          var centerX = radius.x;
          var centerY = radius.y;
          ArcTo$1(centerX, centerY, radius.x, radius.y, 180, 270, false, iteration, pathData);
        } else {
          LineTo(0, 0, pathData);
        } // top-right


        radius = cornerRadius.tr;

        if (isArcCorner(radius)) {
          var centerX = geom.width - radius.x;
          var centerY = radius.y;
          ArcTo$1(centerX, centerY, radius.x, radius.y, 270, 360, false, iteration, pathData);
        } else {
          LineTo(geom.width, 0, pathData);
        }

        pathData.push(pathData[0], pathData[1]); // Repeat first point to close curve

        this.pathIndexes = Earcut$1(pathData);
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this.geom.width;
      },
      set: function set(value) {
        this.resize(value, this.height);
      }
    }, {
      key: "height",
      get: function get() {
        return this.geom.height;
      },
      set: function set(value) {
        this.resize(this.width, value);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        // Override Shape's setSize method
        if (height === undefined) {
          height = width;
        }

        if (this.geom.width === width && this.geom.height === height) {
          return this;
        }

        this.geom.setSize(width, height);
        this.updateDisplayOrigin();
        this.dirty = true;
        var input = this.input;

        if (input && !input.customHitArea) {
          input.hitArea.width = width;
          input.hitArea.height = height;
        }

        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        this.setSize(width, height);
        return this;
      }
    }, {
      key: "iteration",
      get: function get() {
        return this._iteration;
      },
      set: function set(value) {
        // Set iteration first time
        if (this._iteration === undefined) {
          this._iteration = value;
          return;
        } // Change iteration value


        if (this._iteration === value) {
          return;
        }

        this._iteration = value;
        this.dirty = true;
      }
    }, {
      key: "setIteration",
      value: function setIteration(iteration) {
        if (iteration === undefined) {
          iteration = 6;
        }

        this.iteration = iteration;
        return this;
      }
    }, {
      key: "radius",
      get: function get() {
        return this.geom.radius;
      },
      set: function set(value) {
        this.geom.setRadius(value);
        this.updateDisplayOrigin();
        this.dirty = true;
      }
    }, {
      key: "radiusTL",
      get: function get() {
        return this.geom.radiusTL;
      },
      set: function set(value) {
        this.geom.radiusTL = value;
        this.dirty = true;
      }
    }, {
      key: "radiusTR",
      get: function get() {
        return this.geom.radiusTR;
      },
      set: function set(value) {
        this.geom.radiusTR = value;
        this.dirty = true;
      }
    }, {
      key: "radiusBL",
      get: function get() {
        return this.geom.radiusBL;
      },
      set: function set(value) {
        this.geom.radiusBL = value;
        this.dirty = true;
      }
    }, {
      key: "radiusBR",
      get: function get() {
        return this.geom.radiusBR;
      },
      set: function set(value) {
        this.geom.radiusBR = value;
        this.dirty = true;
      }
    }, {
      key: "setRadius",
      value: function setRadius(value) {
        if (value === undefined) {
          value = 0;
        }

        this.radius = value;
        return this;
      }
    }, {
      key: "setRadiusTL",
      value: function setRadiusTL(value) {
        if (value === undefined) {
          value = 0;
        }

        this.radiusTL = value;
        return this;
      }
    }, {
      key: "setRadiusTR",
      value: function setRadiusTR(value) {
        if (value === undefined) {
          value = 0;
        }

        this.radiusTR = value;
        return this;
      }
    }, {
      key: "setRadiusBL",
      value: function setRadiusBL(value) {
        if (value === undefined) {
          value = 0;
        }

        this.radiuBL = value;
        return this;
      }
    }, {
      key: "setRadiusBR",
      value: function setRadiusBR(value) {
        if (value === undefined) {
          value = 0;
        }

        this.radiusBR = value;
        return this;
      }
    }, {
      key: "cornerRadius",
      get: function get() {
        return this.geom.cornerRadius;
      },
      set: function set(value) {
        this.radius = value;
      }
    }, {
      key: "setCornerRadius",
      value: function setCornerRadius(value) {
        return this.setRadius(value);
      }
    }]);

    return RoundRectangle;
  }(Shape$1);

  var isArcCorner = function isArcCorner(radius) {
    return radius.x !== 0 && radius.y !== 0;
  };

  Object.assign(RoundRectangle$1.prototype, Render$3);

  ObjectFactory.register('roundRectangle', function (x, y, width, height, radiusConfig, fillColor, fillAlpha) {
    var gameObject = new RoundRectangle$1(this.scene, x, y, width, height, radiusConfig, fillColor, fillAlpha);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.RoundRectangle', RoundRectangle$1);

  // copy from Phaser.GameObjects.Text
  var Utils$1 = Phaser.Renderer.WebGL.Utils;

  var WebGLRenderer$2 = function WebGLRenderer(renderer, src, camera, parentMatrix) {
    if (src.dirty) {
      src.updateTexture();
      src.dirty = false;
    }

    if (src.width === 0 || src.height === 0) {
      return;
    }

    camera.addToRenderList(src);
    var frame = src.frame;
    var width = frame.width;
    var height = frame.height;
    var getTint = Utils$1.getTintAppendFloatAlpha;
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
    renderer.pipelines.preBatch(src);
    pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.resolution, height / src.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
    renderer.pipelines.postBatch(src);
  };

  // copy from Phaser.GameObjects.Text
  var CanvasRenderer$2 = function CanvasRenderer(renderer, src, camera, parentMatrix) {
    if (src.dirty) {
      src.updateTexture();
      src.dirty = false;
    }

    if (src.width === 0 || src.height === 0) {
      return;
    }

    camera.addToRenderList(src);
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };

  var Render$2 = {
    renderWebGL: WebGLRenderer$2,
    renderCanvas: CanvasRenderer$2
  };

  var Color = Phaser.Display.Color;
  var CanvasMethods = {
    clear: function clear() {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.dirty = true;
      return this;
    },
    fill: function fill(color) {
      this.context.fillStyle = color;
      this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
      this.dirty = true;
      return this;
    },
    loadFromURL: function loadFromURL(url, callback) {
      var self = this;
      var img = new Image();

      img.onload = function () {
        if (self.width !== img.width || self.height !== img.height) {
          self.resize(img.width, img.height);
        } else {
          self.clear();
        }

        self.context.drawImage(img, 0, 0);
        self.updateTexture();

        if (callback) {
          callback();
        }

        img.onload = null;
        img.src = '';
        img.remove();
      };

      img.src = url;
      return this;
    },
    loadFromURLPromise: function loadFromURLPromise(url) {
      var self = this;
      return new Promise(function (resolve, reject) {
        self.loadFromURL(url, resolve);
      });
    },
    getDataURL: function getDataURL(type, encoderOptions) {
      return this.canvas.toDataURL(type, encoderOptions);
    },
    getPixel: function getPixel(x, y, out) {
      if (out === undefined) {
        out = new Color();
      }

      var rgb = this.context.getImageData(x, y, 1, 1);
      out.setTo(rgb.data[0], rgb.data[1], rgb.data[2], rgb.data[3]);
      return out;
    },
    setPixel: function setPixel(x, y, r, g, b, a) {
      if (typeof r !== 'number') {
        var color = r;
        r = color.red;
        g = color.green;
        b = color.blue;
        a = color.alpha;
      }

      if (a === undefined) {
        a = r !== 0 || g !== 0 || b !== 0 ? 255 : 0;
      }

      var imgData = this.context.createImageData(1, 1);
      imgData.data[0] = r;
      imgData.data[1] = g;
      imgData.data[2] = b;
      imgData.data[3] = a;
      this.context.putImageData(imgData, x, y);
      this.dirty = true;
      return this;
    }
  };

  var CopyCanvasToTexture = function CopyCanvasToTexture(scene, srcCanvas, key, x, y, width, height) {
    var textures = scene.sys.textures;
    var renderer = scene.renderer;

    if (x === undefined) {
      x = 0;
    }

    if (y === undefined) {
      y = 0;
    }

    if (width === undefined) {
      width = srcCanvas.width;
    }

    if (height === undefined) {
      height = srcCanvas.height;
    }

    var texture;

    if (textures.exists(key)) {
      texture = textures.get(key);
    } else {
      texture = textures.createCanvas(key, width, height);
    }

    var destCanvas = texture.getSourceImage();

    if (destCanvas.width !== width) {
      destCanvas.width = width;
    }

    if (destCanvas.height !== height) {
      destCanvas.height = height;
    }

    var destCtx = destCanvas.getContext('2d');
    destCtx.clearRect(0, 0, width, height);
    destCtx.drawImage(srcCanvas, x, y, width, height);

    if (renderer.gl && texture) {
      renderer.canvasToTexture(destCanvas, texture.source[0].glTexture, true, 0);
    }
  };

  var TextureMethods = {
    updateTexture: function updateTexture(callback, scope) {
      if (callback) {
        if (scope) {
          callback.call(scope, this.canvas, this.context);
        } else {
          callback(this.canvas, this.context);
        }
      }

      if (this.canvas.width !== this.frame.width || this.canvas.height !== this.frame.height) {
        this.frame.setSize(this.canvas.width, this.canvas.height);
      }

      if (this.renderer.gl) {
        this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, true);
        this.frame.glTexture = this.frame.source.glTexture;
      }

      this.dirty = false;
      var input = this.input;

      if (input && !input.customHitArea) {
        input.hitArea.width = this.width;
        input.hitArea.height = this.height;
      }

      return this;
    },
    generateTexture: function generateTexture(key, x, y, width, height) {
      var srcCanvas = this.canvas;

      if (width === undefined) {
        width = srcCanvas.width;
      } else {
        width *= this.resolution;
      }

      if (height === undefined) {
        height = srcCanvas.height;
      } else {
        height *= this.resolution;
      }

      CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);
      return this;
    },
    loadTexture: function loadTexture(key, frame) {
      var textureFrame = this.scene.sys.textures.getFrame(key, frame);

      if (!textureFrame) {
        return this;
      }

      if (this.width !== textureFrame.cutWidth || this.height !== textureFrame.cutHeight) {
        this.setSize(textureFrame.cutWidth, textureFrame.cutHeight);
      } else {
        this.clear();
      }

      this.context.drawImage(textureFrame.source.image, textureFrame.cutX, textureFrame.cutY, textureFrame.cutWidth, textureFrame.cutHeight, 0, 0, this.canvas.width, this.canvas.height);
      this.dirty = true;
      return this;
    }
  };

  var CanvasPool$3 = Phaser.Display.Canvas.CanvasPool;
  var GameObject$1 = Phaser.GameObjects.GameObject;

  var Canvas = /*#__PURE__*/function (_GameObject) {
    _inherits(Canvas, _GameObject);

    var _super = _createSuper(Canvas);

    function Canvas(scene, x, y, width, height) {
      var _this;

      _classCallCheck(this, Canvas);

      if (x === undefined) {
        x = 0;
      }

      if (y === undefined) {
        y = 0;
      }

      if (width === undefined) {
        width = 1;
      }

      if (height === undefined) {
        height = 1;
      }

      _this = _super.call(this, scene, 'rexCanvas');
      _this.renderer = scene.sys.game.renderer;
      _this.resolution = 1;
      _this._width = width;
      _this._height = height;
      width = Math.max(Math.ceil(width * _this.resolution), 1);
      height = Math.max(Math.ceil(height * _this.resolution), 1);
      _this.canvas = CanvasPool$3.create(_assertThisInitialized(_this), width, height);
      _this.context = _this.canvas.getContext('2d');
      _this.dirty = false;

      _this.setPosition(x, y);

      _this.setOrigin(0.5, 0.5);

      _this.initPipeline();

      _this._crop = _this.resetCropObject(); //  Create a Texture for this Text object

      _this.texture = scene.sys.textures.addCanvas(null, _this.canvas, true); //  Get the frame

      _this.frame = _this.texture.get(); //  Set the resolution

      _this.frame.source.resolution = _this.resolution;

      if (_this.renderer && _this.renderer.gl) {
        //  Clear the default 1x1 glTexture, as we override it later
        _this.renderer.deleteTexture(_this.frame.source.glTexture);

        _this.frame.source.glTexture = null;
      }

      _this.dirty = true;
      scene.sys.game.events.on('contextrestored', _this.onContextRestored, _assertThisInitialized(_this));
      return _this;
    }

    _createClass(Canvas, [{
      key: "onContextRestored",
      value: function onContextRestored() {
        this.dirty = true;
      }
    }, {
      key: "preDestroy",
      value: function preDestroy() {
        this.scene.sys.game.events.off('contextrestored', this.onContextRestored, this);
        CanvasPool$3.remove(this.canvas);
        this.texture.destroy();
        this.canvas = null;
        this.context = null;
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this.setSize(value, this._height);
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this.setSize(this._width, value);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        if (this._width === width && this._height === height) {
          return this;
        }

        this._width = width;
        this._height = height;
        this.updateDisplayOrigin();
        width = Math.max(Math.ceil(width * this.resolution), 1);
        height = Math.max(Math.ceil(height * this.resolution), 1);
        this.canvas.width = width;
        this.canvas.height = height;
        this.frame.setSize(width, height);
        this.dirty = true;
        return this;
      }
    }, {
      key: "displayWidth",
      get: function get() {
        return this.scaleX * this._width;
      },
      set: function set(value) {
        this.scaleX = value / this._width;
      }
    }, {
      key: "displayHeight",
      get: function get() {
        return this.scaleY * this._height;
      },
      set: function set(value) {
        this.scaleY = value / this._height;
      }
    }, {
      key: "setDisplaySize",
      value: function setDisplaySize(width, height) {
        this.displayWidth = width;
        this.displayHeight = height;
        return this;
      }
    }, {
      key: "getCanvas",
      value: function getCanvas(readOnly) {
        if (!readOnly) {
          this.dirty = true;
        }

        return this.canvas;
      }
    }, {
      key: "getContext",
      value: function getContext(readOnly) {
        if (!readOnly) {
          this.dirty = true;
        }

        return this.context;
      }
    }, {
      key: "needRedraw",
      value: function needRedraw() {
        this.dirty = true;
        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        this.setSize(width, height);
        return this;
      }
    }]);

    return Canvas;
  }(GameObject$1);

  var Components$2 = Phaser.GameObjects.Components;
  Phaser.Class.mixin(Canvas, [Components$2.Alpha, Components$2.BlendMode, Components$2.Crop, Components$2.Depth, Components$2.Flip, Components$2.GetBounds, Components$2.Mask, Components$2.Origin, Components$2.Pipeline, Components$2.ScrollFactor, Components$2.Tint, Components$2.Transform, Components$2.Visible, Render$2, CanvasMethods, TextureMethods]);

  var Pad = Phaser.Utils.String.Pad;

  var GetStyle = function GetStyle(style, canvas, context) {
    if (style == null) {
      return style;
    }

    switch (_typeof(style)) {
      case 'string':
        return style;

      case 'number':
        return "#".concat(Pad(Math.floor(style).toString(16), 6, '0', 1));

      case 'function':
        return style(canvas, context);

      case 'object':
        if (style.hasOwnProperty('r')) {
          if (style.hasOwnProperty('a')) {
            // rgba
            return "rgba(".concat(style.r, ",").concat(style.g, ",").concat(style.b, ",").concat(style.a, ")");
          } else {
            // rgb
            return "rgb(".concat(style.r, ",").concat(style.g, ",").concat(style.b, ")");
          }
        } else if (style.hasOwnProperty('h')) {
          if (style.hasOwnProperty('a')) {
            // hsla
            return "hsla(".concat(style.h, ",").concat(style.s, ",").concat(style.l, ",").concat(style.a, ")");
          } else {
            // hsl
            return "hsl(".concat(style.h, ",").concat(style.s, ",").concat(style.l, ")");
          }
        } else {
          return style; // Not a valid input
        }

      default:
        return style;
    }
  };

  var DegToRad$9 = Phaser.Math.DegToRad;
  var Rad0 = DegToRad$9(0);
  var Rad90 = DegToRad$9(90);
  var Rad180 = DegToRad$9(180);
  var Rad270 = DegToRad$9(270);

  var AddRoundRectanglePath = function AddRoundRectanglePath(context, x, y, width, height, radiusConfig, iteration) {
    var geom = new RoundRectangle$2(x, y, width, height, radiusConfig),
        minWidth = geom.minWidth,
        minHeight = geom.minHeight,
        scaleRX = width >= minWidth ? 1 : width / minWidth,
        scaleRY = height >= minHeight ? 1 : height / minHeight;
    var cornerRadius = geom.cornerRadius;
    var radius, radiusX, radiusY, centerX, centerY;
    context.save();
    context.beginPath();
    context.translate(x, y); // Bottom-right

    radius = cornerRadius.br;
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    centerX = width - radiusX;
    centerY = height - radiusY;
    context.moveTo(width, centerY);

    if (radiusX > 0 && radiusY > 0) {
      ArcTo(context, centerX, centerY, radiusX, radiusY, Rad0, Rad90, iteration);
    } else {
      context.lineTo(width, height);
      context.lineTo(centerX, height);
    } // Bottom-left


    radius = cornerRadius.bl;
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    centerX = radiusX;
    centerY = height - radiusY;
    context.lineTo(radiusX, height);

    if (radiusX > 0 && radiusY > 0) {
      ArcTo(context, centerX, centerY, radiusX, radiusY, Rad90, Rad180, iteration);
    } else {
      context.lineTo(0, height);
      context.lineTo(0, centerY);
    } // Top-left


    radius = cornerRadius.tl;
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    centerX = radiusX;
    centerY = radiusY;
    context.lineTo(0, centerY);

    if (radiusX > 0 && radiusY > 0) {
      ArcTo(context, centerX, centerY, radiusX, radiusY, Rad180, Rad270, iteration);
    } else {
      context.lineTo(0, 0);
      context.lineTo(centerX, 0);
    } // Top-right


    radius = cornerRadius.tr;
    radiusX = radius.x * scaleRX;
    radiusY = radius.y * scaleRY;
    centerX = width - radiusX;
    centerY = radiusY;
    context.lineTo(centerX, 0);

    if (radiusX > 0 && radiusY > 0) {
      ArcTo(context, centerX, centerY, radiusX, radiusY, Rad270, Rad0, iteration);
    } else {
      context.lineTo(width, 0);
      context.lineTo(width, centerY);
    }

    context.closePath();
    context.restore();
  };

  var ArcTo = function ArcTo(context, centerX, centerY, radiusX, radiusY, startAngle, endAngle, iteration) {
    if (iteration == null) {
      // undefined, or null
      context.ellipse(centerX, centerY, radiusX, radiusY, 0, startAngle, endAngle);
    } else {
      iteration += 1;
      var x, y, angle;
      var step = (endAngle - startAngle) / iteration;

      for (var i = 0; i <= iteration; i++) {
        angle = startAngle + step * i;
        x = centerX + radiusX * Math.cos(angle);
        y = centerY + radiusY * Math.sin(angle);
        context.lineTo(x, y);
      }
    }
  };

  var DrawRoundRectangle = function DrawRoundRectangle(canvas, context, x, y, width, height, radiusConfig, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient, iteration) {
    AddRoundRectanglePath(context, x, y, width, height, radiusConfig, iteration);

    if (fillStyle != null) {
      if (fillColor2 != null) {
        var grd;

        if (isHorizontalGradient) {
          grd = context.createLinearGradient(0, 0, width, 0);
        } else {
          grd = context.createLinearGradient(0, 0, 0, height);
        }

        grd.addColorStop(0, fillStyle);
        grd.addColorStop(1, fillColor2);
        fillStyle = grd;
      }

      context.fillStyle = fillStyle;
      context.fill();
    }

    if (strokeStyle != null && lineWidth > 0) {
      context.strokeStyle = strokeStyle;
      context.lineWidth = lineWidth;
      context.stroke();
    }
  };

  var DrawRoundRectangleBackground = function DrawRoundRectangleBackground(canvasObject, color, strokeColor, strokeLineWidth, radius, color2, isHorizontalGradient, iteration) {
    if (color == null && strokeColor == null) {
      return;
    }

    var width = canvasObject.canvas.width,
        height = canvasObject.canvas.height;

    if (strokeColor == null) {
      strokeLineWidth = 0;
    }

    var x = strokeLineWidth / 2;
    width -= strokeLineWidth;
    height -= strokeLineWidth;
    DrawRoundRectangle(canvasObject.canvas, canvasObject.context, x, x, width, height, radius, color, strokeColor, strokeLineWidth, color2, isHorizontalGradient, iteration);
  };

  var DrawContent$2 = function DrawContent() {
    DrawRoundRectangleBackground(this, this.fillStyle, this.strokeStyle, this.lineWidth, this.radius, this.fillColor2, this.isHorizontalGradient, this.iteration);
  };

  var GetValue$2A = Phaser.Utils.Objects.GetValue;

  var RoundRectangle = /*#__PURE__*/function (_Canvas) {
    _inherits(RoundRectangle, _Canvas);

    var _super = _createSuper(RoundRectangle);

    function RoundRectangle(scene, x, y, width, height, radiusConfig, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient) {
      var _this;

      _classCallCheck(this, RoundRectangle);

      _this = _super.call(this, scene, x, y, width, height);
      _this.type = 'rexRoundRectangleCanvas';
      var radius = GetValue$2A(radiusConfig, 'radius', radiusConfig);
      var iteration = GetValue$2A(radiusConfig, 'iteration', undefined);

      _this.setRadius(radius);

      _this.setIteration(iteration);

      _this.setFillStyle(fillStyle, fillColor2, isHorizontalGradient);

      _this.setStrokeStyle(strokeStyle, lineWidth);

      return _this;
    }

    _createClass(RoundRectangle, [{
      key: "radius",
      get: function get() {
        return this._radius;
      },
      set: function set(value) {
        this.dirty |= this._radius != value;
        this._radius = value;
      }
    }, {
      key: "setRadius",
      value: function setRadius(radius) {
        this.radius = radius;
        return this;
      }
    }, {
      key: "iteration",
      get: function get() {
        return this._iteration;
      },
      set: function set(value) {
        this.dirty |= this._iteration != value;
        this._iteration = value;
      }
    }, {
      key: "setIteration",
      value: function setIteration(iteration) {
        this.iteration = iteration;
        return this;
      }
    }, {
      key: "fillStyle",
      get: function get() {
        return this._fillStyle;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty |= this._fillStyle != value;
        this._fillStyle = value;
      }
    }, {
      key: "fillColor2",
      get: function get() {
        return this._fillColor2;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty |= this._fillColor2 != value;
        this._fillColor2 = value;
      }
    }, {
      key: "isHorizontalGradient",
      get: function get() {
        return this._fillStyle;
      },
      set: function set(value) {
        this.dirty |= this._isHorizontalGradient != value;
        this._isHorizontalGradient = value;
      }
    }, {
      key: "setFillStyle",
      value: function setFillStyle(fillStyle, fillColor2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
          isHorizontalGradient = true;
        }

        this.fillStyle = fillStyle;
        this.fillColor2 = fillColor2;
        this.isHorizontalGradient = isHorizontalGradient;
        return this;
      }
    }, {
      key: "strokeStyle",
      get: function get() {
        return this._strokeStyle;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty |= this._strokeStyle != value;
        this._strokeStyle = value;
      }
    }, {
      key: "lineWidth",
      get: function get() {
        return this._lineWidth;
      },
      set: function set(value) {
        this.dirty |= this._lineWidth != value;
        this._lineWidth = value;
      }
    }, {
      key: "setStrokeStyle",
      value: function setStrokeStyle(strokeStyle, lineWidth) {
        this.strokeStyle = strokeStyle;
        this.lineWidth = lineWidth;
        return this;
      }
    }, {
      key: "updateTexture",
      value: function updateTexture() {
        this.clear();
        DrawContent$2.call(this);

        _get(_getPrototypeOf(RoundRectangle.prototype), "updateTexture", this).call(this);

        return this;
      }
    }]);

    return RoundRectangle;
  }(Canvas);

  ObjectFactory.register('roundRectangleCanvas', function (x, y, width, height, radius, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient) {
    var gameObject = new RoundRectangle(this.scene, x, y, width, height, radius, fillStyle, strokeStyle, lineWidth, fillColor2, isHorizontalGradient);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.RoundRectangleCanvas', RoundRectangle);

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var Utils = Phaser.Renderer.WebGL.Utils;
  /**
   * Renders this Game Object with the WebGL Renderer to the given Camera.
   * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
   * This method should not be called directly. It is a utility function of the Render module.
   *
   * @method Phaser.GameObjects.Text#renderWebGL
   * @since 3.0.0
   * @private
   *
   * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - A reference to the current active WebGL renderer.
   * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.
   * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
   * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
   */

  var WebGLRenderer$1 = function WebGLRenderer(renderer, src, camera, parentMatrix) {
    if (src.width === 0 || src.height === 0) {
      return;
    }

    camera.addToRenderList(src);
    var frame = src.frame;
    var width = frame.width;
    var height = frame.height;
    var getTint = Utils.getTintAppendFloatAlpha;
    var pipeline = renderer.pipelines.set(src.pipeline, src);
    var textureUnit = pipeline.setTexture2D(frame.glTexture, src);
    renderer.pipelines.preBatch(src);
    pipeline.batchTexture(src, frame.glTexture, width, height, src.x, src.y, width / src.style.resolution, height / src.style.resolution, src.scaleX, src.scaleY, src.rotation, src.flipX, src.flipY, src.scrollFactorX, src.scrollFactorY, src.displayOriginX, src.displayOriginY, 0, 0, width, height, getTint(src.tintTopLeft, camera.alpha * src._alphaTL), getTint(src.tintTopRight, camera.alpha * src._alphaTR), getTint(src.tintBottomLeft, camera.alpha * src._alphaBL), getTint(src.tintBottomRight, camera.alpha * src._alphaBR), src.tintFill, 0, 0, camera, parentMatrix, false, textureUnit);
    renderer.pipelines.postBatch(src);
  };

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2019 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */

  /**
   * Renders this Game Object with the Canvas Renderer to the given Camera.
   * The object will not render if any of its renderFlags are set or it is being actively filtered out by the Camera.
   * This method should not be called directly. It is a utility function of the Render module.
   *
   * @method Phaser.GameObjects.Text#renderCanvas
   * @since 3.0.0
   * @private
   *
   * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - A reference to the current active Canvas renderer.
   * @param {Phaser.GameObjects.Text} src - The Game Object being rendered in this call.
   * @param {number} interpolationPercentage - Reserved for future use and custom pipelines.
   * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera that is rendering the Game Object.
   * @param {Phaser.GameObjects.Components.TransformMatrix} parentMatrix - This transform matrix is defined if the game object is nested
   */
  var CanvasRenderer$1 = function CanvasRenderer(renderer, src, camera, parentMatrix) {
    if (src.width === 0 || src.height === 0) {
      return;
    }

    camera.addToRenderList(src);
    renderer.batchSprite(src, src.frame, camera, parentMatrix);
  };

  var Render$1 = {
    renderWebGL: WebGLRenderer$1,
    renderCanvas: CanvasRenderer$1
  };

  /**
   * @author       Richard Davey <rich@photonstorm.com>
   * @copyright    2018 Photon Storm Ltd.
   * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
   */
  var CanvasPool$2 = Phaser.Display.Canvas.CanvasPool;
  /**
   * Calculates the ascent, descent and fontSize of a given font style.
   *
   * @function Phaser.GameObjects.MeasureText
   * @since 3.0.0
   *
   * @param {Phaser.GameObjects.Text.TextStyle} textStyle - The TextStyle object to measure.
   *
   * @return {object} An object containing the ascent, descent and fontSize of the TextStyle.
   */

  var MeasureText = function MeasureText(textStyle) {
    // @property {HTMLCanvasElement} canvas - The canvas element that the text is rendered.
    var canvas = CanvasPool$2.create(this); // @property {HTMLCanvasElement} context - The context of the canvas element that the text is rendered to.

    var context = canvas.getContext('2d');
    textStyle.syncFont(canvas, context);
    var metrics = context.measureText(textStyle.testString);

    if ('actualBoundingBoxAscent' in metrics) {
      var ascent = metrics.actualBoundingBoxAscent;
      var descent = metrics.actualBoundingBoxDescent;
      var output = {
        ascent: ascent,
        descent: descent,
        fontSize: ascent + descent
      };
      CanvasPool$2.remove(canvas);
      return output;
    }

    var width = Math.ceil(metrics.width * textStyle.baselineX);
    var baseline = width;
    var height = 2 * baseline;
    baseline = baseline * textStyle.baselineY | 0;
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);
    context.font = textStyle._font;
    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(textStyle.testString, 0, baseline);
    var output = {
      ascent: 0,
      descent: 0,
      fontSize: 0
    };

    if (!context.getImageData(0, 0, width, height)) {
      output.ascent = baseline;
      output.descent = baseline + 6;
      output.fontSize = output.ascent + output.descent;
      CanvasPool$2.remove(canvas);
      return output;
    }

    var imagedata = context.getImageData(0, 0, width, height).data;
    var pixels = imagedata.length;
    var line = width * 4;
    var i;
    var j;
    var idx = 0;
    var stop = false; // ascent. scan from top to bottom until we find a non red pixel

    for (i = 0; i < baseline; i++) {
      for (j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }

      if (!stop) {
        idx += line;
      } else {
        break;
      }
    }

    output.ascent = baseline - i;
    idx = pixels - line;
    stop = false; // descent. scan from bottom to top until we find a non red pixel

    for (i = height; i > baseline; i--) {
      for (j = 0; j < line; j += 4) {
        if (imagedata[idx + j] !== 255) {
          stop = true;
          break;
        }
      }

      if (!stop) {
        idx -= line;
      } else {
        break;
      }
    }

    output.descent = i - baseline;
    output.fontSize = output.ascent + output.descent;
    CanvasPool$2.remove(canvas);
    return output;
  };

  var CONST = {
    // new line mode
    NO_NEWLINE: 0,
    RAW_NEWLINE: 1,
    WRAPPED_NEWLINE: 2,
    // wrap mode
    NO_WRAP: 0,
    WORD_WRAP: 1,
    CHAR_WRAP: 2,
    // split lines
    SPLITREGEXP: /(?:\r\n|\r|\n)/
  };

  var GetAdvancedValue$6 = Phaser.Utils.Objects.GetAdvancedValue;
  var GetValue$2z = Phaser.Utils.Objects.GetValue; //  Key: [ Object Key, Default Value, postCallback ]

  var propertyMap = {
    // background
    backgroundColor: ['backgroundColor', null, GetStyle],
    backgroundColor2: ['backgroundColor2', null, GetStyle],
    backgroundHorizontalGradient: ['backgroundHorizontalGradient', true, null],
    backgroundStrokeColor: ['backgroundStrokeColor', null, GetStyle],
    backgroundStrokeLineWidth: ['backgroundStrokeLineWidth', 2, null],
    backgroundCornerRadius: ['backgroundCornerRadius', 0, null],
    backgroundCornerIteration: ['backgroundCornerIteration', null, null],
    // font
    fontFamily: ['fontFamily', 'Courier', null],
    fontSize: ['fontSize', '16px', null],
    fontStyle: ['fontStyle', '', null],
    color: ['color', '#fff', GetStyle],
    stroke: ['stroke', '#fff', GetStyle],
    strokeThickness: ['strokeThickness', 0, null],
    shadowOffsetX: ['shadow.offsetX', 0, null],
    shadowOffsetY: ['shadow.offsetY', 0, null],
    shadowColor: ['shadow.color', '#000', GetStyle],
    shadowBlur: ['shadow.blur', 0, null],
    shadowStroke: ['shadow.stroke', false, null],
    shadowFill: ['shadow.fill', false, null],
    // underline
    underlineColor: ['underline.color', '#000', GetStyle],
    underlineThickness: ['underline.thickness', 0, null],
    underlineOffset: ['underline.offset', 0, null],
    // align
    halign: ['halign', 'left', null],
    valign: ['valign', 'top', null],
    // size
    maxLines: ['maxLines', 0, null],
    fixedWidth: ['fixedWidth', 0, null],
    fixedHeight: ['fixedHeight', 0, null],
    resolution: ['resolution', 0, null],
    lineSpacing: ['lineSpacing', 0, null],
    xOffset: ['xOffset', 0, null],
    rtl: ['rtl', false, null],
    testString: ['testString', '|MÃ‰qgy', null],
    baselineX: ['baselineX', 1.2, null],
    baselineY: ['baselineY', 1.4, null],
    // wrap
    wrapMode: ['wrap.mode', 0, null],
    wrapWidth: ['wrap.width', 0, null],
    wrapCallback: ['wrap.callback', null],
    wrapCallbackScope: ['wrap.callbackScope', null]
  };

  var TextStyle$1 = /*#__PURE__*/function () {
    function TextStyle(text, style) {
      _classCallCheck(this, TextStyle);

      this.parent = text;
      this.backgroundColor;
      this.backgroundColor2;
      this.backgroundHorizontalGradient;
      this.backgroundStrokeColor;
      this.backgroundStrokeLineWidth;
      this.backgroundCornerRadius;
      this.backgroundCornerIteration;
      this.fontFamily;
      this.fontSize;
      this.fontStyle;
      this.color;
      this.stroke;
      this.strokeThickness;
      this.shadowOffsetX;
      this.shadowOffsetY;
      this.shadowColor;
      this.shadowBlur;
      this.shadowStroke;
      this.shadowFill;
      this.underlineColor;
      this.underlineThickness;
      this.underlineOffset;
      this.halign;
      this.valign;
      this.maxLines;
      this.fixedWidth;
      this.fixedHeight;
      this.resolution;
      this.lineSpacing;
      this.xOffset;
      this.rtl;
      this.testString;
      this.baselineX;
      this.baselineY;
      this.wrapMode;
      this.wrapWidth;
      this.wrapCallback;
      this.wrapCallbackScope;
      this._font; //  Set to defaults + user style

      this.setStyle(style, false, true);
      var metrics = GetValue$2z(style, 'metrics', false); //  Provide optional TextMetrics in the style object to avoid the canvas look-up / scanning
      //  Doing this is reset if you then change the font of this TextStyle after creation

      if (metrics) {
        this.metrics = {
          ascent: GetValue$2z(metrics, 'ascent', 0),
          descent: GetValue$2z(metrics, 'descent', 0),
          fontSize: GetValue$2z(metrics, 'fontSize', 0)
        };
      } else {
        this.metrics = MeasureText(this);
      }
    }

    _createClass(TextStyle, [{
      key: "canvas",
      get: function get() {
        return this.parent.canvasText.canvas;
      }
    }, {
      key: "context",
      get: function get() {
        return this.parent.canvasText.context;
      }
    }, {
      key: "isWrapFitMode",
      get: function get() {
        return this.fixedWidth > 0 && this.wrapMode !== CONST.NO_WRAP && this.wrapWidth === 0;
      }
    }, {
      key: "setStyle",
      value: function setStyle(style, updateText, setDefaults) {
        if (updateText === undefined) {
          updateText = true;
        }

        if (setDefaults === undefined) {
          setDefaults = false;
        }

        if (style && style.hasOwnProperty('wrap')) {
          var wrap = style.wrap;

          if (wrap.hasOwnProperty('mode')) {
            var mode = wrap.mode;

            if (typeof mode === 'string') {
              wrap.mode = WRAPMODE[mode];
            }
          } else {
            if (wrap.hasOwnProperty('width')) {
              wrap.mode = 1;
            }
          }
        } // default halign of RTL is 'right'


        if (style && style.rtl && setDefaults && !style.hasOwnProperty('halign')) {
          style.halign = 'right';
        } //  Avoid type mutation


        if (style && style.hasOwnProperty('fontSize') && typeof style.fontSize === 'number') {
          style.fontSize = style.fontSize.toString() + 'px';
        }

        for (var key in propertyMap) {
          var prop = propertyMap[key]; // [ Object Key, Default Value, preCallback ]

          var objKey = prop[0];
          var defaultValue = setDefaults ? prop[1] : this[key];
          var postCallback = prop[2];

          if (key === 'wrapCallback' || key === 'wrapCallbackScope') {
            // Callback & scope should be set without processing the values
            this[key] = GetValue$2z(style, objKey, defaultValue);
          } else {
            var value = GetAdvancedValue$6(style, objKey, defaultValue);

            if (postCallback) {
              value = postCallback(value);
            }

            this[key] = value;
          }
        } //  Allow for 'font' override


        var font = GetValue$2z(style, 'font', null);

        if (font === null) {
          this._font = this.fontStyle + ' ' + this.fontSize + ' ' + this.fontFamily;
        } else {
          this._font = font;
        } //  Allow for 'fill' to be used in place of 'color'


        var fill = GetValue$2z(style, 'fill', null);

        if (fill !== null) {
          this.color = GetStyle(fill);
        }

        var imageData = GetValue$2z(style, 'images', undefined);

        if (imageData) {
          this.parent.addImage(imageData);
        }

        if (updateText) {
          return this.update(true);
        } else {
          return this.parent;
        }
      }
    }, {
      key: "syncFont",
      value: function syncFont(canvas, context) {
        context.font = this._font;
      }
    }, {
      key: "syncStyle",
      value: function syncStyle(canvas, context) {
        context.textBaseline = 'alphabetic';
        context.fillStyle = this.color;
        context.strokeStyle = this.stroke;
        context.lineWidth = this.strokeThickness;
        context.lineCap = 'round';
        context.lineJoin = 'round';
      }
    }, {
      key: "syncShadow",
      value: function syncShadow(context, enabled) {
        if (enabled) {
          context.shadowOffsetX = this.shadowOffsetX;
          context.shadowOffsetY = this.shadowOffsetY;
          context.shadowColor = this.shadowColor;
          context.shadowBlur = this.shadowBlur;
        } else {
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;
          context.shadowColor = 0;
          context.shadowBlur = 0;
        }
      }
    }, {
      key: "update",
      value: function update(recalculateMetrics) {
        if (recalculateMetrics) {
          this._font = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim();
          this.metrics = MeasureText(this);
        }

        return this.parent.updateText(recalculateMetrics);
      }
    }, {
      key: "buildFont",
      value: function buildFont() {
        var newFont = "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily).trim();

        if (newFont !== this._font) {
          this._font = newFont; //this.metrics = MeasureText(this);
        }

        return this;
      }
    }, {
      key: "setFont",
      value: function setFont(font) {
        if (typeof font === 'string') {
          this.fontFamily = font;
          this.fontSize = '';
          this.fontStyle = '';
        } else {
          this.fontFamily = GetValue$2z(font, 'fontFamily', 'Courier');
          this.fontSize = GetValue$2z(font, 'fontSize', '16px');
          this.fontStyle = GetValue$2z(font, 'fontStyle', '');
        }

        return this.update(true);
      }
    }, {
      key: "setFontFamily",
      value: function setFontFamily(family) {
        this.fontFamily = family;
        return this.update(true);
      }
    }, {
      key: "setFontStyle",
      value: function setFontStyle(style) {
        this.fontStyle = style;
        return this.update(true);
      }
    }, {
      key: "setFontSize",
      value: function setFontSize(size) {
        if (typeof size === 'number') {
          size = size.toString() + 'px';
        }

        this.fontSize = size;
        return this.update(true);
      }
    }, {
      key: "setTestString",
      value: function setTestString(string) {
        this.testString = string;
        return this.update(true);
      }
    }, {
      key: "setFixedSize",
      value: function setFixedSize(width, height) {
        this.fixedWidth = width;
        this.fixedHeight = height;

        if (width) {
          this.parent.width = width;
        }

        if (height) {
          this.parent.height = height;
        }

        return this.update(this.isWrapFitMode);
      }
    }, {
      key: "setResolution",
      value: function setResolution(value) {
        this.resolution = value;
        return this.update(false);
      }
    }, {
      key: "setLineSpacing",
      value: function setLineSpacing(value) {
        this.lineSpacing = value;
        return this.update(false);
      }
    }, {
      key: "setXOffset",
      value: function setXOffset(value) {
        this.xOffset = value;
        return this.update(false);
      }
    }, {
      key: "setBackgroundColor",
      value: function setBackgroundColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
          isHorizontalGradient = true;
        }

        this.backgroundColor = GetStyle(color, this.canvas, this.context);
        this.backgroundColor2 = GetStyle(color2, this.canvas, this.context);
        this.backgroundHorizontalGradient = isHorizontalGradient;
        return this.update(false);
      }
    }, {
      key: "setBackgroundStrokeColor",
      value: function setBackgroundStrokeColor(color, lineWidth) {
        this.backgroundStrokeColor = GetStyle(color, this.canvas, this.context);
        this.backgroundStrokeLineWidth = lineWidth;
        return this.update(false);
      }
    }, {
      key: "setBackgroundCornerRadius",
      value: function setBackgroundCornerRadius(radius, iteration) {
        this.backgroundCornerRadius = radius;
        this.backgroundCornerIteration = iteration;
        return this.update(false);
      }
    }, {
      key: "setFill",
      value: function setFill(color) {
        this.color = GetStyle(color, this.canvas, this.context);
        return this.update(false);
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        this.color = GetStyle(color, this.canvas, this.context);
        return this.update(false);
      }
    }, {
      key: "setStroke",
      value: function setStroke(color, thickness) {
        if (color === undefined) {
          //  Reset the stroke to zero (disabling it)
          this.strokeThickness = 0;
        } else {
          if (thickness === undefined) {
            thickness = this.strokeThickness;
          }

          this.stroke = GetStyle(color, this.canvas, this.context);
          this.strokeThickness = thickness;
        }

        return this.update(true);
      }
    }, {
      key: "setShadow",
      value: function setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        if (x === undefined) {
          x = 0;
        }

        if (y === undefined) {
          y = 0;
        }

        if (color === undefined) {
          color = '#000';
        }

        if (blur === undefined) {
          blur = 0;
        }

        if (shadowStroke === undefined) {
          shadowStroke = false;
        }

        if (shadowFill === undefined) {
          shadowFill = true;
        }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;
        this.shadowColor = GetStyle(color, this.canvas, this.context);
        this.shadowBlur = blur;
        this.shadowStroke = shadowStroke;
        this.shadowFill = shadowFill;
        return this.update(false);
      }
    }, {
      key: "setShadowOffset",
      value: function setShadowOffset(x, y) {
        if (x === undefined) {
          x = 0;
        }

        if (y === undefined) {
          y = x;
        }

        this.shadowOffsetX = x;
        this.shadowOffsetY = y;
        return this.update(false);
      }
    }, {
      key: "setShadowColor",
      value: function setShadowColor(color) {
        if (color === undefined) {
          color = '#000';
        }

        this.shadowColor = GetStyle(color, this.canvas, this.context);
        return this.update(false);
      }
    }, {
      key: "setShadowBlur",
      value: function setShadowBlur(blur) {
        if (blur === undefined) {
          blur = 0;
        }

        this.shadowBlur = blur;
        return this.update(false);
      }
    }, {
      key: "setShadowStroke",
      value: function setShadowStroke(enabled) {
        this.shadowStroke = enabled;
        return this.update(false);
      }
    }, {
      key: "setShadowFill",
      value: function setShadowFill(enabled) {
        this.shadowFill = enabled;
        return this.update(false);
      }
    }, {
      key: "setUnderline",
      value: function setUnderline(color, thickness, offset) {
        if (color === undefined) {
          color = '#000';
        }

        if (thickness === undefined) {
          thickness = 0;
        }

        if (offset === undefined) {
          offset = 0;
        }

        this.underlineColor = GetStyle(color, this.canvas, this.context);
        this.underlineThickness = thickness;
        this.underlineOffset = offset;
        return this.update(false);
      }
    }, {
      key: "setUnderlineColor",
      value: function setUnderlineColor(color) {
        if (color === undefined) {
          color = '#000';
        }

        this.underlineColor = GetStyle(color, this.canvas, this.context);
        return this.update(false);
      }
    }, {
      key: "setUnderlineThickness",
      value: function setUnderlineThickness(thickness) {
        if (thickness === undefined) {
          thickness = 0;
        }

        this.underlineThickness = thickness;
        return this.update(false);
      }
    }, {
      key: "setUnderlineOffset",
      value: function setUnderlineOffset(offset) {
        if (offset === undefined) {
          offset = 0;
        }

        this.underlineOffset = offset;
        return this.update(false);
      }
    }, {
      key: "setWrapMode",
      value: function setWrapMode(mode) {
        if (typeof mode === 'string') {
          mode = WRAPMODE[mode.toLowerCase()] || 0;
        }

        this.wrapMode = mode;
        return this.update(true);
      }
    }, {
      key: "setWrapWidth",
      value: function setWrapWidth(width) {
        this.wrapWidth = width;
        return this.update(false);
      }
    }, {
      key: "setAlign",
      value: function setAlign(halign, valign) {
        if (halign === undefined) {
          halign = 'left';
        }

        if (valign === undefined) {
          valign = 'top';
        }

        this.halign = halign;
        this.valign = valign;
        return this.update(false);
      }
    }, {
      key: "setHAlign",
      value: function setHAlign(halign) {
        if (halign === undefined) {
          halign = 'left';
        }

        this.halign = halign;
        return this.update(false);
      }
    }, {
      key: "setVAlign",
      value: function setVAlign(valign) {
        if (valign === undefined) {
          valign = 'top';
        }

        this.valign = valign;
        return this.update(false);
      }
    }, {
      key: "setMaxLines",
      value: function setMaxLines(max) {
        if (max === undefined) {
          max = 0;
        }

        this.maxLines = max;
        return this.update(false);
      }
    }, {
      key: "getTextMetrics",
      value: function getTextMetrics() {
        var metrics = this.metrics;
        return {
          ascent: metrics.ascent,
          descent: metrics.descent,
          fontSize: metrics.fontSize
        };
      }
    }, {
      key: "setTextMetrics",
      value: function setTextMetrics(metrics, font) {
        this.metrics.ascent = metrics.ascent;
        this.metrics.descent = metrics.descent;
        this.metrics.fontSize = metrics.fontSize;

        if (typeof font === 'string') {
          this.fontFamily = font;
          this.fontSize = '';
          this.fontStyle = '';
        } else {
          this.fontFamily = GetValue$2z(font, 'fontFamily', this.fontFamily);
          this.fontSize = GetValue$2z(font, 'fontSize', this.fontSize);
          this.fontStyle = GetValue$2z(font, 'fontStyle', this.fontStyle);
        }

        return this.parent.updateText(true);
      }
    }, {
      key: "lineHeight",
      get: function get() {
        return this.metrics.fontSize + this.strokeThickness + this.lineSpacing;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var output = {};

        for (var key in propertyMap) {
          output[key] = this[key];
        }

        output.metrics = this.getTextMetrics();
        return output;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.parent = undefined;
      }
    }]);

    return TextStyle;
  }();
  var WRAPMODE = {
    none: CONST.NO_WRAP,
    word: CONST.WORD_WRAP,
    "char": CONST.CHAR_WRAP,
    character: CONST.CHAR_WRAP
  };

  var CanvasPool$1 = Phaser.Display.Canvas.CanvasPool;

  var MeasureTextMargins = function MeasureTextMargins(textStyle, testString, out) {
    if (out === undefined) {
      out = {};
    }

    var canvas = CanvasPool$1.create(this);
    var context = canvas.getContext('2d');
    textStyle.syncFont(canvas, context);
    var metrics = context.measureText(testString);
    var width = Math.ceil(metrics.width * textStyle.baselineX);
    var baseline = width;
    var height = 2 * baseline;
    baseline = baseline * textStyle.baselineY | 0;
    canvas.width = width;
    canvas.height = height;
    context.fillStyle = '#f00';
    context.fillRect(0, 0, width, height);
    context.font = textStyle._font;
    context.textBaseline = 'alphabetic';
    context.fillStyle = '#000';
    context.fillText(textStyle.testString, 0, baseline);
    out.left = 0;

    if (width === 0 || height === 0 || !context.getImageData(0, 0, width, height)) {
      CanvasPool$1.remove(canvas);
      return out;
    }

    var imagedata = context.getImageData(0, 0, width, height).data;
    var stop = false;

    for (var x = 0; x < width; x++) {
      for (var y = 0; y < height; y++) {
        var idx = (y * width + x) * 4;

        if (imagedata[idx] !== 255) {
          out.left = x;
          stop = true;
          break;
        }
      }

      if (stop) {
        break;
      }
    }

    CanvasPool$1.remove(canvas);
    return out;
  };

  var DrawMethods = {
    draw: function draw(startX, startY, textWidth, textHeight) {
      var penManager = this.penManager;
      this.hitAreaManager.clear();
      var context = this.context;
      context.save();
      var defaultStyle = this.defaultStyle;
      this.clear();
      DrawRoundRectangleBackground(this, defaultStyle.backgroundColor, defaultStyle.backgroundStrokeColor, defaultStyle.backgroundStrokeLineWidth, defaultStyle.backgroundCornerRadius, defaultStyle.backgroundColor2, defaultStyle.backgroundHorizontalGradient, defaultStyle.backgroundCornerIteration); // draw lines

      startX += this.startXOffset;
      startY += this.startYOffset;
      var defaultHalign = defaultStyle.halign,
          valign = defaultStyle.valign;
      var lineWidth,
          lineHeight = defaultStyle.lineHeight;
      var lines = penManager.lines;
      var totalLinesNum = lines.length,
          maxLines = defaultStyle.maxLines;
      var drawLinesNum, drawLineStartIdx, drawLineEndIdx;

      if (maxLines > 0 && totalLinesNum > maxLines) {
        drawLinesNum = maxLines;

        if (valign === 'center') {
          // center
          drawLineStartIdx = Math.floor((totalLinesNum - drawLinesNum) / 2);
        } else if (valign === 'bottom') {
          // bottom
          drawLineStartIdx = totalLinesNum - drawLinesNum;
        } else {
          drawLineStartIdx = 0;
        }
      } else {
        drawLinesNum = totalLinesNum;
        drawLineStartIdx = 0;
      }

      drawLineEndIdx = drawLineStartIdx + drawLinesNum;
      var offsetX, offsetY;
      var rtl = this.rtl,
          rtlOffset = rtl ? this.parent.width : undefined;

      if (valign === 'center') {
        // center
        offsetY = Math.max((textHeight - drawLinesNum * lineHeight) / 2, 0);
      } else if (valign === 'bottom') {
        // bottom
        offsetY = Math.max(textHeight - drawLinesNum * lineHeight - 2, 0);
      } else {
        offsetY = 0;
      }

      offsetY += startY;

      for (var lineIdx = drawLineStartIdx; lineIdx < drawLineEndIdx; lineIdx++) {
        lineWidth = penManager.getLineWidth(lineIdx);

        if (lineWidth === 0) {
          continue;
        }

        var pens = lines[lineIdx],
            penCount = pens.length;
        var halign = defaultHalign; // Seek if there has algin tag

        for (var penIdx = 0; penIdx < penCount; penIdx++) {
          var penAlign = pens[penIdx].prop.align;

          if (penAlign !== undefined) {
            halign = penAlign;
            break;
          }
        }

        if (halign === 'center') {
          // center
          offsetX = (textWidth - lineWidth) / 2;
        } else if (halign === 'right') {
          // right
          offsetX = !rtl ? textWidth - lineWidth : 0;
        } else {
          offsetX = !rtl ? 0 : textWidth - lineWidth;
        }

        offsetX += startX;

        for (var penIdx = 0; penIdx < penCount; penIdx++) {
          this.drawPen(pens[penIdx], offsetX, offsetY, rtlOffset);
        }
      }

      context.restore();
    },
    drawPen: function drawPen(pen, offsetX, offsetY, rtlOffset) {
      offsetX += pen.x;
      offsetY += pen.y + (pen.prop.y || 0);

      if (rtlOffset !== undefined) {
        offsetX = rtlOffset - offsetX;
      }

      var canvas = this.canvas;
      var context = this.context;
      context.save();
      var curStyle = this.parser.propToContextStyle(this.defaultStyle, pen.prop);
      curStyle.buildFont();
      curStyle.syncFont(canvas, context);
      curStyle.syncStyle(canvas, context); // Underline

      if (curStyle.underlineThickness > 0 && pen.width > 0) {
        this.drawUnderline(offsetX, offsetY, pen.width, curStyle);
      } // Text


      if (pen.isTextPen) {
        this.drawText(offsetX, offsetY, pen.text, curStyle);
      } // Image


      if (pen.isImagePen) {
        this.drawImage(offsetX, offsetY, pen.prop.img, curStyle);
      }

      context.restore();

      if (pen.hasAreaMarker && pen.width > 0) {
        this.hitAreaManager.add(pen.prop.area, // key
        offsetX, // x
        offsetY - this.startYOffset, // y
        pen.width, // width
        this.defaultStyle.lineHeight // height
        );
      }
    },
    clear: function clear() {
      var canvas = this.canvas;
      this.context.clearRect(0, 0, canvas.width, canvas.height);
    },
    drawUnderline: function drawUnderline(x, y, width, style) {
      y += style.underlineOffset - style.underlineThickness / 2;

      if (this.autoRound) {
        x = Math.round(x);
        y = Math.round(y);
      }

      var context = this.context;
      var savedLineCap = context.lineCap;
      context.lineCap = 'butt';
      context.strokeStyle = style.underlineColor;
      context.lineWidth = style.underlineThickness;
      context.beginPath();
      context.moveTo(x, y);
      context.lineTo(x + width, y);
      context.stroke();
      context.lineCap = savedLineCap;
    },
    drawText: function drawText(x, y, text, style) {
      if (this.autoRound) {
        x = Math.round(x);
        y = Math.round(y);
      }

      var context = this.context;

      if (style.stroke && style.stroke !== 'none' && style.strokeThickness > 0) {
        style.syncShadow(context, style.shadowStroke);
        context.strokeText(text, x, y);
      }

      if (style.color && style.color !== 'none') {
        style.syncShadow(context, style.shadowFill);
        context.fillText(text, x, y);
      }
    },
    drawImage: function drawImage(x, y, imgKey, style) {
      y -= this.startYOffset;
      this.parent.imageManager.draw(imgKey, this.context, x, y, this.autoRound);
    }
  };

  var GetValue$2y = Phaser.Utils.Objects.GetValue;
  var NO_NEWLINE$3 = CONST.NO_NEWLINE;
  var RAW_NEWLINE$1 = CONST.RAW_NEWLINE;

  var Pen = /*#__PURE__*/function () {
    function Pen(config) {
      _classCallCheck(this, Pen);

      this.prop = {};
      this.resetFromJSON(config);
    }

    _createClass(Pen, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        // (txt, x, y, width, prop, newLineMode, startIndex)
        this.text = GetValue$2y(o, 'text', '');
        this.x = GetValue$2y(o, 'x', 0);
        this.y = GetValue$2y(o, 'y', 0);
        this.width = GetValue$2y(o, 'width', 0);
        var prop = GetValue$2y(o, 'prop', null);

        if (prop === null) {
          prop = {};
        }

        this.prop = prop;
        this.newLineMode = GetValue$2y(o, 'newLineMode', 0);
        this.startIndex = GetValue$2y(o, 'startIndex', 0);
      }
    }, {
      key: "plainText",
      get: function get() {
        var txt = this.text;

        if (this.newLineMode === RAW_NEWLINE$1) {
          txt += "\n";
        }

        return txt;
      }
    }, {
      key: "wrapText",
      get: function get() {
        var txt = this.text;

        if (this.newLineMode !== NO_NEWLINE$3) {
          txt += "\n";
        }

        return txt;
      }
    }, {
      key: "rawTextLength",
      get: function get() {
        var len = this.text.length;

        if (this.newLineMode === RAW_NEWLINE$1) {
          len += 1;
        }

        return len;
      }
    }, {
      key: "endIndex",
      get: function get() {
        return this.startIndex + this.rawTextLength;
      }
    }, {
      key: "lastX",
      get: function get() {
        return this.x + this.width;
      }
    }, {
      key: "isTextPen",
      get: function get() {
        return this.text !== '';
      }
    }, {
      key: "isImagePen",
      get: function get() {
        return !!this.prop.img;
      }
    }, {
      key: "hasAreaMarker",
      get: function get() {
        return !!this.prop.area;
      }
    }]);

    return Pen;
  }();

  var GetFastValue$2 = Phaser.Utils.Objects.GetFastValue;
  var NO_NEWLINE$2 = CONST.NO_NEWLINE;
  var WRAPPED_NEWLINE$1 = CONST.WRAPPED_NEWLINE; // Reuse objects can increase performance

  var PensPool = new Stack(); // Default pens pool

  var LinesPool$1 = new Stack(); // Default lines pool

  var PenManager = /*#__PURE__*/function () {
    function PenManager(config) {
      _classCallCheck(this, PenManager);

      this.pens = []; // all pens

      this.lines = []; // pens in lines [ [],[],[],.. ]

      this.maxLinesWidth = undefined;
      this.PensPool = GetFastValue$2(config, 'pensPool', PensPool);
      this.LinesPool = GetFastValue$2(config, 'linesPool', LinesPool$1);
      this.tagToText = GetFastValue$2(config, 'tagToText', NOOP);
      this.tagToTextScope = GetFastValue$2(config, 'tagToTextScope', undefined);
    }

    _createClass(PenManager, [{
      key: "destroy",
      value: function destroy() {
        this.clear();
        this.tagToText = undefined;
        this.tagToTextScope = undefined;
      }
    }, {
      key: "clear",
      value: function clear() {
        for (var i = 0, len = this.lines.length; i < len; i++) {
          this.lines[i].length = 0;
        }

        this.PensPool.pushMultiple(this.pens);
        this.LinesPool.pushMultiple(this.lines);
        this.maxLinesWidth = undefined;
      }
    }, {
      key: "addTextPen",
      value: function addTextPen(text, x, y, width, prop, newLineMode) {
        var pen = this.PensPool.pop();

        if (pen == null) {
          pen = new Pen();
        }

        PEN_CONFIG.text = text;
        PEN_CONFIG.x = x;
        PEN_CONFIG.y = y;
        PEN_CONFIG.width = width;
        PEN_CONFIG.prop = prop;
        PEN_CONFIG.newLineMode = newLineMode;
        pen.resetFromJSON(PEN_CONFIG);
        this.addPen(pen);
        return this;
      }
    }, {
      key: "addImagePen",
      value: function addImagePen(x, y, width, prop) {
        this.addTextPen('', x, y, width, prop, NO_NEWLINE$2);
        return this;
      }
    }, {
      key: "addNewLinePen",
      value: function addNewLinePen() {
        var previousPen = this.lastPen;
        var x = previousPen ? previousPen.lastX : 0;
        var y = previousPen ? previousPen.y : 0;
        var prop = previousPen ? Clone(previousPen.prop) : null;
        this.addTextPen('', x, y, 0, prop, WRAPPED_NEWLINE$1);
        return this;
      }
    }, {
      key: "addPen",
      value: function addPen(pen) {
        var previousPen = this.lastPen;

        if (previousPen == null) {
          pen.startIndex = 0;
        } else {
          pen.startIndex = previousPen.endIndex;
        }

        this.pens.push(pen); // maintan lines

        var line = this.lastLine;

        if (line == null) {
          line = this.LinesPool.pop() || [];
          this.lines.push(line);
        }

        line.push(pen); // new line, add an empty line

        if (pen.newLineMode !== NO_NEWLINE$2) {
          line = this.LinesPool.pop() || [];
          this.lines.push(line);
        }

        this.maxLinesWidth = undefined;
      }
    }, {
      key: "clone",
      value: function clone(targetPenManager) {
        if (targetPenManager == null) targetPenManager = new PenManager();
        targetPenManager.clear();

        for (var li = 0, llen = this.lines.length; li < llen; li++) {
          var pens = this.lines[li];

          for (var pi = 0, plen = pens.length; pi < plen; pi++) {
            var pen = pens[pi];
            targetPenManager.addPen(pen.text, pen.x, pen.y, pen.width, Clone(pen.prop), pen.newLineMode);
          }
        }

        return targetPenManager;
      }
    }, {
      key: "lastPen",
      get: function get() {
        return this.pens[this.pens.length - 1];
      }
    }, {
      key: "lastLine",
      get: function get() {
        return this.lines[this.lines.length - 1];
      }
    }, {
      key: "getLineStartIndex",
      value: function getLineStartIndex(i) {
        if (i >= this.lines.length) {
          return this.getLineEndIndex(i);
        } else {
          var line = this.lines[i];
          return line && line[0] ? line[0].startIndex : 0;
        }
      }
    }, {
      key: "getLineEndIndex",
      value: function getLineEndIndex(i) {
        if (i >= this.lines.length) {
          i = this.lines.length - 1;
        }

        var li,
            hasLastPen = false,
            line;

        for (li = i; li >= 0; li--) {
          line = this.lines[li];
          hasLastPen = line != null && line.length > 0;

          if (hasLastPen) {
            break;
          }
        }

        if (!hasLastPen) {
          return 0;
        }

        var lastPen = line[line.length - 1];
        return lastPen.endIndex;
      }
    }, {
      key: "getLineWidth",
      value: function getLineWidth(i) {
        var line = this.lines[i];

        if (!line) {
          return 0;
        }

        var lastPen = line[line.length - 1];

        if (lastPen == null) {
          return 0;
        }

        var lineWidth = lastPen.lastX; // start from 0

        return lineWidth;
      }
    }, {
      key: "getMaxLineWidth",
      value: function getMaxLineWidth() {
        if (this.maxLinesWidth !== undefined) {
          return this.maxLinesWidth;
        }

        var w,
            maxW = 0;

        for (var i = 0, len = this.lines.length; i < len; i++) {
          w = this.getLineWidth(i);

          if (w > maxW) {
            maxW = w;
          }
        }

        this.maxLinesWidth = maxW;
        return maxW;
      }
    }, {
      key: "getLineWidths",
      value: function getLineWidths() {
        var result = [];

        for (var i = 0, len = this.lines.length; i < len; i++) {
          result.push(this.getLineWidth(i));
        }

        return result;
      }
    }, {
      key: "linesCount",
      get: function get() {
        return this.lines.length;
      }
    }, {
      key: "plainText",
      get: function get() {
        var txt = "",
            pens = this.pens;

        for (var i = 0, len = pens.length; i < len; i++) {
          txt += pens[i].plainText;
        }

        return txt;
      }
    }, {
      key: "rawTextLength",
      get: function get() {
        var l = 0,
            pens = this.pens;

        for (var i = 0, len = this.pens.length; i < len; i++) {
          l += pens[i].rawTextLength;
        }

        return l;
      }
    }, {
      key: "getSliceTagText",
      value: function getSliceTagText(start, end, wrap) {
        if (start === undefined) {
          start = 0;
        }

        if (end === undefined) {
          var lastPen = this.lastPen;

          if (lastPen == null) {
            return "";
          }

          end = lastPen.endIndex;
        }

        if (wrap === undefined) {
          wrap = false;
        }

        var txt = "",
            pen,
            penTxt,
            penStartIdx,
            penEndIdx,
            isInRange;
        var currentProp, previousProp;

        for (var i = 0, len = this.pens.length; i < len; i++) {
          pen = this.pens[i];
          penEndIdx = pen.endIndex;

          if (penEndIdx <= start) {
            continue;
          }

          pen = this.pens[i];
          penTxt = !wrap ? pen.plainText : pen.wrapText;
          currentProp = pen.prop;
          penStartIdx = pen.startIndex;
          isInRange = penStartIdx >= start && penEndIdx <= end;

          if (!isInRange) {
            penTxt = penTxt.substring(start - penStartIdx, end - penStartIdx);
          }

          if (this.tagToTextScope) {
            txt += this.tagToText.call(this.tagToTextScope, penTxt, currentProp, previousProp);
          } else {
            txt += this.tagToText(penTxt, currentProp, previousProp);
          }

          previousProp = currentProp;

          if (penEndIdx >= end) {
            break;
          }
        }

        return txt;
      }
    }, {
      key: "length",
      get: function get() {
        return this.lines.length;
      },
      set: function set(value) {
        // Only for set length to 0 (clear)
        this.clear();
      }
    }]);

    return PenManager;
  }();
  var PEN_CONFIG = {};

  var Rectangle$5 = Phaser.Geom.Rectangle;
  var RectanglePool = new Stack();

  var HitAreaManager = /*#__PURE__*/function () {
    function HitAreaManager() {
      _classCallCheck(this, HitAreaManager);

      this.hitAreas = [];
    }

    _createClass(HitAreaManager, [{
      key: "destroy",
      value: function destroy() {
        this.clear();
      }
    }, {
      key: "clear",
      value: function clear() {
        RectanglePool.pushMultiple(this.hitAreas);
        return this;
      }
    }, {
      key: "add",
      value: function add(key, x, y, width, height) {
        var rectangle = RectanglePool.pop();

        if (rectangle === null) {
          rectangle = new Rectangle$5(x, y, width, height);
        } else {
          rectangle.setTo(x, y, width, height);
        }

        rectangle.key = key;
        this.hitAreas.push(rectangle);
        return this;
      }
    }, {
      key: "getFirst",
      value: function getFirst(x, y) {
        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
          var hitArea = this.hitAreas[i];

          if (hitArea.contains(x, y)) {
            return hitArea;
          }
        }

        return null;
      }
    }, {
      key: "drawBounds",
      value: function drawBounds(graphics, color, parent) {
        if (color === undefined) {
          color = 0xffffff;
        }

        if (parent) {
          graphics.save().scaleCanvas(parent.scaleX, parent.scaleY).rotateCanvas(parent.rotation).translateCanvas(parent.x, parent.y);
        }

        for (var i = 0, cnt = this.hitAreas.length; i < cnt; i++) {
          var hitArea = this.hitAreas[i];
          graphics.lineStyle(1, color).strokeRect(hitArea.x, hitArea.y, hitArea.width, hitArea.height);
        }

        if (parent) {
          graphics.restore();
        }

        return this;
      }
    }]);

    return HitAreaManager;
  }();

  var SetInteractive = function SetInteractive() {
    this.parent.on('pointerdown', OnAreaDown, this).on('pointerup', OnAreaUp, this).on('pointermove', OnAreaOverOut, this).on('pointerover', OnAreaOverOut, this).on('pointerout', function (pointer, event) {
      OnAreaOverOut.call(this, pointer, null, null, event);
    }, this);
  };

  var OnAreaDown = function OnAreaDown(pointer, localX, localY, event) {
    var area = this.hitAreaManager.getFirst(localX, localY);

    if (area === null) {
      return;
    }

    FireEvent$2.call(this, 'areadown', area.key, pointer, localX, localY, event);
  };

  var OnAreaUp = function OnAreaUp(pointer, localX, localY, event) {
    var area = this.hitAreaManager.getFirst(localX, localY);

    if (area === null) {
      return;
    }

    FireEvent$2.call(this, 'areaup', area.key, pointer, localX, localY, event);
  };

  var OnAreaOverOut = function OnAreaOverOut(pointer, localX, localY, event) {
    if (localX === null) {
      // Case of pointerout
      if (this.lastHitAreaKey !== null) {
        FireEvent$2.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);
      }

      this.lastHitAreaKey = null;
      return;
    }

    var area = this.hitAreaManager.getFirst(localX, localY);
    var hitAreaKey = area ? area.key : null;

    if (this.lastHitAreaKey === hitAreaKey) {
      return;
    }

    if (this.lastHitAreaKey !== null) {
      FireEvent$2.call(this, 'areaout', this.lastHitAreaKey, pointer, localX, localY, event);
    }

    if (hitAreaKey !== null) {
      FireEvent$2.call(this, 'areaover', hitAreaKey, pointer, localX, localY, event);
    }

    this.lastHitAreaKey = hitAreaKey;
  };

  var FireEvent$2 = function FireEvent(eventName, key, pointer, localX, localY, event) {
    this.parent.emit("".concat(eventName, "-").concat(key), pointer, localX, localY, event);
    this.parent.emit(eventName, key, pointer, localX, localY, event);
  };

  var LinesPool = new Stack();

  var FreeLine = function FreeLine(line) {
    if (!line) {
      return;
    }

    LinesPool.push(line);
  };

  var FreeLines = function FreeLines(lines) {
    if (!lines) {
      return;
    }

    LinesPool.pushMultiple(lines);
  };

  var GetLine = function GetLine(text, width, newLineMode) {
    var l = LinesPool.pop();

    if (l === null) {
      l = {};
    }

    l.text = text;
    l.width = width;
    l.newLineMode = newLineMode;
    return l;
  };

  var NO_NEWLINE$1 = CONST.NO_NEWLINE;
  var RAW_NEWLINE = CONST.RAW_NEWLINE;
  var WRAPPED_NEWLINE = CONST.WRAPPED_NEWLINE;
  var NO_WRAP$1 = CONST.NO_WRAP;
  var WORD_WRAP = CONST.WORD_WRAP;
  var CHAR_WRAP = CONST.CHAR_WRAP;
  var splitRegExp = CONST.SPLITREGEXP;

  var WrapText = function WrapText(text, getTextWidth, wrapMode, wrapWidth, offset) {
    if (wrapWidth <= 0) {
      wrapMode = NO_WRAP$1;
    }

    var retLines = [];

    if (!text || !text.length) {
      return retLines;
    }

    var isNoWrap = wrapMode === NO_WRAP$1;
    var isWordWrap = wrapMode === WORD_WRAP;
    var lines = text.split(splitRegExp),
        line,
        remainWidth,
        newLineMode;

    for (var i = 0, linesLen = lines.length; i < linesLen; i++) {
      line = lines[i];
      newLineMode = i === linesLen - 1 ? NO_NEWLINE$1 : RAW_NEWLINE;

      if (isNoWrap) {
        var textWidth = getTextWidth(line);
        retLines.push(GetLine(line, textWidth, newLineMode));
        continue;
      }

      remainWidth = i === 0 ? wrapWidth - offset : wrapWidth; // short string testing

      if (line.length <= 100) {
        var textWidth = getTextWidth(line);

        if (textWidth <= remainWidth) {
          retLines.push(GetLine(line, textWidth, newLineMode));
          continue;
        }
      }

      var tokenArray, isSpaceCharacterEnd;

      if (isWordWrap) {
        // word mode
        tokenArray = line.split(' ');
        isSpaceCharacterEnd = tokenArray[tokenArray.length - 1] === '';

        if (isSpaceCharacterEnd) {
          tokenArray.length -= 1;
        }
      } else {
        tokenArray = line;
      }

      var token, tokenWidth, isLastToken;
      var lineText = '',
          lineWidth = 0;
      var currLineWidth;
      var whiteSpaceWidth = isWordWrap ? getTextWidth(' ') : undefined;

      for (var j = 0, tokenLen = tokenArray.length; j < tokenLen; j++) {
        token = tokenArray[j];
        tokenWidth = getTextWidth(token);
        isLastToken = j === tokenLen - 1;

        if (isWordWrap && (!isLastToken || isSpaceCharacterEnd)) {
          token += ' ';
          tokenWidth += whiteSpaceWidth;
        } // Text width of single token is larger than a line width


        if (isWordWrap && tokenWidth > wrapWidth) {
          if (lineText !== '') {
            // Has pending lineText, flush it out
            retLines.push(GetLine(lineText, lineWidth, WRAPPED_NEWLINE));
          } else if (j === 0 && offset > 0) {
            // No pending lineText, but has previous text. Append a newline
            retLines.push(GetLine('', 0, WRAPPED_NEWLINE));
          } // Word break


          retLines.push.apply(retLines, _toConsumableArray(WrapText(token, getTextWidth, CHAR_WRAP, wrapWidth, 0))); // Continue at last-wordBreak-line

          var lastwordBreakLine = retLines.pop();
          lineText = lastwordBreakLine.text;
          lineWidth = lastwordBreakLine.width; // Free this line

          FreeLine(lastwordBreakLine); // Special case : Start at a space character, discard it

          if (lineText === ' ') {
            lineText = '';
            lineWidth = 0;
          }

          continue;
        }

        currLineWidth = lineWidth + tokenWidth;

        if (currLineWidth > remainWidth) {
          // New line
          retLines.push(GetLine(lineText, lineWidth, WRAPPED_NEWLINE));
          lineText = token;
          lineWidth = tokenWidth;
          remainWidth = wrapWidth;
        } else {
          // Append token, continue
          lineText += token;
          lineWidth = currLineWidth;
        }

        if (isLastToken) {
          // Flush remain text
          retLines.push(GetLine(lineText, lineWidth, newLineMode));
        }
      } // for token in tokenArray

    } // for each line in lines


    return retLines;
  };

  var GetValue$2x = Phaser.Utils.Objects.GetValue;
  var NO_WRAP = CONST.NO_WRAP;
  var NO_NEWLINE = CONST.NO_NEWLINE;

  var CanvasText = /*#__PURE__*/function () {
    function CanvasText(config) {
      _classCallCheck(this, CanvasText);

      this.parent = config.parent;
      this.context = GetValue$2x(config, 'context', null);
      this.canvas = this.context.canvas;
      this.parser = GetValue$2x(config, 'parser', null);
      this.defaultStyle = GetValue$2x(config, 'style', null);
      this.autoRound = true;
      this.pensPool = GetValue$2x(config, 'pensPool', null);
      this.penManager = this.newPenManager();
      this._tmpPenManager = null;
      this.hitAreaManager = new HitAreaManager();
      this.lastHitAreaKey = null;
      var context = this.context;

      this.getTextWidth = function (text) {
        return context.measureText(text).width;
      };
    }

    _createClass(CanvasText, [{
      key: "destroy",
      value: function destroy() {
        this.context = undefined;
        this.canvas = undefined;
        this.parser = undefined;
        this.defaultStyle = undefined;

        if (this.penManager) {
          this.penManager.destroy();
          this.penManager = undefined;
        }

        if (this._tmpPenManager) {
          this._tmpPenManager.destroy();

          this._tmpPenManager = undefined;
        }

        if (this.hitAreaManager) {
          this.hitAreaManager.destroy();
          this.hitAreaManager = undefined;
        }
      }
    }, {
      key: "updatePenManager",
      value: function updatePenManager(text, wrapMode, wrapWidth, lineHeight, penManager) {
        if (penManager === undefined) {
          penManager = this.penManager;
        }

        penManager.clear();

        if (text === "") {
          return penManager;
        }

        var textStyle = this.parent.style;

        if (textStyle.isWrapFitMode) {
          var padding = this.parent.padding;
          wrapWidth = textStyle.fixedWidth - padding.left - padding.right;
        }

        var canvas = this.canvas;
        var context = this.context;

        var MeasureText = function MeasureText(text) {
          return context.measureText(text).width;
        };

        var cursorX = 0,
            cursorY = 0;
        var customTextWrapCallback = textStyle.wrapCallback,
            customTextWrapCallbackScope = textStyle.wrapCallbackScope;
        var reuseLines = true;
        var plainText, curProp, curStyle;
        var match = this.parser.splitText(text),
            result,
            wrapLines;

        for (var i = 0, len = match.length; i < len; i++) {
          result = this.parser.tagTextToProp(match[i], curProp);
          plainText = result.plainText;
          curProp = result.prop;

          if (curProp.img) {
            // Image tag                
            var imgWidth = this.imageManager.getOuterWidth(curProp.img);

            if (wrapWidth > 0 && wrapMode !== NO_WRAP) {
              // Wrap mode
              if (wrapWidth < cursorX + imgWidth) {
                penManager.addNewLinePen();
                cursorY += lineHeight;
                cursorX = 0;
              }
            }

            penManager.addImagePen(cursorX, cursorY, imgWidth, Clone(curProp));
            cursorX += imgWidth;
          } else if (plainText !== '') {
            // wrap text to lines
            // Save the current context.
            context.save();
            curStyle = this.parser.propToContextStyle(this.defaultStyle, curProp);
            curStyle.buildFont();
            curStyle.syncFont(canvas, context);
            curStyle.syncStyle(canvas, context);

            if (!customTextWrapCallback) {
              wrapLines = WrapText(plainText, MeasureText, wrapMode, wrapWidth, cursorX);
            } else {
              // customTextWrapCallback
              wrapLines = customTextWrapCallback.call(customTextWrapCallbackScope, plainText, MeasureText, wrapWidth, cursorX);

              if (typeof wrapLines === 'string') {
                wrapLines = wrapLines.split('\n');
              }

              var n;

              for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
                n = wrapLines[j];

                if (typeof n === 'string') {
                  wrapLines[j] = GetLine(n, MeasureText(n), j < jLen - 1 ? 2 : 0);
                } else {
                  reuseLines = false;
                }
              }
            } // customTextWrapCallback
            // add pens


            var n;

            for (var j = 0, jLen = wrapLines.length; j < jLen; j++) {
              n = wrapLines[j];
              penManager.addTextPen(n.text, cursorX, cursorY, n.width, Clone(curProp), n.newLineMode);

              if (n.newLineMode !== NO_NEWLINE) {
                cursorX = 0;
                cursorY += lineHeight;
              } else {
                cursorX += n.width;
              }
            }

            if (reuseLines) {
              FreeLines(wrapLines);
            }

            wrapLines = null;
            context.restore();
          }
        } // Add strokeThinkness to last pen of each line


        for (var i = 0, len = this.lines.length; i < len; i++) {
          var line = this.lines[i];
          var lastPen = line[line.length - 1];

          if (lastPen) {
            lastPen.width += this.parser.getStrokeThinkness(this.defaultStyle, lastPen.prop);
          }
        }

        return penManager;
      }
    }, {
      key: "startXOffset",
      get: function get() {
        var defaultStyle = this.defaultStyle;
        return defaultStyle.strokeThickness / 2 + defaultStyle.xOffset;
      }
    }, {
      key: "startYOffset",
      get: function get() {
        var defaultStyle = this.defaultStyle;
        return defaultStyle.strokeThickness / 2 + defaultStyle.metrics.ascent;
      }
    }, {
      key: "lines",
      get: function get() {
        return this.penManager.lines;
      }
    }, {
      key: "desplayLinesCount",
      get: function get() {
        var linesCount = this.penManager.linesCount,
            maxLines = this.defaultStyle.maxLines;

        if (maxLines > 0 && linesCount > maxLines) {
          linesCount = maxLines;
        }

        return linesCount;
      }
    }, {
      key: "linesWidth",
      get: function get() {
        return Math.ceil(this.penManager.getMaxLineWidth());
      }
    }, {
      key: "linesHeight",
      get: function get() {
        var linesCount = this.desplayLinesCount;
        var linesHeight = this.defaultStyle.lineHeight * linesCount;

        if (linesCount > 0) {
          linesHeight -= this.defaultStyle.lineSpacing;
        }

        return linesHeight;
      }
    }, {
      key: "imageManager",
      get: function get() {
        return this.parent.imageManager;
      }
    }, {
      key: "rtl",
      get: function get() {
        return this.parent.style.rtl;
      }
    }, {
      key: "newPenManager",
      value: function newPenManager() {
        return new PenManager({
          pensPool: this.pensPool,
          tagToText: this.parser.propToTagText,
          tagToTextScope: this.parser
        });
      }
    }, {
      key: "tmpPenManager",
      get: function get() {
        if (this._tmpPenManager === null) {
          this._tmpPenManager = this.newPenManager();
        }

        return this._tmpPenManager;
      }
    }, {
      key: "getPlainText",
      value: function getPlainText(text, start, end) {
        var plainText;

        if (text == null) {
          plainText = this.penManager.plainText;
        } else {
          var match = this.parser.splitText(text, 1); // PLAINTEXTONLY_MODE

          plainText = "";

          for (var i = 0, len = match.length; i < len; i++) {
            plainText += match[i];
          }
        }

        if (start != null || end != null) {
          if (start == null) {
            start = 0;
          }

          if (end == null) {
            end = plainText.length;
          }

          plainText = plainText.substring(start, end);
        }

        return plainText;
      }
    }, {
      key: "getPenManager",
      value: function getPenManager(text, retPenManager) {
        if (text === undefined) {
          return this.copyPenManager(retPenManager, this.penManager);
        }

        if (retPenManager === undefined) {
          retPenManager = this.newPenManager();
        }

        var defaultStyle = this.defaultStyle;
        this.updatePenManager(text, defaultStyle.wrapMode, defaultStyle.wrapWidth, defaultStyle.lineHeight, retPenManager);
        return retPenManager;
      }
    }, {
      key: "getText",
      value: function getText(text, start, end, wrap) {
        if (text == null) {
          return this.penManager.getSliceTagText(start, end, wrap);
        }

        var penManager = this.tmpPenManager;
        var defaultStyle = this.defaultStyle;
        this.updatePenManager(text, defaultStyle.wrapMode, defaultStyle.wrapWidth, defaultStyle.lineHeight, penManager);
        return penManager.getSliceTagText(start, end, wrap);
      }
    }, {
      key: "copyPenManager",
      value: function copyPenManager(ret, src) {
        if (src === undefined) {
          src = this.penManager;
        }

        return src.copy(ret);
      }
    }, {
      key: "getTextWidth",
      value: function getTextWidth(penManager) {
        if (penManager === undefined) {
          penManager = this.penManager;
        }

        return penManager.getMaxLineWidth();
      }
    }, {
      key: "getLastPen",
      value: function getLastPen(penManager) {
        if (penManager === undefined) {
          penManager = this.penManager;
        }

        return penManager.lastPen;
      }
    }]);

    return CanvasText;
  }();
  var methods$m = {
    setInteractive: SetInteractive
  };
  Object.assign(CanvasText.prototype, DrawMethods, methods$m);

  var GetValue$2w = Phaser.Utils.Objects.GetValue;

  var AddImage$1 = function AddImage(key, config) {
    if (config === undefined) {
      config = {
        key: key
      };
    }

    if (!config.hasOwnProperty('key')) {
      config.key = key;
    }

    var textureKey = config.key,
        frameKey = config.frame;
    var width = config.width,
        height = config.height;

    if (width === undefined || height === undefined) {
      var frame = this.textureManager.getFrame(textureKey, frameKey);
      var frameWidth = frame ? frame.cutWidth : 0;
      var frameHeight = frame ? frame.cutHeight : 0;

      if (width === undefined && height === undefined) {
        width = frameWidth;
        height = frameHeight;
      } else if (width === undefined) {
        width = frameWidth * (height / frameHeight);
      } else if (height === undefined) {
        height = frameHeight * (width / frameWidth);
      }
    }

    this.images[key] = {
      key: textureKey,
      frame: frameKey,
      width: width,
      height: height,
      y: GetValue$2w(config, 'y', 0),
      left: GetValue$2w(config, 'left', 0),
      right: GetValue$2w(config, 'right', 0)
    };
  };

  var DrawImage = function DrawImage(key, context, x, y, autoRound) {
    var imgData = this.get(key);
    x += imgData.left;
    y += imgData.y;

    if (autoRound) {
      x = Math.round(x);
      y = Math.round(y);
    }

    var frame = this.textureManager.getFrame(imgData.key, imgData.frame);
    context.drawImage(frame.source.image, frame.cutX, frame.cutY, frame.cutWidth, frame.cutHeight, x, y, imgData.width, imgData.height);
  };

  var ImageManager = /*#__PURE__*/function () {
    function ImageManager(scene) {
      _classCallCheck(this, ImageManager);

      this.textureManager = scene.sys.textures;
      this.images = {};
    }

    _createClass(ImageManager, [{
      key: "destroy",
      value: function destroy() {
        this.textureManager = undefined;
        this.images = undefined;
      }
    }, {
      key: "add",
      value: function add(key, config) {
        if (typeof key === 'string') {
          AddImage$1.call(this, key, config);
        } else if (Array.isArray(key)) {
          var data = key;

          for (var i = 0, cnt = data.length; i < cnt; i++) {
            AddImage$1.call(this, data[i]);
          }
        } else {
          var data = key;

          for (var key in data) {
            AddImage$1.call(this, key, data[key]);
          }
        }

        return this;
      }
    }, {
      key: "has",
      value: function has(key) {
        return this.images.hasOwnProperty(key);
      }
    }, {
      key: "remove",
      value: function remove(key) {
        if (this.has(key)) {
          delete this.images[key];
        }

        return this;
      }
    }, {
      key: "get",
      value: function get(key) {
        if (!this.has(key)) {
          if (this.textureManager.exists(key)) {
            this.add(key);
          }
        }

        return this.images[key];
      }
    }, {
      key: "getOuterWidth",
      value: function getOuterWidth(key) {
        var data = this.get(key);
        return data ? data.width + data.left + data.right : 0;
      }
    }, {
      key: "getFrame",
      value: function getFrame(key) {
        var data = this.get(key);
        return data ? this.textureManager.getFrame(data.key, data.frame) : undefined;
      }
    }, {
      key: "hasTexture",
      value: function hasTexture(key) {
        return !!this.getFrame(key);
      }
    }]);

    return ImageManager;
  }();

  var methods$l = {
    draw: DrawImage
  };
  Object.assign(ImageManager.prototype, methods$l);

  var IsPlainObject$u = Phaser.Utils.Objects.IsPlainObject;
  var AddToDOM = Phaser.DOM.AddToDOM;
  var CanvasPool = Phaser.Display.Canvas.CanvasPool;
  var GameObject = Phaser.GameObjects.GameObject;
  var GetValue$2v = Phaser.Utils.Objects.GetValue;
  var RemoveFromDOM = Phaser.DOM.RemoveFromDOM;
  var SPLITREGEXP = CONST.SPLITREGEXP;
  var PensPools = {};

  var Text = /*#__PURE__*/function (_GameObject) {
    _inherits(Text, _GameObject);

    var _super = _createSuper(Text);

    function Text(scene, x, y, text, style, type, parser) {
      var _this;

      _classCallCheck(this, Text);

      if (IsPlainObject$u(x)) {
        var config = x;
        x = GetValue$2v(config, 'x', 0);
        y = GetValue$2v(config, 'y', 0);
        text = GetValue$2v(config, 'text', '');
        style = GetValue$2v(config, 'style', '');
      }

      if (x === undefined) {
        x = 0;
      }

      if (y === undefined) {
        y = 0;
      }

      _this = _super.call(this, scene, type);
      _this.renderer = scene.sys.game.renderer;

      _this.setPosition(x, y);

      _this.setOrigin(0, 0);

      _this.initPipeline();

      _this.canvas = CanvasPool.create(_assertThisInitialized(_this));
      _this.context = _this.canvas.getContext('2d');
      _this._imageManager = undefined;

      if (style) {
        // Override align
        if (style.hasOwnProperty('align')) {
          var halign = style.align;
          delete style.align;
          style.halign = halign;
        } // Has Stroke color but stroke thinkness, set stroke thinkness to 1


        if (style.hasOwnProperty('stroke') && !style.hasOwnProperty('strokeThickness')) {
          style.strokeThickness = 1;
        }
      }

      _this.style = new TextStyle$1(_assertThisInitialized(_this), style);
      _this.autoRound = true;
      _this._text = undefined;
      _this.padding = {
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
      };
      _this.width = 1;
      _this.height = 1;
      _this.dirty = false; //  If resolution wasn't set, force it to 1

      if (_this.style.resolution === 0) {
        _this.style.resolution = 1;
      }

      _this._crop = _this.resetCropObject(); //  Create a Texture for this Text object

      _this.texture = scene.sys.textures.addCanvas(null, _this.canvas, true); //  Get the frame

      _this.frame = _this.texture.get(); //  Set the resolution

      _this.frame.source.resolution = _this.style.resolution;

      if (_this.renderer.gl) {
        //  Clear the default 1x1 glTexture, as we override it later
        _this.renderer.deleteTexture(_this.frame.source.glTexture);

        _this.frame.source.glTexture = null;
      }

      if (!PensPools.hasOwnProperty(type)) {
        PensPools[type] = new Stack();
      }

      _this.canvasText = new CanvasText({
        parent: _assertThisInitialized(_this),
        context: _this.context,
        parser: parser,
        style: _this.style,
        pensPool: PensPools[type]
      });
      _this.parser = parser;

      _this.initRTL();

      if (style && style.padding) {
        _this.setPadding(style.padding);
      }

      _this.setText(text);

      scene.sys.game.events.on('contextrestored', _this.onContextRestored, _assertThisInitialized(_this));
      return _this;
    }

    _createClass(Text, [{
      key: "onContextRestored",
      value: function onContextRestored() {
        this.dirty = true;
      }
    }, {
      key: "preDestroy",
      value: function preDestroy() {
        if (this.style.rtl) {
          RemoveFromDOM(this.canvas);
        }

        this.scene.sys.game.events.off('contextrestored', this.onContextRestored, this);
        this.canvasText.destroy();
        this.canvasText = undefined;

        if (this._imageManager) {
          this._imageManager.destroy();

          this._imageManager = undefined;
        }

        CanvasPool.remove(this.canvas);
        this.texture.destroy();
      }
    }, {
      key: "text",
      get: function get() {
        return this._text;
      },
      set: function set(value) {
        this.setText(value);
      }
    }, {
      key: "initRTL",
      value: function initRTL() {
        if (!this.style.rtl) {
          return;
        } //  Here is where the crazy starts.
        //
        //  Due to browser implementation issues, you cannot fillText BiDi text to a canvas
        //  that is not part of the DOM. It just completely ignores the direction property.


        this.canvas.dir = 'rtl'; //  Experimental atm, but one day ...

        this.context.direction = 'rtl'; //  Add it to the DOM, but hidden within the parent canvas.

        this.canvas.style.display = 'none';
        AddToDOM(this.canvas, this.scene.sys.canvas); //  And finally we set the x origin

        this.originX = 1;
      }
    }, {
      key: "setText",
      value: function setText(value) {
        if (value == null) {
          value = '';
        } else if (Array.isArray(value)) {
          value = value.join('\n');
        } else {
          value = value.toString();
        }

        if (value === this._text) {
          return this;
        }

        this._text = value;
        this.updateText();
        return this;
      }
    }, {
      key: "appendText",
      value: function appendText(value) {
        if (value == null) {
          return this;
        }

        if (Array.isArray(value)) {
          value = value.join('\n');
        }

        this.setText(this.text + value.toString());
        return this;
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {
        return this.style.setStyle(style);
      }
    }, {
      key: "setFont",
      value: function setFont(font) {
        return this.style.setFont(font);
      }
    }, {
      key: "setFontFamily",
      value: function setFontFamily(family) {
        return this.style.setFontFamily(family);
      }
    }, {
      key: "setFontSize",
      value: function setFontSize(size) {
        return this.style.setFontSize(size);
      }
    }, {
      key: "setFontStyle",
      value: function setFontStyle(style) {
        return this.style.setFontStyle(style);
      }
    }, {
      key: "setTestString",
      value: function setTestString(string) {
        return this.style.setTestString(string);
      }
    }, {
      key: "setFixedSize",
      value: function setFixedSize(width, height) {
        return this.style.setFixedSize(width, height);
      }
    }, {
      key: "setBackgroundColor",
      value: function setBackgroundColor(color, color2, isHorizontalGradient) {
        return this.style.setBackgroundColor(color, color2, isHorizontalGradient);
      }
    }, {
      key: "setBackgroundStrokeColor",
      value: function setBackgroundStrokeColor(color, lineWidth) {
        return this.style.setBackgroundStrokeColor(color, lineWidth);
      }
    }, {
      key: "setBackgroundCornerRadius",
      value: function setBackgroundCornerRadius(radius, iteration) {
        return this.style.setBackgroundCornerRadius(radius, iteration);
      }
    }, {
      key: "setFill",
      value: function setFill(color) {
        return this.style.setFill(color);
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        return this.style.setColor(color);
      }
    }, {
      key: "setStroke",
      value: function setStroke(color, thickness) {
        return this.style.setStroke(color, thickness);
      }
    }, {
      key: "setShadow",
      value: function setShadow(x, y, color, blur, shadowStroke, shadowFill) {
        return this.style.setShadow(x, y, color, blur, shadowStroke, shadowFill);
      }
    }, {
      key: "setShadowOffset",
      value: function setShadowOffset(x, y) {
        return this.style.setShadowOffset(x, y);
      }
    }, {
      key: "setShadowColor",
      value: function setShadowColor(color) {
        return this.style.setShadowColor(color);
      }
    }, {
      key: "setShadowBlur",
      value: function setShadowBlur(blur) {
        return this.style.setShadowBlur(blur);
      }
    }, {
      key: "setShadowStroke",
      value: function setShadowStroke(enabled) {
        return this.style.setShadowStroke(enabled);
      }
    }, {
      key: "setShadowFill",
      value: function setShadowFill(enabled) {
        return this.style.setShadowFill(enabled);
      }
    }, {
      key: "setWrapMode",
      value: function setWrapMode(mode) {
        return this.style.setWrapMode(mode);
      }
    }, {
      key: "setWrapWidth",
      value: function setWrapWidth(width) {
        return this.style.setWrapWidth(width);
      } // Align with built-in text game object

    }, {
      key: "setWordWrapWidth",
      value: function setWordWrapWidth(width) {
        return this.style.setWrapWidth(width);
      }
    }, {
      key: "setAlign",
      value: function setAlign(align) {
        return this.style.setHAlign(align);
      }
    }, {
      key: "setHAlign",
      value: function setHAlign(align) {
        return this.style.setHAlign(align);
      }
    }, {
      key: "setVAlign",
      value: function setVAlign(align) {
        return this.style.setVAlign(align);
      }
    }, {
      key: "setLineSpacing",
      value: function setLineSpacing(value) {
        return this.style.setLineSpacing(value);
      }
    }, {
      key: "setXOffset",
      value: function setXOffset(value) {
        return this.style.setXOffset(value);
      }
    }, {
      key: "setPadding",
      value: function setPadding(left, top, right, bottom) {
        if (_typeof(left) === 'object') {
          var config = left; //  If they specify x and/or y this applies to all

          var x = GetValue$2v(config, 'x', null);

          if (x !== null) {
            left = x;
            right = x;
          } else {
            left = GetValue$2v(config, 'left', 0);
            right = GetValue$2v(config, 'right', left);
          }

          var y = GetValue$2v(config, 'y', null);

          if (y !== null) {
            top = y;
            bottom = y;
          } else {
            top = GetValue$2v(config, 'top', 0);
            bottom = GetValue$2v(config, 'bottom', top);
          }
        } else {
          if (left === undefined) {
            left = 0;
          }

          if (top === undefined) {
            top = left;
          }

          if (right === undefined) {
            right = left;
          }

          if (bottom === undefined) {
            bottom = top;
          }
        }

        this.padding.left = left;
        this.padding.top = top;
        this.padding.right = right;
        this.padding.bottom = bottom;
        return this.updateText(false);
      }
    }, {
      key: "setMaxLines",
      value: function setMaxLines(max) {
        return this.style.setMaxLines(max);
      }
    }, {
      key: "setResolution",
      value: function setResolution(value) {
        return this.style.setResolution(value);
      }
    }, {
      key: "updateText",
      value: function updateText(runWrap) {
        if (runWrap === undefined) {
          runWrap = true;
        }

        var canvasText = this.canvasText; // wrap text to pens

        var style = this.style;

        if (runWrap) {
          canvasText.updatePenManager(this._text, style.wrapMode, style.wrapWidth, style.lineHeight);
        } // resize


        var padding = this.padding;
        var textWidth, textHeight;
        var linesWidth = Math.ceil(canvasText.linesWidth);

        if (style.fixedWidth === 0) {
          this.width = linesWidth + padding.left + padding.right;
          textWidth = linesWidth;
        } else {
          this.width = style.fixedWidth;
          textWidth = this.width - padding.left - padding.right;

          if (textWidth < linesWidth) {
            textWidth = linesWidth;
          }
        }

        if (style.fixedHeight === 0) {
          this.height = canvasText.linesHeight + padding.top + padding.bottom;
          textHeight = canvasText.linesHeight;
        } else {
          this.height = style.fixedHeight;
          textHeight = this.height - padding.top - padding.bottom;

          if (textHeight < canvasText.linesHeight) {
            textHeight = canvasText.linesHeight;
          }
        }

        var w = this.width;
        var h = this.height;
        this.updateDisplayOrigin();
        var resolution = style.resolution;
        w *= resolution;
        h *= resolution;
        w = Math.max(Math.ceil(w), 1);
        h = Math.max(Math.ceil(h), 1);
        var canvas = this.canvas;
        var context = this.context;

        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
          this.frame.setSize(w, h);
        } else {
          context.clearRect(0, 0, w, h);
        }

        context.save();
        context.scale(resolution, resolution); // draw

        var startX = !this.style.rtl ? padding.left : padding.right;
        var startY = padding.top;
        canvasText.draw(startX, startY, textWidth, textHeight);
        context.restore();

        if (this.renderer && this.renderer.gl) {
          this.frame.source.glTexture = this.renderer.canvasToTexture(canvas, this.frame.source.glTexture, true);
          this.frame.glTexture = this.frame.source.glTexture;
        }

        this.dirty = true;
        var input = this.input;

        if (input && !input.customHitArea) {
          input.hitArea.width = this.width;
          input.hitArea.height = this.height;
        }

        return this;
      }
    }, {
      key: "getTextMetrics",
      value: function getTextMetrics() {
        return this.style.getTextMetrics();
      }
    }, {
      key: "setTextMetrics",
      value: function setTextMetrics(metrics, font) {
        return this.style.setTextMetrics(metrics, font);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var out = Components$1.ToJSON(this); //  Extra Text data is added here

        var data = {
          autoRound: this.autoRound,
          text: this._text,
          style: this.style.toJSON(),
          resolution: this.resolution,
          padding: {
            left: this.padding.left,
            right: this.padding.right,
            top: this.padding.top,
            bottom: this.padding.bottom
          }
        };
        out.data = data;
        return out;
      }
    }, {
      key: "setInteractive",
      value: function setInteractive(hitArea, hitAreaCallback, dropZone) {
        var isInteractived = !!this.input;
        GameObject.prototype.setInteractive.call(this, hitArea, hitAreaCallback, dropZone);

        if (!isInteractived) {
          this.canvasText.setInteractive();
        }

        return this;
      }
    }, {
      key: "getWrappedText",
      value: function getWrappedText(text, start, end) {
        text = this.canvasText.getText(text, start, end, true);
        return text.split(SPLITREGEXP);
      }
    }, {
      key: "getPlainText",
      value: function getPlainText(text, start, end) {
        return this.canvasText.getPlainText(text, start, end);
      }
    }, {
      key: "getText",
      value: function getText(text, start, end, wrap) {
        if (wrap === undefined) {
          wrap = false;
        }

        return this.canvasText.getText(text, start, end, wrap);
      }
    }, {
      key: "getSubString",
      value: function getSubString(text, start, end) {
        return this.getText(text, start, end);
      }
    }, {
      key: "copyPenManager",
      value: function copyPenManager(penManager) {
        return this.canvasText.copyPenManager(penManager);
      }
    }, {
      key: "getPenManager",
      value: function getPenManager(text, penManager) {
        return this.canvasText.getPenManager(text, penManager);
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        return this.setFixedSize(width, height);
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        return this.setFixedSize(width, height);
      }
    }, {
      key: "lineSpacing",
      get: function get() {
        return this.style.lineSpacing;
      },
      set: function set(value) {
        this.setLineSpacing(value);
      }
    }, {
      key: "imageManager",
      get: function get() {
        if (!this._imageManager) {
          this._imageManager = new ImageManager(this.scene);
        }

        return this._imageManager;
      }
    }, {
      key: "addImage",
      value: function addImage(key, config) {
        this.imageManager.add(key, config);
        return this;
      }
    }, {
      key: "drawAreaBounds",
      value: function drawAreaBounds(graphics, color) {
        this.canvasText.hitAreaManager.drawBounds(graphics, color, this);
        return this;
      }
    }, {
      key: "measureTextMargins",
      value: function measureTextMargins(testString, out) {
        return MeasureTextMargins(this.style, testString, out);
      }
    }, {
      key: "generateTexture",
      value: function generateTexture(key, x, y, width, height) {
        var srcCanvas = this.canvas;

        if (width === undefined) {
          width = srcCanvas.width;
        } else {
          width *= this.resolution;
        }

        if (height === undefined) {
          height = srcCanvas.height;
        } else {
          height *= this.resolution;
        }

        CopyCanvasToTexture(this.scene, srcCanvas, key, x, y, width, height);
        return this;
      }
    }]);

    return Text;
  }(GameObject);

  var Components$1 = Phaser.GameObjects.Components;
  Phaser.Class.mixin(Text, [Components$1.Alpha, Components$1.BlendMode, Components$1.ComputedSize, Components$1.Crop, Components$1.Depth, Components$1.Flip, Components$1.GetBounds, Components$1.Mask, Components$1.Origin, Components$1.Pipeline, Components$1.ScrollFactor, Components$1.Tint, Components$1.Transform, Components$1.Visible, Render$1]);

  var GetOpenTagRegString = function GetOpenTagRegString(tagName, param) {
    if (param === undefined) {
      return "\\[".concat(tagName, "\\]");
    } else {
      return "\\[".concat(tagName, "=(").concat(param, ")\\]");
    }
  };

  var GetCloseTagRegString = function GetCloseTagRegString(tagName) {
    return "\\[/".concat(tagName, "\\]");
  };

  var NUMBER_PARAM = '[-.0-9]+';
  var COLOR_PARAM = '[a-z]+|#[0-9abcdef]+';
  var STR_PARAM = '[^\\]]+';
  var ESC = 'esc';
  var ESC_OPEN = GetOpenTagRegString(ESC);
  var ESC_CLOSE = GetCloseTagRegString(ESC);
  var RAW = 'raw';
  var RAW_OPEN = GetOpenTagRegString(RAW);
  var RAW_CLOSE = GetCloseTagRegString(RAW);
  var BLOD = 'b';
  var BLOD_OPEN = GetOpenTagRegString(BLOD);
  var BLOD_CLOSE = GetCloseTagRegString(BLOD);
  var ITALICS = 'i';
  var ITALICS_OPEN = GetOpenTagRegString(ITALICS);
  var ITALICS_CLOSE = GetCloseTagRegString(ITALICS);
  var SIZE = 'size';
  var SIZE_OPEN = GetOpenTagRegString(SIZE, NUMBER_PARAM);
  var SIZE_CLOSE = GetCloseTagRegString(SIZE);
  var COLOR = 'color';
  var COLOR_OPEN = GetOpenTagRegString(COLOR, COLOR_PARAM);
  var COLOR_CLOSE = GetCloseTagRegString(COLOR);
  var UNDERLINE = 'u';
  var UNDERLINE_OPEN = GetOpenTagRegString(UNDERLINE);
  var UNDERLINE_OPENC = GetOpenTagRegString(UNDERLINE, COLOR_PARAM);
  var UNDERLINE_CLOSE = GetCloseTagRegString(UNDERLINE);
  var SHADOW = 'shadow';
  var SHADOW_OPEN = GetOpenTagRegString(SHADOW);
  var SHADOW_CLOSE = GetCloseTagRegString(SHADOW);
  var STROKE = 'stroke';
  var STROKE_OPEN = GetOpenTagRegString(STROKE);
  var STROKE_OPENC = GetOpenTagRegString(STROKE, COLOR_PARAM);
  var STROKE_CLOSE = GetCloseTagRegString(STROKE);
  var OFFSETY = 'y';
  var OFFSETY_OPEN = GetOpenTagRegString(OFFSETY, NUMBER_PARAM);
  var OFFSETY_CLOSE = GetCloseTagRegString(OFFSETY);
  var IMAGE = 'img';
  var IMAGE_OPEN = GetOpenTagRegString(IMAGE, STR_PARAM);
  var IMAGE_CLOSE = GetCloseTagRegString(IMAGE);
  var AREA = 'area';
  var AREA_OPEN = GetOpenTagRegString(AREA, STR_PARAM);
  var AREA_CLOSE = GetCloseTagRegString(AREA);
  var ALIGN$2 = 'align';
  var ALIGN_OPEN = GetOpenTagRegString(ALIGN$2, STR_PARAM);
  var ALIGN_CLOSE = GetCloseTagRegString(ALIGN$2);
  var RE_ESC_OPEN = new RegExp(ESC_OPEN, 'i');
  var RE_ESC_CLOSE = new RegExp(ESC_CLOSE, 'i');
  var RE_RAW_OPEN = new RegExp(RAW_OPEN, 'i');
  var RE_RAW_CLOSE = new RegExp(RAW_CLOSE, 'i');
  var RE_BLOD_OPEN = new RegExp(BLOD_OPEN, 'i');
  var RE_BLOD_CLOSE = new RegExp(BLOD_CLOSE, 'i');
  var RE_ITALICS_OPEN = new RegExp(ITALICS_OPEN, 'i');
  var RE_ITALICS_CLOSE = new RegExp(ITALICS_CLOSE, 'i');
  var RE_SIZE_OPEN = new RegExp(SIZE_OPEN, 'i');
  var RE_SIZE_CLOSE = new RegExp(SIZE_CLOSE, 'i');
  var RE_COLOR_OPEN = new RegExp(COLOR_OPEN, 'i');
  var RE_COLOR_CLOSE = new RegExp(COLOR_CLOSE, 'i');
  var RE_UNDERLINE_OPEN = new RegExp(UNDERLINE_OPEN, 'i');
  var RE_UNDERLINE_OPENC = new RegExp(UNDERLINE_OPENC, 'i');
  var RE_UNDERLINE_CLOSE = new RegExp(UNDERLINE_CLOSE, 'i');
  var RE_SHADOW_OPEN = new RegExp(SHADOW_OPEN, 'i');
  var RE_SHADOW_CLOSE = new RegExp(SHADOW_CLOSE, 'i');
  var RE_STROKE_OPEN = new RegExp(STROKE_OPEN, 'i');
  var RE_STROKE_OPENC = new RegExp(STROKE_OPENC, 'i');
  var RE_STROKE_CLOSE = new RegExp(STROKE_CLOSE, 'i');
  var RE_OFFSETY_OPEN = new RegExp(OFFSETY_OPEN, 'i');
  var RE_OFFSETY_CLOSE = new RegExp(OFFSETY_CLOSE, 'i');
  var RE_IMAGE_OPEN = new RegExp(IMAGE_OPEN, 'i');
  var RE_IMAGE_CLOSE = new RegExp(IMAGE_CLOSE, 'i');
  var RE_AREA_OPEN = new RegExp(AREA_OPEN, 'i');
  var RE_AREA_CLOSE = new RegExp(AREA_CLOSE, 'i');
  var RE_ALIGN_OPEN = new RegExp(ALIGN_OPEN, 'i');
  var RE_ALIGN_CLOSE = new RegExp(ALIGN_CLOSE, 'i');
  var RE_SPLITTEXT$1 = new RegExp([RAW_OPEN, RAW_CLOSE, ESC_OPEN, ESC_CLOSE, BLOD_OPEN, BLOD_CLOSE, ITALICS_OPEN, ITALICS_CLOSE, SIZE_OPEN, SIZE_CLOSE, COLOR_OPEN, COLOR_CLOSE, UNDERLINE_OPEN, UNDERLINE_OPENC, UNDERLINE_CLOSE, SHADOW_OPEN, SHADOW_CLOSE, STROKE_OPEN, STROKE_OPENC, STROKE_CLOSE, OFFSETY_OPEN, OFFSETY_CLOSE, IMAGE_OPEN, IMAGE_CLOSE, AREA_OPEN, AREA_CLOSE, ALIGN_OPEN, ALIGN_CLOSE].join('|'), 'ig');

  var SplitText = function SplitText(text, mode) {
    var result = [];
    var charIdx = 0;
    var rawMode = false,
        escMode = false;

    while (true) {
      var regexResult = RE_SPLITTEXT$1.exec(text);

      if (!regexResult) {
        break;
      }

      var match = regexResult[0];

      if (escMode) {
        if (RE_ESC_CLOSE.test(match)) {
          escMode = false;
        } else {
          continue; // Skip other tags
        }
      } else if (rawMode) {
        if (RE_RAW_CLOSE.test(match)) {
          rawMode = false;
        } else {
          continue; // Skip other tags
        }
      } else {
        if (RE_ESC_OPEN.test(match)) {
          escMode = true;
        } else if (RE_RAW_OPEN.test(match)) {
          rawMode = true;
        }
      }

      var matchStart = RE_SPLITTEXT$1.lastIndex - match.length;

      if (charIdx < matchStart) {
        var content = text.substring(charIdx, matchStart);
        result.push(content);
      }

      if (mode === undefined) {
        result.push(match);
      }

      charIdx = RE_SPLITTEXT$1.lastIndex;
    }

    var totalLen = text.length;

    if (charIdx < totalLen) {
      // Push remainder string
      result.push(text.substring(charIdx, totalLen));
    }

    return result; // [text,...]
  };

  var PROP_REMOVE = false;
  var PROP_ADD = true;
  var GETPROP_RESULT$1 = {
    plainText: null,
    prevProp: null
  };

  var TagTextToProp = function TagTextToProp(text, prevProp) {
    // text : result of splitText()
    if (prevProp == null) {
      prevProp = {};
    }

    var plainText = ''; // close image tag

    if (prevProp.img) {
      UpdateProp(prevProp, PROP_REMOVE, 'img');
    }

    if (prevProp.esc) {
      if (RE_ESC_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'esc');
      } else {
        plainText = text;
      }
    } else if (prevProp.raw) {
      if (RE_RAW_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'raw');
      } else {
        plainText = text;
      }
    } else {
      if (RE_ESC_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'esc', true);
      } else if (RE_ESC_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'esc');
      } else if (RE_RAW_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'raw', true);
      } else if (RE_RAW_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'raw');
      } else if (RE_BLOD_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'b', true);
      } else if (RE_BLOD_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'b');
      } else if (RE_ITALICS_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'i', true);
      } else if (RE_ITALICS_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'i');
      } else if (RE_SIZE_OPEN.test(text)) {
        var innerMatch = text.match(RE_SIZE_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'size', "".concat(innerMatch[1], "px"));
      } else if (RE_SIZE_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'size');
      } else if (RE_COLOR_OPEN.test(text)) {
        var innerMatch = text.match(RE_COLOR_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'color', innerMatch[1]);
      } else if (RE_COLOR_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'color');
      } else if (RE_UNDERLINE_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'u', true);
      } else if (RE_UNDERLINE_OPENC.test(text)) {
        var innerMatch = text.match(RE_UNDERLINE_OPENC);
        UpdateProp(prevProp, PROP_ADD, 'u', innerMatch[1]);
      } else if (RE_UNDERLINE_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'u');
      } else if (RE_SHADOW_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'shadow', true);
      } else if (RE_SHADOW_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'shadow');
      } else if (RE_STROKE_OPEN.test(text)) {
        UpdateProp(prevProp, PROP_ADD, 'stroke', true);
      } else if (RE_STROKE_OPENC.test(text)) {
        var innerMatch = text.match(RE_STROKE_OPENC);
        UpdateProp(prevProp, PROP_ADD, 'stroke', innerMatch[1]);
      } else if (RE_STROKE_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'stroke');
      } else if (RE_OFFSETY_OPEN.test(text)) {
        var innerMatch = text.match(RE_OFFSETY_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'y', parseFloat(innerMatch[1]));
      } else if (RE_OFFSETY_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'y');
      } else if (RE_IMAGE_OPEN.test(text)) {
        var innerMatch = text.match(RE_IMAGE_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'img', innerMatch[1]);
      } else if (RE_IMAGE_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'img');
      } else if (RE_AREA_OPEN.test(text)) {
        var innerMatch = text.match(RE_AREA_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'area', innerMatch[1]);
      } else if (RE_AREA_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'area');
      } else if (RE_ALIGN_OPEN.test(text)) {
        var innerMatch = text.match(RE_ALIGN_OPEN);
        UpdateProp(prevProp, PROP_ADD, 'align', innerMatch[1]);
      } else if (RE_ALIGN_CLOSE.test(text)) {
        UpdateProp(prevProp, PROP_REMOVE, 'align');
      } else {
        plainText = text;
      }
    }

    var result = GETPROP_RESULT$1;
    result.plainText = plainText;
    result.prop = prevProp;
    return result;
  };

  var UpdateProp = function UpdateProp(prop, op, key, value) {
    if (op === PROP_ADD) {
      // PROP_ADD     
      prop[key] = value;
    } else {
      // PROP_REMOVE        
      if (prop.hasOwnProperty(key)) {
        delete prop[key];
      }
    }

    return prop;
  };

  var PropToContextStyle = function PropToContextStyle(defaultStyle, prop) {
    var result = STYLE_RESULT$1;

    if (!prop.hasOwnProperty('img')) {
      result.image = null;

      if (prop.hasOwnProperty('family')) {
        result.fontFamily = prop.family;
      } else {
        result.fontFamily = defaultStyle.fontFamily;
      }

      if (prop.hasOwnProperty('size')) {
        var size = prop.size;

        if (typeof size === 'number') {
          size = "".concat(size, "px");
        }

        result.fontSize = size;
      } else {
        result.fontSize = defaultStyle.fontSize;
      }

      result.fontStyle = GetFontStyle(prop.b, prop.i);

      if (prop.hasOwnProperty('color')) {
        result.color = prop.color;
      } else {
        result.color = defaultStyle.color;
      }

      if (prop.hasOwnProperty('stroke')) {
        if (prop.stroke === true) {
          result.stroke = defaultStyle.stroke;
          result.strokeThickness = defaultStyle.strokeThickness;
        } else {
          result.stroke = prop.stroke;
          result.strokeThickness = defaultStyle.strokeThickness;
        }
      } else {
        result.stroke = defaultStyle.stroke;
        result.strokeThickness = 0;
      }
    } else {
      result.image = prop.img;
    }

    if (prop.hasOwnProperty('shadow')) {
      if (prop.shadow === true) {
        result.shadowColor = defaultStyle.shadowColor;
        result.shadowOffsetX = defaultStyle.shadowOffsetX;
        result.shadowOffsetY = defaultStyle.shadowOffsetY;
        result.shadowBlur = defaultStyle.shadowBlur;
        result.shadowStroke = true;
        result.shadowFill = true;
      } else {
        result.shadowColor = prop.shadow;
        result.shadowOffsetX = defaultStyle.shadowOffsetX;
        result.shadowOffsetY = defaultStyle.shadowOffsetY;
        result.shadowBlur = defaultStyle.shadowBlur;
        result.shadowStroke = true;
        result.shadowFill = true;
      }
    } else {
      result.shadowColor = '#000';
      result.shadowOffsetX = 0;
      result.shadowOffsetY = 0;
      result.shadowBlur = 0;
      result.shadowStroke = false;
      result.shadowFill = false;
    }

    if (prop.hasOwnProperty('u')) {
      if (prop.u === true) {
        result.underlineColor = defaultStyle.underlineColor;
        result.underlineThickness = defaultStyle.underlineThickness;
        result.underlineOffset = defaultStyle.underlineOffset;
      } else {
        result.underlineColor = prop.u;
        result.underlineThickness = defaultStyle.underlineThickness;
        result.underlineOffset = defaultStyle.underlineOffset;
      }
    } else {
      result.underlineColor = '#000';
      result.underlineThickness = 0;
      result.underlineOffset = 0;
    }

    return result;
  };

  var GetFontStyle = function GetFontStyle(isBold, isItalic) {
    if (isBold && isItalic) {
      return 'bold italic';
    } else if (isBold) {
      return 'bold';
    } else if (isItalic) {
      return 'italic';
    } else {
      return '';
    }
  };

  var STYLE_RESULT$1 = new TextStyle$1();

  var PropToTagText = function PropToTagText(text, prop, prevProp) {
    if (prevProp == null) {
      prevProp = EMPTYPROP;
    }

    var headers = [];

    for (var k in prevProp) {
      if (!prop.hasOwnProperty(k)) {
        headers.push("[/".concat(k, "]"));
      }
    }

    for (var k in prop) {
      var value = prop[k];

      if (prevProp[k] === value) {
        continue;
      }

      switch (k) {
        case 'size':
          headers.push("[size=".concat(value.replace('px', ''), "]"));
          break;

        case 'color':
        case 'stroke':
        case 'y':
        case 'img':
        case 'area':
        case 'align':
          headers.push("[".concat(k, "=").concat(value, "]"));
          break;

        case 'u':
          if (value === true) {
            headers.push('[u]');
          } else {
            headers.push("[u=".concat(value, "]"));
          }

          break;

        default:
          headers.push("[".concat(k, "]"));
          break;
      }
    }

    headers.push(text);
    return headers.join('');
  };

  var EMPTYPROP = {};

  var Parser$2 = /*#__PURE__*/function () {
    function Parser() {
      _classCallCheck(this, Parser);
    }

    _createClass(Parser, [{
      key: "getStrokeThinkness",
      value: function getStrokeThinkness(defaultStyle, prop) {
        var strokeThickness;

        if (prop.hasOwnProperty('stroke')) {
          strokeThickness = defaultStyle.strokeThickness;
        } else {
          strokeThickness = 0;
        }

        return strokeThickness;
      }
    }]);

    return Parser;
  }();

  var methods$k = {
    splitText: SplitText,
    tagTextToProp: TagTextToProp,
    propToContextStyle: PropToContextStyle,
    propToTagText: PropToTagText
  };
  Object.assign(Parser$2.prototype, methods$k);

  var BBCodeText = /*#__PURE__*/function (_Text) {
    _inherits(BBCodeText, _Text);

    var _super = _createSuper(BBCodeText);

    function BBCodeText(scene, x, y, text, style) {
      _classCallCheck(this, BBCodeText);

      var parser = new Parser$2(style);
      return _super.call(this, scene, x, y, text, style, 'rexBBCodeText', parser);
    }

    return _createClass(BBCodeText);
  }(Text);

  ObjectFactory.register('BBCodeText', function (x, y, text, style) {
    var gameObject = new BBCodeText(this.scene, x, y, text, style);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.BBCodeText', BBCodeText);

  var GETPROP_RESULT = {
    plainText: null,
    prevProp: null
  };
  var STYLE_RESULT = new TextStyle$1();

  var Parser$1 = /*#__PURE__*/function () {
    function Parser(tags) {
      _classCallCheck(this, Parser);

      if (tags === undefined) {
        tags = {};
      }

      this.tags = tags;
    }

    _createClass(Parser, [{
      key: "addTag",
      value: function addTag(name, prop) {
        this.tags[name] = prop;
      }
    }, {
      key: "getTag",
      value: function getTag(name) {
        return this.tags[name];
      }
    }, {
      key: "splitText",
      value: function splitText(text, mode) {
        var result = [];
        var charIdx = 0;

        while (true) {
          var regexResult = RE_SPLITTEXT.exec(text);

          if (!regexResult) {
            break;
          }

          var match = regexResult[0];
          var matchStart = RE_SPLITTEXT.lastIndex - match.length;

          if (charIdx < matchStart) {
            result.push(text.substring(charIdx, matchStart));
          }

          if (mode === undefined) {
            result.push(match);
          } else if (mode === 1) {
            // RAWTEXTONLY_MODE
            if (RE_CLASS_HEADER.test(match)) {
              var innerMatch = match.match(RE_CLASS);
              result.push(innerMatch[2]);
            } else if (RE_STYLE_HEADER.test(match)) {
              var innerMatch = match.match(RE_STYLE);
              result.push(innerMatch[2]);
            }
          }

          charIdx = RE_SPLITTEXT.lastIndex;
        }

        var totalLen = text.length;

        if (charIdx < totalLen) {
          // Push remainder string
          result.push(text.substring(charIdx, totalLen));
        }

        return result; // [text,...]         
      }
    }, {
      key: "tagTextToProp",
      value: function tagTextToProp(text, prevProp) {
        var plainText, propOut;

        if (RE_CLASS_HEADER.test(text)) {
          var innerMatch = text.match(RE_CLASS);

          if (innerMatch != null) {
            var name = innerMatch[1];
            var tags = this.tags;

            if (tags.hasOwnProperty(name)) {
              propOut = tags[name];
            } else {
              propOut = {};
            }

            propOut._class = name;
            plainText = innerMatch[2];
          }
        } else if (RE_STYLE_HEADER.test(text)) {
          var innerMatch = text.match(RE_STYLE);

          if (innerMatch != null) {
            var style = innerMatch[1];
            propOut = StyleToProp(style);
            propOut._style = style;
            plainText = innerMatch[2];
          }
        }

        if (plainText == null) {
          plainText = text;
        }

        if (propOut == null) {
          propOut = {};
        }

        var result = GETPROP_RESULT;
        result.plainText = plainText;
        result.prop = propOut;
        return result;
      }
    }, {
      key: "propToContextStyle",
      value: function propToContextStyle(defaultStyle, prop) {
        var result = STYLE_RESULT;

        if (!prop.hasOwnProperty('img')) {
          result.image = null;

          if (prop.hasOwnProperty('family') || prop.hasOwnProperty('fontFamily') || prop.hasOwnProperty('font-family')) {
            var family = prop.hasOwnProperty('family') ? prop.family : prop.hasOwnProperty('fontFamily') ? prop.fontFamily : prop['font-family'];
            result.fontFamily = family;
          } else {
            result.fontFamily = defaultStyle.fontFamily;
          }

          if (prop.hasOwnProperty('size') || prop.hasOwnProperty('fontSize') || prop.hasOwnProperty('font-size')) {
            var size = prop.hasOwnProperty('size') ? prop.size : prop.hasOwnProperty('fontSize') ? prop.fontSize : prop['font-size'];

            if (typeof size === 'number') {
              size = "".concat(size, "px");
            }

            result.fontSize = size;
          } else {
            result.fontSize = defaultStyle.fontSize;
          }

          if (prop.hasOwnProperty('style') || prop.hasOwnProperty('fontStyle') || prop.hasOwnProperty('font-style')) {
            var fontStyle = prop.hasOwnProperty('style') ? prop.style : prop.hasOwnProperty('fontStyle') ? prop.fontStyle : prop['font-style'];
            result.fontStyle = fontStyle;
          } else {
            result.fontStyle = defaultStyle.fontStyle;
          }

          if (prop.hasOwnProperty('color') || prop.hasOwnProperty('font-color')) {
            var color = prop.hasOwnProperty('color') ? prop.color : prop['font-color'];
            result.color = color;
          } else {
            result.color = defaultStyle.color;
          }

          if (prop.hasOwnProperty('stroke')) {
            var stroke = prop.stroke; // {color, thickness}

            result.stroke = stroke.hasOwnProperty('color') ? stroke.color : defaultStyle.stroke;
            result.strokeThickness = stroke.hasOwnProperty('thickness') ? stroke.thickness : defaultStyle.strokeThickness;
          } else {
            result.stroke = defaultStyle.stroke;
            result.strokeThickness = defaultStyle.strokeThickness;
          }
        } else {
          result.image = prop.img;
        }

        if (prop.hasOwnProperty('shadow')) {
          var shadow = prop.shadow; // {color, offsetX, offsetY, blur}

          result.shadowColor = shadow.hasOwnProperty('color') ? shadow.color : defaultStyle.shadowColor;
          result.shadowOffsetX = shadow.hasOwnProperty('offsetX') ? shadow.offsetX : defaultStyle.shadowOffsetX;
          result.shadowOffsetY = shadow.hasOwnProperty('offsetY') ? shadow.offsetY : defaultStyle.shadowOffsetY;
          result.shadowBlur = shadow.hasOwnProperty('blur') ? shadow.blur : defaultStyle.shadowBlur;
          result.shadowStroke = true;
          result.shadowFill = true;
        } else {
          result.shadowColor = defaultStyle.shadowColor;
          result.shadowOffsetX = defaultStyle.shadowOffsetX;
          result.shadowOffsetY = defaultStyle.shadowOffsetY;
          result.shadowBlur = defaultStyle.shadowBlur;
          result.shadowStroke = defaultStyle.shadowStroke;
          result.shadowFill = defaultStyle.shadowFill;
        }

        if (prop.hasOwnProperty('u') || prop.hasOwnProperty('underline')) {
          var u = prop.hasOwnProperty('u') ? prop.u : prop.underline; // {color, thickness, offset}

          result.underlineColor = u.hasOwnProperty('color') ? u.color : defaultStyle.underlineColor;
          result.underlineThickness = u.hasOwnProperty('thickness') ? u.thickness : defaultStyle.underlineThickness;
          result.underlineOffset = u.hasOwnProperty('offset') ? u.offset : defaultStyle.underlineOffset;
        } else {
          result.underlineColor = defaultStyle.underlineColor;
          result.underlineThickness = defaultStyle.underlineThickness;
          result.underlineOffset = defaultStyle.underlineOffset;
        }

        return result;
      }
    }, {
      key: "getStrokeThinkness",
      value: function getStrokeThinkness(defaultStyle, prop) {
        var strokeThinkness;

        if (prop.hasOwnProperty('stroke')) {
          var stroke = prop.stroke; // {color, thickness}           

          strokeThinkness = stroke.hasOwnProperty('thickness') ? stroke.thickness : defaultStyle.strokeThickness;
        } else {
          strokeThinkness = defaultStyle.strokeThickness;
        }

        return strokeThinkness;
      }
    }, {
      key: "propToTagText",
      value: function propToTagText(text, prop, prevProp) {
        if (prop.hasOwnProperty('_class')) {
          // class mode
          if (text === '') {
            if (this.isTextTag(prop._class)) {
              return '';
            }
          }

          return "<class='".concat(prop._class, "'>").concat(text, "</class>");
        } else if (prop.hasOwnProperty('_style')) {
          // class mode
          return "<style='".concat(prop._style, "'>").concat(text, "</style>");
        } else {
          return text;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.tags = undefined;
      }
    }, {
      key: "isTextTag",
      value: function isTextTag(tagName) {
        var tag = this.tags[tagName];

        if (tag) {
          return tag.img == null;
        } else {
          // tag not found
          return false;
        }
      }
    }]);

    return Parser;
  }();

  var StyleToProp = function StyleToProp(s) {
    s = s.split(";");
    var result = {},
        prop,
        k,
        v;

    for (var i = 0, slen = s.length; i < slen; i++) {
      prop = s[i].split(":");
      k = prop[0], v = prop[1];

      if (isEmpty(k) || isEmpty(v)) {
        continue;
      }

      switch (k) {
        case 'stroke':
          var stroke = v.split(' '); // stroke:blue 1px

          var len = stroke.length;
          v = {};

          if (len >= 1) {
            v.color = stroke[0];
          }

          if (len >= 2) {
            v.thickness = parseInt(stroke[1].replace('px', ''));
          }

          break;

        case 'shadow':
          var shadow = v.split(' '); // shadow:blue 2px 2px 2px

          var len = shadow.length;
          v = {};

          if (len >= 1) {
            v.color = shadow[0];
          }

          if (len >= 2) {
            v.offsetX = parseInt(shadow[1].replace('px', ''));
          }

          if (len >= 3) {
            v.offsetY = parseInt(shadow[2].replace('px', ''));
          }

          if (len >= 4) {
            v.blur = parseInt(shadow[3].replace('px', ''));
          }

          break;

        case 'u':
        case 'underline':
          // underline:blue 3px -1px
          var u = v.split(' ');
          var len = u.length;
          v = {};

          if (len >= 1) {
            v.color = u[0];
          }

          if (len >= 2) {
            v.thickness = parseInt(u[1].replace('px', ''));
          }

          if (len >= 3) {
            v.offset = parseInt(u[2].replace('px', ''));
          }

          break;

        case 'y':
          v = parseFloat(v);
          break;
      }

      result[k] = v;
    }

    return result;
  };

  var isEmpty = function isEmpty(s) {
    // Remove white spaces.
    s = s.replace(RE_SPACE, '');
    return s.length === 0;
  };

  var RE_SPLITTEXT = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>|<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/g;
  var RE_CLASS_HEADER = /<\s*class=/i;
  var RE_CLASS = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>/;
  var RE_STYLE_HEADER = /<\s*style=/i;
  var RE_STYLE = /<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/;
  var RE_SPACE = /^\s+|\s+$/;

  var GetValue$2u = Phaser.Utils.Objects.GetValue;

  var TagText = /*#__PURE__*/function (_Text) {
    _inherits(TagText, _Text);

    var _super = _createSuper(TagText);

    function TagText(scene, x, y, text, style) {
      _classCallCheck(this, TagText);

      var tags = GetValue$2u(style, 'tags', undefined);
      var parser = new Parser$1(tags);
      return _super.call(this, scene, x, y, text, style, 'rexTagText', parser);
    }

    _createClass(TagText, [{
      key: "addTag",
      value: function addTag(name, prop) {
        this.parser.addTag(name, prop);
        return this.updateText(true);
      }
    }, {
      key: "addTags",
      value: function addTags(tags) {
        for (var name in tags) {
          this.parser.addTag(name, tags[name]);
        }

        return this.updateText(true);
      }
    }, {
      key: "getTag",
      value: function getTag(name) {
        return this.parser.getTag(name);
      }
    }, {
      key: "preDestroy",
      value: function preDestroy() {
        _get(_getPrototypeOf(TagText.prototype), "preDestroy", this).call(this);

        this.parser.destroy();
        this.parser = undefined;
      }
    }]);

    return TagText;
  }(Text);

  ObjectFactory.register('tagText', function (x, y, text, style) {
    var gameObject = new TagText(this.scene, x, y, text, style);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.TagText', TagText);

  var Resize = function Resize(width, height) {
    if (this.scene.sys.scale.autoRound) {
      width = Math.floor(width);
      height = Math.floor(height);
    }

    if (this.width === width && this.height === height) {
      return this;
    }

    var style = this.node.style;
    style.width = "".concat(width, "px");
    style.height = "".concat(height, "px");
    this.updateSize();
    return this;
  };

  var GetValue$2t = Phaser.Utils.Objects.GetValue;

  var SetProperties = function SetProperties(properties, config, out) {
    if (out === undefined) {
      out = {};
    }

    var property, value;

    for (var key in properties) {
      property = properties[key]; // [propName, defaultValue]

      value = GetValue$2t(config, key, property[1]);

      if (value !== undefined) {
        out[property[0]] = value;
      }
    }

    return out;
  };

  var RouteEvents = function RouteEvents(gameObject, element, elementEvents) {
    var _loop = function _loop(elementEventName) {
      // Note: Don't use `var` here
      element.addEventListener(elementEventName, function (e) {
        gameObject.emit(elementEvents[elementEventName], gameObject, e);
      });
    };

    for (var elementEventName in elementEvents) {
      _loop(elementEventName);
    }
  };

  var StopPropagationTouchEvents = function StopPropagationTouchEvents(element) {
    // Don't propagate touch/mouse events to parent(game canvas)
    element.addEventListener('touchstart', callback, false);
    element.addEventListener('touchmove', callback, false);
    element.addEventListener('touchend', callback, false);
    element.addEventListener('mousedown', callback, false);
    element.addEventListener('mouseup', callback, false);
    element.addEventListener('mousemove', callback, false);
  };

  var callback = function callback(e) {
    e.stopPropagation();
  };

  var DOMElement = Phaser.GameObjects.DOMElement;
  var IsPlainObject$t = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$2s = Phaser.Utils.Objects.GetValue;

  var InputText = /*#__PURE__*/function (_DOMElement) {
    _inherits(InputText, _DOMElement);

    var _super = _createSuper(InputText);

    function InputText(scene, x, y, width, height, config) {
      var _this;

      _classCallCheck(this, InputText);

      if (IsPlainObject$t(x)) {
        config = x;
        x = GetValue$2s(config, 'x', 0);
        y = GetValue$2s(config, 'y', 0);
        width = GetValue$2s(config, 'width', 0);
        height = GetValue$2s(config, 'height', 0);
      } else if (IsPlainObject$t(width)) {
        config = width;
        width = GetValue$2s(config, 'width', 0);
        height = GetValue$2s(config, 'height', 0);
      }

      if (config === undefined) {
        config = {};
      }

      var element;
      var textType = GetValue$2s(config, 'type', 'text');

      if (textType === 'textarea') {
        element = document.createElement('textarea');
        element.style.resize = 'none';
      } else {
        element = document.createElement('input');
        element.type = textType;
      }

      SetProperties(ElementProperties, config, element);
      var style = GetValue$2s(config, 'style', undefined);
      style = SetProperties(StyleProperties, config, style); // Apply other style properties

      var elementStyle = element.style;

      for (var key in config) {
        if (key in ElementProperties || key in StyleProperties) {
          continue;
        } else if (key in elementStyle) {
          style[key] = config[key];
        }
      }

      style['box-sizing'] = 'border-box';
      _this = _super.call(this, scene, x, y, element, style);
      _this.type = 'rexInputText';

      _this.resize(width, height); // Apply events


      RouteEvents(_assertThisInitialized(_this), element, ElementEvents); // Don't propagate touch/mouse events to parent(game canvas)

      StopPropagationTouchEvents(element);

      if (GetValue$2s(config, 'selectAll', false)) {
        _this.selectAll();
      }

      _this._isFocused = false;

      _this.on('focus', function () {
        this._isFocused = true;
      }, _assertThisInitialized(_this)).on('blur', function () {
        this._isFocused = false;
      }, _assertThisInitialized(_this));

      return _this;
    }

    _createClass(InputText, [{
      key: "text",
      get: function get() {
        return this.node.value;
      },
      set: function set(value) {
        this.node.value = value;
      }
    }, {
      key: "setText",
      value: function setText(value) {
        // Override
        this.text = value;
        return this;
      }
    }, {
      key: "maxLength",
      get: function get() {
        return this.node.maxLength;
      },
      set: function set(value) {
        this.node.maxLength = value;
      }
    }, {
      key: "setMaxLength",
      value: function setMaxLength(value) {
        this.maxLength = value;
        return this;
      }
    }, {
      key: "minLength",
      get: function get() {
        return this.node.minLength;
      },
      set: function set(value) {
        this.node.minLength = value;
      }
    }, {
      key: "setMinLength",
      value: function setMinLength(value) {
        this.minLength = value;
        return this;
      }
    }, {
      key: "placeholder",
      get: function get() {
        return this.node.placeholder;
      },
      set: function set(value) {
        this.node.placeholder = value;
      }
    }, {
      key: "setPlaceholder",
      value: function setPlaceholder(value) {
        this.placeholder = value;
        return this;
      }
    }, {
      key: "selectText",
      value: function selectText(selectionStart, selectionEnd) {
        if (selectionStart === undefined) {
          this.node.select();
        } else {
          this.node.setSelectionRange(selectionStart, selectionEnd);
        }

        return this;
      }
    }, {
      key: "selectAll",
      value: function selectAll() {
        this.selectText();
        return this;
      }
    }, {
      key: "selectionStart",
      get: function get() {
        return this.node.selectionStart;
      }
    }, {
      key: "selectionEnd",
      get: function get() {
        return this.node.selectionEnd;
      }
    }, {
      key: "selectedText",
      get: function get() {
        var node = this.node;
        return node.value.substring(node.selectionStart, node.selectionEnd);
      }
    }, {
      key: "cursorPosition",
      get: function get() {
        return this.node.selectionStart;
      }
    }, {
      key: "tooltip",
      get: function get() {
        return this.node.title;
      },
      set: function set(value) {
        this.node.title = value;
      }
    }, {
      key: "setTooltip",
      value: function setTooltip(value) {
        this.tooltip = value;
        return this;
      }
    }, {
      key: "setTextChangedCallback",
      value: function setTextChangedCallback(callback) {
        this.onTextChanged = callback;
        return this;
      }
    }, {
      key: "readOnly",
      get: function get() {
        return this.node.readOnly;
      },
      set: function set(value) {
        this.node.readOnly = value;
      }
    }, {
      key: "setReadOnly",
      value: function setReadOnly(value) {
        if (value === undefined) {
          value = true;
        }

        this.readOnly = value;
        return this;
      }
    }, {
      key: "spellCheck",
      get: function get() {
        return this.node.spellcheck;
      },
      set: function set(value) {
        this.node.spellcheck = value;
      }
    }, {
      key: "setSpellCheck",
      value: function setSpellCheck(value) {
        this.spellCheck = value;
        return this;
      }
    }, {
      key: "fontColor",
      get: function get() {
        return this.node.style.color;
      },
      set: function set(value) {
        this.node.style.color = value;
      }
    }, {
      key: "setFontColor",
      value: function setFontColor(value) {
        this.fontColor = value;
        return this;
      }
    }, {
      key: "setStyle",
      value: function setStyle(key, value) {
        this.node.style[key] = value;
        return this;
      }
    }, {
      key: "getStyle",
      value: function getStyle(key) {
        return this.node.style[key];
      }
    }, {
      key: "scrollToBottom",
      value: function scrollToBottom() {
        this.node.scrollTop = this.node.scrollHeight;
        return this;
      }
    }, {
      key: "setEnabled",
      value: function setEnabled(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }

        this.node.disabled = !enabled;
        return this;
      }
    }, {
      key: "setBlur",
      value: function setBlur() {
        this.node.blur();
        return this;
      }
    }, {
      key: "setFocus",
      value: function setFocus() {
        this.node.focus();
        return this;
      }
    }, {
      key: "isFocused",
      get: function get() {
        return this._isFocused;
      }
    }]);

    return InputText;
  }(DOMElement);

  var methods$j = {
    resize: Resize
  };
  Object.assign(InputText.prototype, methods$j);
  var ElementProperties = {
    id: ['id', undefined],
    text: ['value', undefined],
    maxLength: ['maxLength', undefined],
    minLength: ['minLength', undefined],
    placeholder: ['placeholder', undefined],
    tooltip: ['title', undefined],
    readOnly: ['readOnly', false],
    spellCheck: ['spellcheck', false],
    autoComplete: ['autocomplete', 'off']
  };
  var StyleProperties = {
    align: ['textAlign', undefined],
    paddingLeft: ['padding-left', undefined],
    paddingRight: ['padding-right', undefined],
    paddingTop: ['padding-top', undefined],
    paddingBottom: ['padding-bottom', undefined],
    fontFamily: ['fontFamily', undefined],
    fontSize: ['font-size', undefined],
    color: ['color', '#ffffff'],
    backgroundColor: ['backgroundColor', 'transparent'],
    border: ['border', 0],
    borderColor: ['borderColor', 'transparent'],
    outline: ['outline', 'none'],
    direction: ['direction', undefined]
  };
  var ElementEvents = {
    input: 'textchange',
    click: 'click',
    dblclick: 'dblclick',
    mousedown: 'pointerdown',
    mousemove: 'pointermove',
    mouseup: 'pointerup',
    touchstart: 'pointerdown',
    touchmove: 'pointermove',
    touchend: 'pointerup',
    keydown: 'keydown',
    keyup: 'keyup',
    keypress: 'keypress',
    focus: 'focus',
    blur: 'blur',
    select: 'select'
  };

  var IsPointerInHitArea = function IsPointerInHitArea(gameObject, pointer, preTest, postTest) {
    if (pointer) {
      if (preTest && !preTest(gameObject, pointer)) {
        return false;
      }

      if (!HitTest(gameObject, pointer)) {
        return false;
      }

      if (postTest && !postTest(gameObject, pointer)) {
        return false;
      }

      return true;
    } else {
      var inputManager = gameObject.scene.input.manager;
      var pointersTotal = inputManager.pointersTotal;
      var pointers = inputManager.pointers,
          pointer;

      for (var i = 0; i < pointersTotal; i++) {
        pointer = pointers[i];

        if (preTest && !preTest(gameObject, pointer)) {
          continue;
        }

        if (!HitTest(gameObject, pointer)) {
          continue;
        }

        if (postTest && !postTest(gameObject, pointer)) {
          continue;
        }

        return true;
      }

      return false;
    }
  };

  var HitTest = function HitTest(gameObject, pointer) {
    var scene = gameObject.scene;
    var cameras = scene.input.cameras.getCamerasBelowPointer(pointer);
    var inputManager = scene.input.manager;
    var gameObjects = [gameObject];
    var output;

    for (var i = 0, len = cameras.length; i < len; i++) {
      output = inputManager.hitTest(pointer, gameObjects, cameras[i]);

      if (output.length > 0) {
        return true;
      }
    }

    return false;
  };

  var GetValue$2r = Phaser.Utils.Objects.GetValue;
  var Wrap = Phaser.Math.Wrap;

  var HiddenInputText = /*#__PURE__*/function (_InputText) {
    _inherits(HiddenInputText, _InputText);

    var _super = _createSuper(HiddenInputText);

    function HiddenInputText(textObject, config) {
      var _this;

      _classCallCheck(this, HiddenInputText);

      _this = _super.call(this, textObject.scene, config); // Note: Don't add this game object into scene
      // Set style

      var style = _this.node.style;
      style.position = 'absolute';
      style.opacity = 0;
      style.pointerEvents = 'none';
      style.zIndex = 0; // hide native blue text cursor on iOS

      style.transform = 'scale(0)';

      _this.setCursor(GetValue$2r(config, 'cursor', '|'));

      _this.setCursorFlashDuration(GetValue$2r(config, 'cursorFlashDuration', 1000));

      _this.cursorFlashTimer = 0;

      _this.setEnterClose(GetValue$2r(config, 'enterClose', true));

      _this.onOpenCallback = GetValue$2r(config, 'onOpen', undefined);
      _this.onCloseCallback = GetValue$2r(config, 'onClose', undefined);
      _this.onUpdateCallback = GetValue$2r(config, 'onUpdate', undefined);
      _this.textObject = textObject;
      textObject.setInteractive().on('pointerdown', _this.setFocus, _assertThisInitialized(_this)).on('destroy', _this.destroy, _assertThisInitialized(_this));

      _this.on('focus', function () {
        this.cursorFlashTimer = 0;

        if (this.enterClose) {
          this.scene.input.keyboard.once('keydown-ENTER', this.setBlur, this);
        }

        this.setText(this.textObject.text);
        this.scene.sys.events.on('postupdate', this.updateText, this);
        this.scene.input.on('pointerdown', this.onClickOutside, this);

        if (this.onOpenCallback) {
          this.onOpenCallback(this.textObject, this);
        }
      }, _assertThisInitialized(_this)).on('blur', function () {
        this.updateText();
        this.scene.sys.events.off('postupdate', this.updateText, this);
        this.scene.input.off('pointerdown', this.onClickOutside, this);

        if (this.onCloseCallback) {
          this.onCloseCallback(this.textObject, this);
        }
      }, _assertThisInitialized(_this));

      return _this;
    }

    _createClass(HiddenInputText, [{
      key: "preDestroy",
      value: function preDestroy() {
        this.textObject.off('pointerdown', this.setFocus, this);
        this.textObject.off('destroy', this.destroy, this);
        this.scene.sys.events.off('postupdate', this.updateText, this);
        this.scene.input.off('pointerdown', this.onClickOutside, this);

        _get(_getPrototypeOf(HiddenInputText.prototype), "preDestroy", this).call(this);
      }
    }, {
      key: "onClickOutside",
      value: function onClickOutside(pointer) {
        if (!IsPointerInHitArea(this.textObject, pointer)) {
          this.setBlur();
        }
      }
    }, {
      key: "updateText",
      value: function updateText() {
        var text = this.text;

        if (this.onUpdateCallback) {
          var newText = this.onUpdateCallback(text, this.textObject, this);

          if (newText) {
            text = newText;
          }
        }

        if (this.isFocused && this.hasCursor) {
          // Insert Cursor
          var cursorPosition = this.cursorPosition;
          text = text.substring(0, cursorPosition) + this.cursor + text.substring(cursorPosition);
        }

        this.textObject.setText(text);
        return this;
      }
    }, {
      key: "setCursor",
      value: function setCursor(s) {
        this._cursor = s;
        this.hasCursor = s && s !== '';
        return s;
      }
    }, {
      key: "setCursorFlashDuration",
      value: function setCursorFlashDuration(duration) {
        this.cursorFlashDuration = duration;
        return this;
      }
    }, {
      key: "cursor",
      get: function get() {
        if (!this._isFocused) {
          return this._cursor;
        } // Flash Cursor


        var cursor;

        if (this.cursorFlashTimer < this.cursorFlashDuration / 2) {
          cursor = this._cursor;
        } else {
          cursor = ' ';
        }

        var timerValue = this.cursorFlashTimer + this.scene.game.loop.delta;
        this.cursorFlashTimer = Wrap(timerValue, 0, this.cursorFlashDuration);
        return cursor;
      }
    }, {
      key: "setEnterClose",
      value: function setEnterClose(value) {
        if (value === undefined) {
          value = true;
        }

        this.enterClose = value;
        return this;
      }
    }, {
      key: "open",
      value: function open() {
        this.setFocus();
        return this;
      }
    }, {
      key: "close",
      value: function close() {
        this.setBlur();
        return this;
      }
    }, {
      key: "isOpened",
      get: function get() {
        return this._isFocused;
      }
    }]);

    return HiddenInputText;
  }(InputText);

  ObjectFactory.register('hiddenEdit', function (textObject, config) {
    var gameObject = new HiddenInputText(textObject, config); // Note: Don't add this game object into scene

    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.HiddenEdit', HiddenInputText);

  var Zone$1 = Phaser.GameObjects.Zone;
  var AddItem = Phaser.Utils.Array.Add;
  var RemoveItem$a = Phaser.Utils.Array.Remove;

  var Base$2 = /*#__PURE__*/function (_Zone) {
    _inherits(Base, _Zone);

    var _super = _createSuper(Base);

    function Base(scene, x, y, width, height) {
      var _this;

      _classCallCheck(this, Base);

      if (x === undefined) {
        x = 0;
      }

      if (y === undefined) {
        y = 0;
      }

      if (width === undefined) {
        width = 1;
      }

      if (height === undefined) {
        height = 1;
      }

      _this = _super.call(this, scene, x, y, width, height);
      _this.children = [];
      return _this;
    }

    _createClass(Base, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        if (fromScene) {
          // Stop scene
          var child;

          for (var i = this.children.length - 1; i >= 0; i--) {
            child = this.children[i];

            if (!child.parentContainer && // Not in container
            !child.displayList // Not in scene, neither in layer
            ) {
              // Destroy child which is not in scene, container, or layer manually
              child.destroy(fromScene);
            }
          }
        } // Destroy/remove children


        this.clear(!fromScene);

        _get(_getPrototypeOf(Base.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "contains",
      value: function contains(gameObject) {
        return this.children.indexOf(gameObject) !== -1;
      }
    }, {
      key: "add",
      value: function add(gameObjects) {
        var parent = this;
        AddItem(this.children, gameObjects, 0, // Callback of item added
        function (gameObject) {
          gameObject.once('destroy', parent.onChildDestroy, parent);
        }, this);
        return this;
      }
    }, {
      key: "remove",
      value: function remove(gameObjects, destroyChild) {
        var parent = this;
        RemoveItem$a(this.children, gameObjects, // Callback of item removed
        function (gameObject) {
          gameObject.off('destroy', parent.onChildDestroy, parent);

          if (destroyChild) {
            gameObject.destroy();
          }
        });
        return this;
      }
    }, {
      key: "onChildDestroy",
      value: function onChildDestroy(child, fromScene) {
        // Only remove reference
        this.remove(child, false);
      }
    }, {
      key: "clear",
      value: function clear(destroyChild) {
        var parent = this;
        var gameObject;

        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
          gameObject = this.children[i];
          gameObject.off('destroy', parent.onChildDestroy, parent);

          if (destroyChild) {
            gameObject.destroy();
          }
        }

        this.children.length = 0;
        return this;
      }
    }]);

    return Base;
  }(Zone$1);

  var Components = Phaser.GameObjects.Components;
  Phaser.Class.mixin(Base$2, [Components.Alpha, Components.Flip]);

  var GetParent = function GetParent(gameObject, name) {
    var parent;

    if (name === undefined) {
      if (gameObject.hasOwnProperty('rexContainer')) {
        parent = gameObject.rexContainer.parent;
      }
    } else {
      parent = GetParent(gameObject);

      while (parent) {
        if (parent.name === name) {
          break;
        }

        parent = GetParent(parent);
      }
    }

    return parent;
  };

  var GetTopmostParent = function GetTopmostParent(gameObject) {
    var parent = GetParent(gameObject);

    while (parent) {
      gameObject = parent;
      parent = GetParent(parent);
    }

    return gameObject;
  };

  var DegToRad$8 = Phaser.Math.DegToRad;
  var RadToDeg$5 = Phaser.Math.RadToDeg;

  var GetLocalState = function GetLocalState(gameObject) {
    if (!gameObject.hasOwnProperty('rexContainer')) {
      var rexContainer = {
        parent: null,
        self: null,
        x: 0,
        y: 0,
        syncPosition: true,
        rotation: 0,
        syncRotation: true,
        scaleX: 0,
        scaleY: 0,
        syncScale: true,
        alpha: 0,
        syncAlpha: true,
        visible: true,
        active: true
      };
      Object.defineProperty(rexContainer, 'angle', {
        get: function get() {
          return RadToDeg$5(this.rotation);
        },
        set: function set(value) {
          this.rotation = DegToRad$8(value);
        }
      });
      Object.defineProperty(rexContainer, 'displayWidth', {
        get: function get() {
          return gameObject.width * this.scaleX;
        },
        set: function set(width) {
          this.scaleX = width / gameObject.width;
        }
      });
      Object.defineProperty(rexContainer, 'displayHeight', {
        get: function get() {
          return gameObject.height * this.scaleY;
        },
        set: function set(height) {
          this.scaleY = height / gameObject.height;
        }
      });
      gameObject.rexContainer = rexContainer;
    }

    return gameObject.rexContainer;
  };

  var Parent = {
    setParent: function setParent(gameObject, parent) {
      if (parent === undefined) {
        parent = this;
      }

      var localState = GetLocalState(gameObject);

      if (parent) {
        // Add to parent
        localState.parent = parent;
        localState.self = gameObject;
      } else {
        // Remove from parent
        localState.parent = null;
        localState.self = null;
      }

      return this;
    },
    getParent: function getParent(gameObject, name) {
      if (typeof gameObject === 'string') {
        name = gameObject;
        gameObject = undefined;
      }

      if (gameObject === undefined) {
        gameObject = this;
      }

      return GetParent(gameObject, name);
    },
    getTopmostParent: function getTopmostParent(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }

      return GetTopmostParent(gameObject);
    }
  };

  var GetValue$2q = Phaser.Utils.Objects.GetValue;
  var BaseAdd = Base$2.prototype.add;

  var Add$8 = function Add(gameObject, config) {
    this.setParent(gameObject);
    var state = GetLocalState(gameObject);
    SetupSyncFlags(state, config);
    this.resetChildState(gameObject) // Reset local state of child
    .updateChildVisible(gameObject) // Apply parent's visible to child
    .updateChildActive(gameObject) // Apply parent's active to child
    .updateChildScrollFactor(gameObject) // Apply parent's scroll factor to child
    .updateChildMask(gameObject); // Apply parent's mask to child

    BaseAdd.call(this, gameObject);
    return this;
  };

  var AddLocal = function AddLocal(gameObject, config) {
    this.setParent(gameObject); // Set local state from child directly

    var state = GetLocalState(gameObject);
    SetupSyncFlags(state, config); // Position

    state.x = gameObject.x;
    state.y = gameObject.y;
    state.rotation = gameObject.rotation;
    state.scaleX = gameObject.scaleX;
    state.scaleY = gameObject.scaleY; // Alpha

    state.alpha = gameObject.alpha; // Visible

    state.visible = gameObject.visible; // Active

    state.active = gameObject.active;
    this.updateChildPosition(gameObject).updateChildAlpha(gameObject).updateChildVisible(gameObject) // Apply parent's visible to child
    .updateChildActive(gameObject) // Apply parent's active to child
    .updateChildScrollFactor(gameObject) // Apply parent's scroll factor to child
    .updateChildMask(gameObject); // Apply parent's mask to child

    BaseAdd.call(this, gameObject);
    return this;
  };

  var SetupSyncFlags = function SetupSyncFlags(state, config) {
    state.syncPosition = GetValue$2q(config, 'syncPosition', true);
    state.syncRotation = GetValue$2q(config, 'syncRotation', true);
    state.syncScale = GetValue$2q(config, 'syncScale', true);
    state.syncAlpha = GetValue$2q(config, 'syncAlpha', true);
  };

  var AddChild$2 = {
    // Can override this method
    add: function add(gameObject) {
      if (Array.isArray(gameObject)) {
        this.addMultiple(gameObject);
      } else {
        Add$8.call(this, gameObject);
      }

      return this;
    },
    // Don't override this method
    pin: function pin(gameObject, config) {
      if (Array.isArray(gameObject)) {
        this.addMultiple(gameObject, config);
      } else {
        Add$8.call(this, gameObject, config);
      }

      return this;
    },
    addMultiple: function addMultiple(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Add$8.call(this, gameObjects[i]);
      }

      return this;
    },
    addLocal: function addLocal(gameObject) {
      if (Array.isArray(gameObject)) {
        this.addMultiple(gameObject);
      } else {
        AddLocal.call(this, gameObject);
      }

      return this;
    },
    // Don't override this method
    pinLocal: function pinLocal(gameObject, config) {
      if (Array.isArray(gameObject)) {
        this.addMultiple(gameObject, config);
      } else {
        AddLocal.call(this, gameObject, config);
      }

      return this;
    },
    addLocalMultiple: function addLocalMultiple(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        AddLocal.call(this, gameObjects[i]);
      }

      return this;
    }
  };

  var BaseRemove = Base$2.prototype.remove;
  var BaseClear = Base$2.prototype.clear;
  var RemoveChild$2 = {
    remove: function remove(gameObject, destroyChild) {
      if (GetParent(gameObject) !== this) {
        return this;
      }

      this.setParent(gameObject, null);
      BaseRemove.call(this, gameObject, destroyChild);
      return this;
    },
    clear: function clear(destroyChild) {
      for (var i = 0, cnt = this.children.length; i < cnt; i++) {
        this.setParent(this.children[i], null);
      }

      BaseClear.call(this, destroyChild);
      return this;
    }
  };

  var ChildState = {
    getLocalState: function getLocalState(gameObject) {
      return GetLocalState(gameObject);
    },
    resetChildState: function resetChildState(gameObject) {
      this.resetChildPositionState(gameObject).resetChildVisibleState(gameObject).resetChildAlphaState(gameObject).resetChildActiveState(gameObject);
      return this;
    },
    resetChildrenState: function resetChildrenState(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        this.resetChildState(gameObjects[i]);
      }

      return this;
    },
    syncProperties: function syncProperties() {
      this.syncPosition().syncVisible().syncAlpha().syncActive().syncScrollFactor().syncMask();
      return this;
    }
  };

  var RotateAround$5 = Phaser.Math.RotateAround;
  var Transform = {
    worldToLocal: function worldToLocal(point) {
      // Transform
      point.x -= this.x;
      point.y -= this.y; // Rotate

      RotateAround$5(point, 0, 0, -this.rotation); // Scale

      point.x /= this.scaleX;
      point.y /= this.scaleY;
      return point;
    },
    localToWorld: function localToWorld(point) {
      // Scale
      point.x *= this.scaleX;
      point.y *= this.scaleY; // Rotate

      RotateAround$5(point, 0, 0, this.rotation); // Transform

      point.x += this.x;
      point.y += this.y;
      return point;
    }
  };

  var GetScale = function GetScale(a, b) {
    if (a === b) {
      return 1;
    } else {
      return a / b;
    }
  };

  var Position = {
    updateChildPosition: function updateChildPosition(child) {
      if (child.isRexContainerLite) {
        child.syncChildrenEnable = false;
      }

      var state = GetLocalState(child);
      var parent = state.parent;

      if (state.syncPosition) {
        child.x = state.x;
        child.y = state.y;
        parent.localToWorld(child);
      }

      if (state.syncRotation) {
        child.rotation = state.rotation + parent.rotation;
      }

      if (state.syncScale) {
        child.scaleX = state.scaleX * parent.scaleX;
        child.scaleY = state.scaleY * parent.scaleY;
      }

      if (child.isRexContainerLite) {
        child.syncChildrenEnable = true;
        child.syncPosition();
      }

      return this;
    },
    syncPosition: function syncPosition() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildPosition, this);
      }

      return this;
    },
    resetChildPositionState: function resetChildPositionState(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      state.x = child.x;
      state.y = child.y;
      parent.worldToLocal(state);
      state.scaleX = GetScale(child.scaleX, parent.scaleX);
      state.scaleY = GetScale(child.scaleY, parent.scaleY);
      state.rotation = child.rotation - parent.rotation;
      return this;
    },
    setChildPosition: function setChildPosition(child, x, y) {
      child.x = x;
      child.y = y;
      this.resetChildPositionState(child);
      return this;
    },
    setChildLocalPosition: function setChildLocalPosition(child, x, y) {
      var state = GetLocalState(child);
      state.x = x;
      state.y = y;
      this.updateChildPosition(child);
      return this;
    },
    resetLocalPositionState: function resetLocalPositionState() {
      var parent = GetLocalState(this).parent;

      if (parent) {
        parent.resetChildPositionState(this);
      }

      return this;
    }
  };

  var DegToRad$7 = Phaser.Math.DegToRad;
  var Rotation = {
    updateChildRotation: function updateChildRotation(child) {
      var state = GetLocalState(child);
      var parent = state.parent;

      if (state.syncRotation) {
        child.rotation = parent.rotation + state.rotation;
      }

      return this;
    },
    syncRotation: function syncRotation() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildRotation, this);
      }

      return this;
    },
    resetChildRotationState: function resetChildRotationState(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      state.rotation = child.rotation - parent.rotation;
      return this;
    },
    setChildRotation: function setChildRotation(child, rotation) {
      child.rotation = rotation;
      this.resetChildRotationState(child);
      return this;
    },
    setChildAngle: function setChildAngle(child, angle) {
      child.angle = angle;
      this.resetChildRotationState(child);
      return this;
    },
    setChildLocalRotation: function setChildLocalRotation(child, rotation) {
      var state = GetLocalState(child);
      state.rotation = rotation;
      this.updateChildRotation(child);
      return this;
    },
    setChildLocalAngle: function setChildLocalAngle(child, angle) {
      var state = GetLocalState(child);
      state.rotation = DegToRad$7(angle);
      this.updateChildRotation(child);
      return this;
    },
    resetLocalRotationState: function resetLocalRotationState() {
      var parent = GetLocalState(this).parent;

      if (parent) {
        parent.resetChildRotationState(this);
      }

      return this;
    }
  };

  var Scale$1 = {
    updateChildScale: function updateChildScale(child) {
      var state = GetLocalState(child);
      var parent = state.parent;

      if (state.syncScale) {
        child.scaleX = parent.scaleX * state.scaleX;
        child.scaleY = parent.scaleY * state.scaleY;
      }

      return this;
    },
    syncScale: function syncScale() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildScale, this);
      }

      return this;
    },
    resetChildScaleState: function resetChildScaleState(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      state.scaleX = GetScale(child.scaleX, parent.scaleX);
      state.scaleY = GetScale(child.scaleY, parent.scaleY);
      return this;
    },
    setChildScale: function setChildScale(child, scaleX, scaleY) {
      if (scaleY === undefined) {
        scaleY = scaleX;
      }

      child.scaleX = scaleX;
      child.scaleY = scaleY;
      this.resetChildScaleState(child);
      return this;
    },
    setChildLocalScale: function setChildLocalScale(child, scaleX, scaleY) {
      if (scaleY === undefined) {
        scaleY = scaleX;
      }

      var state = GetLocalState(child);
      state.scaleX = scaleX;
      state.scaleY = scaleY;
      this.updateChildScale(child);
      return this;
    },
    setChildDisplaySize: function setChildDisplaySize(child, width, height) {
      child.setDisplaySize(width, height);
      this.resetChildScaleState(child);
      return this;
    },
    resetLocalScaleState: function resetLocalScaleState() {
      var parent = GetLocalState(this).parent;

      if (parent) {
        parent.resetChildScaleState(this);
      }

      return this;
    }
  };

  /*

  Visible in localState:

    - visible: original visible of child
    - maskVisible: invisible by parent mask, see MaskChildren.js
        - undefined (not in masking) : Equal to mask visible
        - true (mask visible) : Inside, or across parent's visible area
        - false (maske invisible) : Out of parent's visible area

  Visible result of child = (parent visible) && (child visible) && (mask visible)
  */
  var Visible$1 = {
    updateChildVisible: function updateChildVisible(child) {
      var localState = GetLocalState(child);
      var parent = localState.parent;
      var maskVisible = localState.hasOwnProperty('maskVisible') ? localState.maskVisible : true;
      child.visible = parent.visible && localState.visible && maskVisible;
      return this;
    },
    syncVisible: function syncVisible() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildVisible, this);
      }

      return this;
    },
    resetChildVisibleState: function resetChildVisibleState(child) {
      var localState = GetLocalState(child); // Delete maskVisible property

      if (localState.hasOwnProperty('maskVisible')) {
        delete localState.maskVisible;
      }

      localState.visible = child.visible;
      return this;
    },
    setChildVisible: function setChildVisible(child, visible) {
      // Visible of child will be affect by parent's visible, and mask visible
      this.setChildLocalVisible(child, visible);
      return this;
    },
    // Internal method
    setChildLocalVisible: function setChildLocalVisible(child, visible) {
      if (visible === undefined) {
        visible = true;
      }

      var localState = GetLocalState(child);
      localState.visible = visible;
      this.updateChildVisible(child);
      return this;
    },
    // Internal method
    setChildMaskVisible: function setChildMaskVisible(child, visible) {
      if (visible === undefined) {
        visible = true;
      }

      var localState = GetLocalState(child);
      localState.maskVisible = visible;
      this.updateChildVisible(child);
      return this;
    },
    resetLocalVisibleState: function resetLocalVisibleState() {
      var parent = GetLocalState(this).parent;

      if (parent) {
        parent.resetChildVisibleState(this);
      }

      return this;
    }
  };

  var Alpha = {
    updateChildAlpha: function updateChildAlpha(child) {
      var state = GetLocalState(child);
      var parent = state.parent;

      if (state.syncAlpha) {
        child.alpha = parent.alpha * state.alpha;
      }

      return this;
    },
    syncAlpha: function syncAlpha() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildAlpha, this);
      }

      return this;
    },
    resetChildAlphaState: function resetChildAlphaState(child) {
      var state = GetLocalState(child);
      var parent = state.parent;
      state.alpha = GetScale(child.alpha, parent.alpha);
      return this;
    },
    setChildAlpha: function setChildAlpha(child, alpha) {
      child.alpha = alpha;
      this.resetChildAlphaState(child);
      return this;
    },
    setChildLocalAlpha: function setChildLocalAlpha(child, alpha) {
      var state = GetLocalState(child);
      state.alpha = alpha;
      this.updateChildAlpha(child);
      return this;
    },
    resetLocalAlphaState: function resetLocalAlphaState() {
      var parent = GetLocalState(this).parent;

      if (parent) {
        parent.resetChildAlphaState(this);
      }

      return this;
    }
  };

  var Active = {
    updateChildActive: function updateChildActive(child) {
      var localState = GetLocalState(child);
      var parent = localState.parent;
      child.active = parent.active && localState.active;
      return this;
    },
    syncActive: function syncActive() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildActive, this);
      }

      return this;
    },
    resetChildActiveState: function resetChildActiveState(child) {
      var localState = GetLocalState(child);
      localState.active = child.active;
      return this;
    },
    setChildActive: function setChildActive(child, active) {
      child.active = active;
      this.resetChildActiveState(child);
      return this;
    },
    setChildLocalActive: function setChildLocalActive(child, active) {
      if (active === undefined) {
        active = true;
      }

      var localState = GetLocalState(child);
      localState.active = active;
      this.updateChildActive(child);
      return this;
    },
    resetLocalActiveState: function resetLocalActiveState() {
      var parent = GetLocalState(this).parent;

      if (parent) {
        parent.resetChildActiveState(this);
      }

      return this;
    }
  };

  var ScrollFactor = {
    updateChildScrollFactor: function updateChildScrollFactor(child) {
      var localState = GetLocalState(child);
      var parent = localState.parent;
      child.setScrollFactor(parent.scrollFactorX, parent.scrollFactorY);
      return this;
    },
    syncScrollFactor: function syncScrollFactor() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildScrollFactor, this);
      }

      return this;
    }
  };

  var Mask = {
    updateChildMask: function updateChildMask(child) {
      // Don't propagate null mask to clear children's mask
      if (this.mask == null) {
        return this;
      }

      var maskGameObject = this.mask.hasOwnProperty('geometryMask') ? this.mask.geometryMask : this.mask.bitmapMask;

      if (maskGameObject !== child) {
        child.mask = this.mask;
      }

      return this;
    },
    syncMask: function syncMask() {
      if (this.syncChildrenEnable) {
        this.children.forEach(this.updateChildMask, this);
      }

      return this;
    },
    setMask: function setMask(mask) {
      this.mask = mask;
      return this;
    },
    clearMask: function clearMask(destroyMask) {
      if (destroyMask === undefined) {
        destroyMask = false;
      }

      if (destroyMask && this.mask) {
        this.mask.destroy();
      }

      this.mask = null;
      return this;
    }
  };

  var SortGameObjectsByDepth = function SortGameObjectsByDepth(gameObjects, descending) {
    if (gameObjects.length === 0) {
      return gameObjects;
    }

    if (descending === undefined) {
      descending = false;
    }

    var scene = gameObjects[0].scene;
    var displayList = scene.sys.displayList;
    displayList.depthSort();

    if (descending) {
      gameObjects.sort(function (childA, childB) {
        return displayList.getIndex(childB) - displayList.getIndex(childA);
      });
    } else {
      gameObjects.sort(function (childA, childB) {
        return displayList.getIndex(childA) - displayList.getIndex(childB);
      });
    }

    return gameObjects;
  };

  var Depth = {
    setDepth: function setDepth(value, containerOnly) {
      this.depth = value;

      if (!containerOnly && this.children) {
        var children = this.getAllChildren();

        for (var i = 0, cnt = children.length; i < cnt; i++) {
          children[i].depth = value;
        }
      }

      return this;
    },
    swapDepth: function swapDepth(containerB) {
      var depthA = this.depth;
      var depthB = containerB.depth;
      this.setDepth(depthB);
      containerB.setDepth(depthA);
      return this;
    },
    incDepth: function incDepth(inc) {
      this.depth += inc;

      if (this.children) {
        var children = this.getAllChildren();

        for (var i = 0, cnt = children.length; i < cnt; i++) {
          children[i].depth += inc;
        }
      }

      return this;
    },
    moveDepthBelow: function moveDepthBelow(gameObject) {
      var displayList = gameObject.scene.children;
      var children = this.getAllChildren([this]);
      SortGameObjectsByDepth(children);

      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];

        if (displayList.exists(child)) {
          displayList.moveBelow(gameObject, child);
          break;
        }
      }

      return this;
    },
    moveDepthAbove: function moveDepthAbove(gameObject) {
      var displayList = gameObject.scene.children;
      var children = this.getAllChildren([this]);
      SortGameObjectsByDepth(children, true);

      for (var i = 0, cnt = children.length; i < cnt; i++) {
        var child = children[i];

        if (displayList.exists(child)) {
          displayList.moveAbove(gameObject, child);
          break;
        }
      }

      return this;
    }
  };

  var DepthFirstSearch = function DepthFirstSearch(root, callback) {
    var skip = callback(root);

    if (!skip && root.isRexContainerLite) {
      var children = root.children;

      for (var i = 0, cnt = children.length; i < cnt; i++) {
        DepthFirstSearch(children[i], callback);
      }
    }
  };

  var BreadthFirstSearch = function BreadthFirstSearch(root, callback) {
    var queue = [root];

    while (queue.length > 0) {
      var current = queue.shift();
      var skip = callback(current);

      if (!skip && current.isRexContainerLite) {
        queue.push.apply(queue, _toConsumableArray(current.children));
      }
    }
  };

  var ArrayUtils = Phaser.Utils.Array;
  var Children = {
    getChildren: function getChildren(out) {
      if (!out) {
        out = this.children; // Return internal children array
      } else {
        for (var i = 0, cnt = this.children.length; i < cnt; i++) {
          out.push(this.children[i]);
        } // Copy children

      }

      return out;
    },
    getAllChildren: function getAllChildren(out) {
      if (out === undefined) {
        out = [];
      }

      var root = this;
      BreadthFirstSearch(root, function (child) {
        // Don't add root
        if (child === root) {
          return;
        }

        out.push(child);
      });
      return out;
    },
    getAllVisibleChildren: function getAllVisibleChildren(out) {
      if (out === undefined) {
        out = [];
      }

      var root = this;
      BreadthFirstSearch(root, function (child) {
        // Don't add root
        if (child === root) {
          return;
        } // Don't add invisible child


        if (!child.visible) {
          return true;
        }

        out.push(child);
      });
      return out;
    },
    bfs: function bfs(callback, root) {
      if (root === undefined) {
        root = this;
      }

      BreadthFirstSearch(root, callback);
      return this;
    },
    dfs: function dfs(callback, root) {
      if (root === undefined) {
        root = this;
      }

      DepthFirstSearch(root, callback);
      return this;
    },
    contains: function contains(gameObject) {
      // Override Base.contains method
      var parent = GetParent(gameObject);

      if (!parent) {
        return false;
      } else if (parent === this) {
        return true;
      } else {
        return this.contains(parent);
      }
    },
    getByName: function getByName(name, recursive) {
      if (!recursive) {
        return ArrayUtils.GetFirst(this.children, 'name', name); // object, or null if not found
      } else {
        // recursive
        // Breadth-first search
        var queue = [this];
        var parent, child;

        while (queue.length) {
          parent = queue.shift();

          for (var i = 0, cnt = parent.children.length; i < cnt; i++) {
            child = parent.children[i];

            if (child.name === name) {
              return child;
            } else if (child.isRexContainerLite) {
              queue.push(child);
            }
          }
        }

        return null;
      }
    },
    getRandom: function getRandom(startIndex, length) {
      return ArrayUtils.GetRandom(this.children, startIndex, length);
    },
    getFirst: function getFirst(property, value, startIndex, endIndex) {
      return ArrayUtils.GetFirstElement(this.children, property, value, startIndex, endIndex);
    },
    getAll: function getAll(property, value, startIndex, endIndex) {
      return ArrayUtils.GetAll(this.children, property, value, startIndex, endIndex);
    },
    count: function count(property, value, startIndex, endIndex) {
      return ArrayUtils.CountAllMatching(this.children, property, value, startIndex, endIndex);
    },
    swap: function swap(child1, child2) {
      ArrayUtils.Swap(this.children, child1, child2);
      return this;
    },
    setAll: function setAll(property, value, startIndex, endIndex) {
      ArrayUtils.SetAll(this.children, property, value, startIndex, endIndex);
      return this;
    }
  };

  var GetLocalStates = function GetLocalStates(gameObjects) {
    var localStates = [];

    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var gameObject = gameObjects[i];

      if (!gameObject.hasOwnProperty('rexContainer')) {
        continue;
      }

      localStates.push(gameObject.rexContainer);
    }

    return localStates;
  };

  var GetScene = function GetScene(gameObjects) {
    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var scene = gameObjects[i].scene;

      if (scene) {
        return scene;
      }
    }

    return null;
  };

  var UpdateChild = function UpdateChild(tween, key, target) {
    if (!target.parent) {
      // target object was removed, so remove this tween too
      tween.remove();
      return;
    }

    var parent = target.parent;
    var child = target.self;

    switch (key) {
      case 'x':
      case 'y':
        parent.updateChildPosition(child);
        break;

      case 'angle':
      case 'rotation':
        parent.updateChildRotation(child);
        break;

      case 'scaleX':
      case 'scaleY':
      case 'displayWidth':
      case 'displayHeight':
        parent.updateChildScale(child);
        break;

      case 'alpha':
        parent.updateChildAlpha(child);
        break;

      default:
        parent.updateChildPosition(child);
        parent.updateChildRotation(child);
        parent.updateChildScale(child);
        parent.updateChildAlpha(child);
        break;
    }
  };

  var Tween = {
    tweenChild: function tweenChild(tweenConfig) {
      var targets = tweenConfig.targets;

      if (!Array.isArray(targets)) {
        targets = [targets];
      }

      var scene = this.scene || GetScene(targets);

      if (!scene) {
        return;
      } // Map child game objects to local states


      tweenConfig.targets = GetLocalStates(targets);
      var tween = scene.tweens.add(tweenConfig); // Update child game object in 'update' event

      tween.on('update', UpdateChild);
      return tween;
    },
    createTweenChildConfig: function createTweenChildConfig(tweenConfig) {
      var targets = tweenConfig.targets;

      if (targets) {
        if (!Array.isArray(targets)) {
          targets = [targets];
        } // Map child game objects to local states


        tweenConfig.targets = GetLocalStates(targets);
      }

      var onUpdate = tweenConfig.onUpdate;

      tweenConfig.onUpdate = function (tween, target) {
        if (onUpdate) {
          onUpdate(tween, target);
        }

        UpdateChild(tween, undefined, target);
      };

      return tweenConfig;
    },
    tween: function tween(tweenConfig) {
      var scene = this.scene;

      if (!tweenConfig.targets) {
        tweenConfig.targets = this;
      }

      return scene.tweens.add(tweenConfig);
    },
    timelineChild: function timelineChild(timelineConfig) {
      var targets = timelineConfig.targets; // Map child game objects to local states

      if (targets) {
        if (!Array.isArray(targets)) {
          targets = [targets];
        }

        timelineConfig.targets = GetLocalStates(targets);
      }

      var tweens = timelineConfig.tweens;

      for (var i = 0, cnt = tweens.length; i < cnt; i++) {
        tweens[i] = this.createTweenChildConfig(tweens[i]);
      }

      var timeline = this.scene.tweens.timeline(timelineConfig);
      return timeline;
    }
  };

  var AddToLayer = function AddToLayer(layer) {
    var gameObjects = this.getAllChildren([this]);
    SortGameObjectsByDepth(gameObjects);
    layer.add(gameObjects);
    return this;
  };

  var AddToContainer = {
    addToLayer: AddToLayer,
    addToContainer: AddToLayer
  };

  var RotateAround$4 = Phaser.Math.RotateAround;

  var ChangeOrigin$1 = function ChangeOrigin(gameObject, originX, originY) {
    if (originY === undefined) {
      originY = originX;
    }

    var deltaXY = {
      x: (originX - gameObject.originX) * gameObject.displayWidth,
      y: (originY - gameObject.originY) * gameObject.displayHeight
    };
    RotateAround$4(deltaXY, 0, 0, gameObject.rotation);
    gameObject.originX = originX;
    gameObject.originY = originY;
    gameObject.x = gameObject.x + deltaXY.x;
    gameObject.y = gameObject.y + deltaXY.y;
    return gameObject;
  };

  var ChangeOrigin = function ChangeOrigin(originX, originY) {
    this.syncChildrenEnable = false;
    ChangeOrigin$1(this, originX, originY);
    this.syncChildrenEnable = true;
    var children = this.getAllChildren();

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      this.resetChildPositionState(children[i]);
    }

    return this;
  };

  var methods$i = {
    changeOrigin: ChangeOrigin
  };
  Object.assign(methods$i, Parent, AddChild$2, RemoveChild$2, ChildState, Transform, Position, Rotation, Scale$1, Visible$1, Alpha, Active, ScrollFactor, Mask, Depth, Children, Tween, AddToContainer);

  var ContainerLite = /*#__PURE__*/function (_Base) {
    _inherits(ContainerLite, _Base);

    var _super = _createSuper(ContainerLite);

    function ContainerLite(scene, x, y, width, height, children) {
      var _this;

      _classCallCheck(this, ContainerLite);

      _this = _super.call(this, scene, x, y, width, height);
      _this.type = 'rexContainerLite';
      _this.isRexContainerLite = true;
      _this.syncChildrenEnable = true;
      _this._active = true;
      _this._mask = null;
      _this._scrollFactorX = 1;
      _this._scrollFactorY = 1;

      if (children) {
        _this.add(children);
      }

      return _this;
    }

    _createClass(ContainerLite, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        this.syncChildrenEnable = false; // Don't sync properties changing anymore

        _get(_getPrototypeOf(ContainerLite.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        this.setSize(width, height);
        return this;
      }
    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        if (this._x === value) {
          return;
        }

        this._x = value;
        this.syncPosition();
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        if (this._y === value) {
          return;
        }

        this._y = value;
        this.syncPosition();
      } // Override

    }, {
      key: "rotation",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "rotation", this);
      },
      set: function set(value) {
        if (this.rotation === value) {
          return;
        }

        _set(_getPrototypeOf(ContainerLite.prototype), "rotation", value, this, true);

        this.syncPosition();
      } // Override

    }, {
      key: "scaleX",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "scaleX", this);
      },
      set: function set(value) {
        if (this.scaleX === value) {
          return;
        }

        _set(_getPrototypeOf(ContainerLite.prototype), "scaleX", value, this, true);

        this.syncPosition();
      } // Override

    }, {
      key: "scaleY",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "scaleY", this);
      },
      set: function set(value) {
        if (this.scaleY === value) {
          return;
        }

        _set(_getPrototypeOf(ContainerLite.prototype), "scaleY", value, this, true);

        this.syncPosition();
      } // Override

    }, {
      key: "scale",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "scale", this);
      },
      set: function set(value) {
        if (this.scale === value) {
          return;
        }

        _set(_getPrototypeOf(ContainerLite.prototype), "scale", value, this, true);

        this.syncPosition();
      } // Override

    }, {
      key: "visible",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "visible", this);
      },
      set: function set(value) {
        if (_get(_getPrototypeOf(ContainerLite.prototype), "visible", this) === value) {
          return;
        }

        _set(_getPrototypeOf(ContainerLite.prototype), "visible", value, this, true);

        this.syncVisible();
      } // Override

    }, {
      key: "alpha",
      get: function get() {
        return _get(_getPrototypeOf(ContainerLite.prototype), "alpha", this);
      },
      set: function set(value) {
        if (_get(_getPrototypeOf(ContainerLite.prototype), "alpha", this) === value) {
          return;
        }

        _set(_getPrototypeOf(ContainerLite.prototype), "alpha", value, this, true);

        this.syncAlpha();
      } // Override

    }, {
      key: "active",
      get: function get() {
        return this._active;
      },
      set: function set(value) {
        if (this._active === value) {
          return;
        }

        this._active = value;
        this.syncActive();
      } // Override

    }, {
      key: "mask",
      get: function get() {
        return this._mask;
      },
      set: function set(mask) {
        if (this._mask === mask) {
          return;
        }

        this._mask = mask;
        this.syncMask();
      } // Override

    }, {
      key: "scrollFactorX",
      get: function get() {
        return this._scrollFactorX;
      },
      set: function set(value) {
        if (this._scrollFactorX === value) {
          return;
        }

        this._scrollFactorX = value;
        this.syncScrollFactor();
      }
    }, {
      key: "scrollFactorY",
      get: function get() {
        return this._scrollFactorY;
      },
      set: function set(value) {
        if (this._scrollFactorY === value) {
          return;
        }

        this._scrollFactorY = value;
        this.syncScrollFactor();
      } // Compatiable with container plugin

    }, {
      key: "list",
      get: function get() {
        return this.children;
      }
    }], [{
      key: "GetParent",
      value: function GetParent$1(child) {
        return GetParent(child);
      }
    }]);

    return ContainerLite;
  }(Base$2);

  Object.assign(ContainerLite.prototype, methods$i);

  ObjectFactory.register('container', function (x, y, width, height, children) {
    var gameObject = new ContainerLite(this.scene, x, y, width, height, children);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Container', ContainerLite);

  ObjectFactory.register('canvas', function (x, y, width, height) {
    var gameObject = new Canvas(this.scene, x, y, width, height);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Canvas', Canvas);

  var GetValue$2p = Phaser.Utils.Objects.GetValue;

  var CircleMaskImage = /*#__PURE__*/function (_Canvas) {
    _inherits(CircleMaskImage, _Canvas);

    var _super = _createSuper(CircleMaskImage);

    function CircleMaskImage(scene, x, y, key, frame, config) {
      var _this;

      _classCallCheck(this, CircleMaskImage);

      _this = _super.call(this, scene, x, y);
      _this.type = 'rexCircleMaskImage';

      _this.setTexture(key, frame, config);

      return _this;
    }

    _createClass(CircleMaskImage, [{
      key: "setTexture",
      value: function setTexture(key, frame, config) {
        if (_typeof(frame) === 'object') {
          config = frame;
          frame = undefined;
        }

        var maskType, backgroundColor;

        if (typeof config === 'string') {
          maskType = config;
          backgroundColor = undefined;
        } else {
          maskType = GetValue$2p(config, 'maskType', 0);
          backgroundColor = GetValue$2p(config, 'backgroundColor', undefined);
        }

        if (maskType === undefined) {
          maskType = 0;
        } else if (typeof maskType === 'string') {
          maskType = MASKTYPE[maskType];
        }

        this._textureKey = key;
        this._frameName = frame;

        if (maskType === null) {
          this.loadTexture(key, frame);
          this.dirty = true;
          return this;
        }

        var hasBackgroundColor = backgroundColor != null;

        if (!hasBackgroundColor) {
          // No background color -- draw image first
          this.loadTexture(key, frame);
        } // Draw mask


        var canvas = this.canvas,
            ctx = this.context;
        var width = canvas.width,
            height = canvas.height;
        ctx.save();
        ctx.globalCompositeOperation = hasBackgroundColor ? 'source-over' : 'destination-in';
        ctx.beginPath(); // Draw circle, ellipse, or roundRectangle

        switch (maskType) {
          case 2:
            var radiusConfig = GetValue$2p(config, 'radius', 0);
            var iteration = GetValue$2p(config, 'iteration', undefined);
            AddRoundRectanglePath(ctx, 0, 0, width, height, radiusConfig, iteration);
            break;

          default:
            // circle, ellipse
            var centerX = Math.floor(width / 2);
            var centerY = Math.floor(height / 2);

            if (maskType === 0) {
              ctx.arc(centerX, centerY, Math.min(centerX, centerY), 0, 2 * Math.PI);
            } else {
              ctx.ellipse(centerX, centerY, centerX, centerY, 0, 0, 2 * Math.PI);
            }

            break;
        }

        if (hasBackgroundColor) {
          ctx.fillStyle = backgroundColor;
        }

        ctx.fill();
        ctx.restore();

        if (hasBackgroundColor) {
          // Has background color -- draw image last
          ctx.save();
          ctx.globalCompositeOperation = 'destination-atop';
          this.loadTexture(key, frame);
          ctx.restore();
        }

        this.dirty = true;
        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        // Don't draw content again.
        this.setDisplaySize(width, height);
        return this;
      }
    }]);

    return CircleMaskImage;
  }(Canvas);

  var MASKTYPE = {
    circle: 0,
    ellipse: 1,
    roundRectangle: 2
  };

  ObjectFactory.register('circleMaskImage', function (x, y, key, frame, config) {
    var gameObject = new CircleMaskImage(this.scene, x, y, key, frame, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.CircleMaskImage', CircleMaskImage);

  var Base$1 = /*#__PURE__*/function () {
    function Base(parent, type) {
      _classCallCheck(this, Base);

      this.setParent(parent);
      this.type = type;
      this.reset().setActive();
    }

    _createClass(Base, [{
      key: "destroy",
      value: function destroy() {
        this.parent.removeChild(this);
      }
    }, {
      key: "setParent",
      value: function setParent(parent) {
        this.parent = parent;
        return this;
      }
    }, {
      key: "scene",
      get: function get() {
        return this.parent.scene;
      }
    }, {
      key: "canvas",
      get: function get() {
        return this.parent ? this.parent.canvas : null;
      }
    }, {
      key: "context",
      get: function get() {
        return this.parent ? this.parent.context : null;
      }
    }, {
      key: "setDirty",
      value: function setDirty(dirty) {
        if (dirty && this.parent) {
          this.parent.dirty = true;
        }

        return this;
      }
    }, {
      key: "active",
      get: function get() {
        return this._active;
      },
      set: function set(value) {
        this.setDirty(this._active != value);
        this._active = value;
      }
    }, {
      key: "setActive",
      value: function setActive(active) {
        if (active === undefined) {
          active = true;
        }

        this.active = active;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        return this;
      } // Override

    }, {
      key: "onFree",
      value: function onFree() {
        this.reset().setParent();
      } // Override

    }, {
      key: "reset",
      value: function reset() {
        return this;
      }
    }]);

    return Base;
  }();

  Object.assign(Base$1.prototype, DataMethods);

  var DegToRad$6 = Phaser.Math.DegToRad;
  var RadToDeg$4 = Phaser.Math.RadToDeg;
  var GetValue$2o = Phaser.Utils.Objects.GetValue;

  var RenderBase = /*#__PURE__*/function (_Base) {
    _inherits(RenderBase, _Base);

    var _super = _createSuper(RenderBase);

    function RenderBase(parent, type) {
      var _this;

      _classCallCheck(this, RenderBase);

      _this = _super.call(this, parent, type);
      _this.originX = 0;
      _this.offsetX = 0; // Override

      _this.offsetY = 0; // Override

      return _this;
    }

    _createClass(RenderBase, [{
      key: "visible",
      get: function get() {
        return this._visible;
      },
      set: function set(value) {
        this.setDirty(this._visible != value);
        this._visible = value;
      }
    }, {
      key: "setVisible",
      value: function setVisible(visible) {
        if (visible === undefined) {
          visible = true;
        }

        this.visible = visible;
        return this;
      }
    }, {
      key: "alpha",
      get: function get() {
        return this._alpha;
      },
      set: function set(value) {
        this.setDirty(this._alpha != value);
        this._alpha = value;
      }
    }, {
      key: "setAlpha",
      value: function setAlpha(alpha) {
        this.alpha = alpha;
        return this;
      }
    }, {
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this.setDirty(this._x != value);
        this._x = value;
      }
    }, {
      key: "setX",
      value: function setX(x) {
        this.x = x;
        return this;
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this.setDirty(this._y != value);
        this._y = value;
      }
    }, {
      key: "setY",
      value: function setY(y) {
        this.y = y;
        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "rotation",
      get: function get() {
        return this._rotation;
      },
      set: function set(value) {
        this.setDirty(this._rotation != value);
        this._rotation = value;
      }
    }, {
      key: "setRotation",
      value: function setRotation(rotation) {
        this.rotation = rotation;
        return this;
      }
    }, {
      key: "angle",
      get: function get() {
        return RadToDeg$4(this._rotation);
      },
      set: function set(value) {
        this.rotation = DegToRad$6(value);
      }
    }, {
      key: "setAngle",
      value: function setAngle(angle) {
        this.angle = angle;
        return this;
      }
    }, {
      key: "scaleX",
      get: function get() {
        return this._scaleX;
      },
      set: function set(value) {
        this.setDirty(this._scaleX !== value);
        this._scaleX = value;
      }
    }, {
      key: "setScaleX",
      value: function setScaleX(scaleX) {
        this.scaleX = scaleX;
        return this;
      } // Override

    }, {
      key: "width",
      get: function get() {
        return 0;
      } // Override
      ,
      set: function set(value) {}
    }, {
      key: "setWidth",
      value: function setWidth(width, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }

        this.width = width;

        if (keepAspectRatio) {
          this.scaleY = this.scaleX;
        }

        return this;
      }
    }, {
      key: "leftSpace",
      get: function get() {
        return this._leftSpace;
      },
      set: function set(value) {
        this.setDirty(this._leftSpace !== value);
        this._leftSpace = value;
      }
    }, {
      key: "setLeftSpace",
      value: function setLeftSpace(value) {
        this.leftSpace = value;
        return this;
      }
    }, {
      key: "rightSpace",
      get: function get() {
        return this._rightSpace;
      },
      set: function set(value) {
        this.setDirty(this._rightSpace !== value);
        this._rightSpace = value;
      }
    }, {
      key: "setRightSpace",
      value: function setRightSpace(value) {
        this.rightSpace = value;
        return this;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.width + this.leftSpace + this.rightSpace;
      }
    }, {
      key: "scaleY",
      get: function get() {
        return this._scaleY;
      },
      set: function set(value) {
        this.setDirty(this._scaleY !== value);
        this._scaleY = value;
      }
    }, {
      key: "setScaleY",
      value: function setScaleY(scaleY) {
        this.scaleY = scaleY;
        return this;
      } // Override

    }, {
      key: "height",
      get: function get() {
        return 0;
      } // Override
      ,
      set: function set(value) {}
    }, {
      key: "setHeight",
      value: function setHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }

        this.height = height;

        if (keepAspectRatio) {
          this.scaleX = this.scaleY;
        }

        return this;
      }
    }, {
      key: "setScale",
      value: function setScale(scaleX, scaleY) {
        if (scaleY === undefined) {
          scaleY = scaleX;
        }

        this.scaleX = scaleX;
        this.scaleY = scaleY;
        return this;
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(x) {
        this.originX = x;
        return this;
      }
    }, {
      key: "setAlign",
      value: function setAlign(align) {
        this.align = align;
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        if (!o) {
          return this;
        }

        if (o.hasOwnProperty('x')) {
          this.setX(o.x);
        }

        if (o.hasOwnProperty('y')) {
          this.setY(o.y);
        }

        if (o.hasOwnProperty('rotation')) {
          this.setRotation(o.rotation);
        } else if (o.hasOwnProperty('angle')) {
          this.setAngle(o.angle);
        }

        if (o.hasOwnProperty('alpha')) {
          this.setAlpha(o.alpha);
        } // ScaleX, ScaleY


        var width = GetValue$2o(o, 'width', undefined);
        var height = GetValue$2o(o, 'height', undefined);
        var scaleX = GetValue$2o(o, 'scaleX', undefined);
        var scaleY = GetValue$2o(o, 'scaleY', undefined);

        if (width !== undefined) {
          if (height === undefined && scaleY === undefined) {
            this.setWidth(width, true);
          } else {
            this.setWidth(width);
          }
        } else if (scaleX !== undefined) {
          this.setScaleX(scaleX);
        }

        if (height !== undefined) {
          if (width === undefined && scaleX === undefined) {
            this.setHeight(height, true);
          } else {
            this.setHeight(height);
          }
        } else if (scaleY !== undefined) {
          this.setScaleY(scaleY);
        }

        if (o.hasOwnProperty('leftSpace')) {
          this.setLeftSpace(o.leftSpace);
        }

        if (o.hasOwnProperty('rightSpace')) {
          this.setRightSpace(o.rightSpace);
        }

        if (o.hasOwnProperty('align')) {
          this.setAlign(o.align);
        }

        return this;
      }
    }, {
      key: "setDrawBelowCallback",
      value: function setDrawBelowCallback(callback) {
        this.drawBelowCallback = callback;
        return this;
      }
    }, {
      key: "setDrawAboveCallback",
      value: function setDrawAboveCallback(callback) {
        this.drawAboveCallback = callback;
        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.setVisible().setAlpha(1).setPosition(0, 0).setRotation(0).setScale(1, 1).setLeftSpace(0).setRightSpace(0).setOrigin(0).setAlign().setDrawBelowCallback().setDrawAboveCallback();
        return this;
      } // Override

    }, {
      key: "drawContent",
      value: function drawContent() {} // Override

    }, {
      key: "draw",
      value: function draw() {
        var context = this.context;
        context.save();
        var x = this.x + this.leftSpace + this.offsetX - this.originX * this.width,
            y = this.y + this.offsetY;

        if (this.autoRound) {
          x = Math.round(x);
          y = Math.round(y);
        }

        context.translate(x, y);
        context.globalAlpha = this.alpha;
        context.scale(this.scaleX, this.scaleY);
        context.rotate(this.rotation);

        if (this.drawBelowCallback) {
          this.drawBelowCallback(this);
        }

        this.drawContent();

        if (this.drawAboveCallback) {
          this.drawAboveCallback(this);
        }

        context.restore();
      }
    }]);

    return RenderBase;
  }(Base$1);

  var GetValue$2n = Phaser.Utils.Objects.GetValue;

  var Background = /*#__PURE__*/function (_Base) {
    _inherits(Background, _Base);

    var _super = _createSuper(Background);

    function Background(parent, config) {
      var _this;

      _classCallCheck(this, Background);

      _this = _super.call(this, parent, 'background');

      _this.setColor(GetValue$2n(config, 'color', null), GetValue$2n(config, 'color2', null), GetValue$2n(config, 'horizontalGradient', true));

      _this.setStroke(GetValue$2n(config, 'stroke', null), GetValue$2n(config, 'strokeThickness', 2));

      _this.setCornerRadius(GetValue$2n(config, 'cornerRadius', 0), GetValue$2n(config, 'cornerIteration', null));

      return _this;
    }

    _createClass(Background, [{
      key: "color",
      get: function get() {
        return this._color;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color != value);
        this._color = value;
      }
    }, {
      key: "color2",
      get: function get() {
        return this._color2;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color2 != value);
        this._color2 = value;
      }
    }, {
      key: "horizontalGradient",
      get: function get() {
        return this._horizontalGradient;
      },
      set: function set(value) {
        this.setDirty(this._horizontalGradient != value);
        this._horizontalGradient = value;
      }
    }, {
      key: "setColor",
      value: function setColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
          isHorizontalGradient = true;
        }

        this.color = color;
        this.color2 = color2;
        this.horizontalGradient = isHorizontalGradient;
        return this;
      }
    }, {
      key: "stroke",
      get: function get() {
        return this._stroke;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._stroke != value);
        this._stroke = value;
      }
    }, {
      key: "strokeThickness",
      get: function get() {
        return this._strokeThickness;
      },
      set: function set(value) {
        this.setDirty(this._strokeThickness != value);
        this._strokeThickness = value;
      }
    }, {
      key: "setStroke",
      value: function setStroke(color, lineWidth) {
        this.stroke = color;
        this.strokeThickness = lineWidth;
        return this;
      }
    }, {
      key: "cornerRadius",
      get: function get() {
        return this._cornerRadius;
      },
      set: function set(value) {
        this.setDirty(this._cornerRadius != value);
        this._cornerRadius = value;
      }
    }, {
      key: "cornerIteration",
      get: function get() {
        return this._cornerIteration;
      },
      set: function set(value) {
        this.setDirty(this._cornerIteration != value);
        this._cornerIteration = value;
      }
    }, {
      key: "setCornerRadius",
      value: function setCornerRadius(radius, iteration) {
        this.cornerRadius = radius;
        this.cornerIteration = iteration;
        return this;
      }
    }, {
      key: "drawContent",
      value: function drawContent() {
        DrawRoundRectangleBackground(this.parent, this.color, this.stroke, this.strokeThickness, this.cornerRadius, this.color2, this.horizontalGradient, this.cornerIteration);
      }
    }]);

    return Background;
  }(RenderBase);

  var GetValue$2m = Phaser.Utils.Objects.GetValue;

  var InnerBounds = /*#__PURE__*/function (_Base) {
    _inherits(InnerBounds, _Base);

    var _super = _createSuper(InnerBounds);

    function InnerBounds(parent, config) {
      var _this;

      _classCallCheck(this, InnerBounds);

      _this = _super.call(this, parent, 'background');

      _this.setColor(GetValue$2m(config, 'color', null), GetValue$2m(config, 'color2', null), GetValue$2m(config, 'horizontalGradient', true));

      _this.setStroke(GetValue$2m(config, 'stroke', null), GetValue$2m(config, 'strokeThickness', 2));

      return _this;
    }

    _createClass(InnerBounds, [{
      key: "color",
      get: function get() {
        return this._color;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color != value);
        this._color = value;
      }
    }, {
      key: "color2",
      get: function get() {
        return this._color2;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._color2 != value);
        this._color2 = value;
      }
    }, {
      key: "horizontalGradient",
      get: function get() {
        return this._horizontalGradient;
      },
      set: function set(value) {
        this.setDirty(this._horizontalGradient != value);
        this._horizontalGradient = value;
      }
    }, {
      key: "setColor",
      value: function setColor(color, color2, isHorizontalGradient) {
        if (isHorizontalGradient === undefined) {
          isHorizontalGradient = true;
        }

        this.color = color;
        this.color2 = color2;
        this.horizontalGradient = isHorizontalGradient;
        return this;
      }
    }, {
      key: "stroke",
      get: function get() {
        return this._stroke;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.setDirty(this._stroke != value);
        this._stroke = value;
      }
    }, {
      key: "strokeThickness",
      get: function get() {
        return this._strokeThickness;
      },
      set: function set(value) {
        this.setDirty(this._strokeThickness != value);
        this._strokeThickness = value;
      }
    }, {
      key: "setStroke",
      value: function setStroke(color, lineWidth) {
        this.stroke = color;
        this.strokeThickness = lineWidth;
        return this;
      }
    }, {
      key: "drawContent",
      value: function drawContent() {
        var padding = this.parent.padding;
        var x = padding.left,
            y = padding.top,
            width = this.parent.width - padding.left - padding.right,
            height = this.parent.height - padding.top - padding.bottom;
        var context = this.context;

        if (this.color != null) {
          var fillStyle;

          if (this.color2 != null) {
            var grd;

            if (this.horizontalGradient) {
              grd = context.createLinearGradient(0, 0, width, 0);
            } else {
              grd = context.createLinearGradient(0, 0, 0, height);
            }

            grd.addColorStop(0, this.color);
            grd.addColorStop(1, this.color2);
            fillStyle = grd;
          } else {
            fillStyle = this.color;
          }

          context.fillStyle = fillStyle;
          context.fillRect(x, y, width, height);
        }

        if (this.stroke != null && this.strokeThickness > 0) {
          context.strokeStyle = this.stroke;
          context.lineWidth = this.strokeThickness;
          context.strokeRect(x, y, width, height);
        }
      }
    }]);

    return InnerBounds;
  }(RenderBase);

  var GetProperty = function GetProperty(name, config, defaultConfig) {
    if (config.hasOwnProperty(name)) {
      return config[name];
    } else {
      return defaultConfig[name];
    }
  };

  var GetValue$2l = Phaser.Utils.Objects.GetValue;

  var TextStyle = /*#__PURE__*/function () {
    function TextStyle(config) {
      _classCallCheck(this, TextStyle);

      this.set(config);
    }

    _createClass(TextStyle, [{
      key: "toJSON",
      value: function toJSON() {
        return {
          bold: this.bold,
          italic: this.italic,
          fontSize: this.fontSize,
          fontFamily: this.fontFamily,
          color: this.color,
          stroke: this.stroke,
          strokeThickness: this.strokeThickness,
          shaodwColor: this.shadowColor,
          shadowBlur: this.shadowBlur,
          shadowOffsetX: this.shadowOffsetX,
          shadowOffsetY: this.shadowOffsetY,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          align: this.align
        };
      }
    }, {
      key: "set",
      value: function set(o) {
        this.setBold(GetValue$2l(o, 'bold', false));
        this.setItalic(GetValue$2l(o, 'italic', false));
        this.setFontSize(GetValue$2l(o, 'fontSize', '16px'));
        this.setFontFamily(GetValue$2l(o, 'fontFamily', 'Courier'));
        this.setColor(GetValue$2l(o, 'color', '#fff'));
        this.setStrokeStyle(GetValue$2l(o, 'stroke', null), GetValue$2l(o, 'strokeThickness', 0));
        this.setShadow(GetValue$2l(o, 'shadowColor', null), GetValue$2l(o, 'shadowOffsetX', 0), GetValue$2l(o, 'shadowOffsetY', 0), GetValue$2l(o, 'shadowBlur', 0));
        this.setOffset(GetValue$2l(o, 'offsetX', 0), GetValue$2l(o, 'offsetY', 0));
        this.setAlign(GetValue$2l(o, 'align', undefined));
        return this;
      }
    }, {
      key: "modify",
      value: function modify(o) {
        if (o.hasOwnProperty('bold')) {
          this.setBold(o.bold);
        }

        if (o.hasOwnProperty('italic')) {
          this.setItalic(o.italic);
        }

        if (o.hasOwnProperty('fontSize')) {
          this.setFontSize(o.fontSize);
        }

        if (o.hasOwnProperty('fontFamily')) {
          this.setFontFamily(o.fontFamily);
        }

        if (o.hasOwnProperty('color')) {
          this.setColor(o.color);
        }

        if (o.hasOwnProperty('stroke') || o.hasOwnProperty('strokeThickness')) {
          this.setStrokeStyle(GetProperty('stroke', o, this), GetProperty('strokeThickness', o, this));
        }

        if (o.hasOwnProperty('shadowColor')) {
          this.setShadowColor(o.shadowColor);
        }

        if (o.hasOwnProperty('shadowOffsetX') || o.hasOwnProperty('shadowOffsetY')) {
          this.setShadowOffset(GetProperty('shadowOffsetX', o, this), GetProperty('shadowOffsetY', o, this));
        }

        if (o.hasOwnProperty('shadowBlur')) {
          this.setShadowBlur(o.shaodwBlur);
        }

        if (o.hasOwnProperty('offsetX')) {
          this.setOffsetX(o.offsetX);
        }

        if (o.hasOwnProperty('offsetY')) {
          this.setOffsetY(o.offsetY);
        }

        if (o.hasOwnProperty('align')) {
          this.setAlign(o.align);
        }

        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new TextStyle(this.toJSON());
      }
    }, {
      key: "copyFrom",
      value: function copyFrom(sourceTextStyle) {
        this.set(sourceTextStyle.toJSON());
        return this;
      }
    }, {
      key: "copyTo",
      value: function copyTo(targetTextStyle) {
        targetTextStyle.set(this.toJSON());
        return this;
      }
    }, {
      key: "setBold",
      value: function setBold(value) {
        if (value === undefined) {
          value = true;
        }

        this.bold = value;
        return this;
      }
    }, {
      key: "setItalic",
      value: function setItalic(value) {
        if (value === undefined) {
          value = true;
        }

        this.italic = value;
        return this;
      }
    }, {
      key: "fontStyle",
      get: function get() {
        if (this.bold && this.italic) {
          return 'bold italic';
        } else if (this.bold) {
          return 'bold';
        } else if (this.italic) {
          return 'italic';
        } else {
          return '';
        }
      }
    }, {
      key: "setFontSize",
      value: function setFontSize(fontSize) {
        if (typeof fontSize === 'number') {
          fontSize = "".concat(fontSize, "px");
        }

        this.fontSize = fontSize;
        return this;
      }
    }, {
      key: "setFontFamily",
      value: function setFontFamily(fontFamily) {
        this.fontFamily = fontFamily;
        return this;
      }
    }, {
      key: "font",
      get: function get() {
        return "".concat(this.fontStyle, " ").concat(this.fontSize, " ").concat(this.fontFamily);
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        this.color = GetStyle(color);
        return this;
      }
    }, {
      key: "hasFill",
      get: function get() {
        return this.color != null;
      }
    }, {
      key: "setStrokeStyle",
      value: function setStrokeStyle(stroke, strokeThickness) {
        this.stroke = GetStyle(stroke);

        if (strokeThickness !== undefined) {
          this.strokeThickness = strokeThickness;
        }

        return this;
      }
    }, {
      key: "setStrokeThickness",
      value: function setStrokeThickness(strokeThickness) {
        this.strokeThickness = strokeThickness;
        return this;
      }
    }, {
      key: "hasStroke",
      get: function get() {
        return this.stroke != null && this.strokeThickness > 0;
      }
    }, {
      key: "setShadowColor",
      value: function setShadowColor(color) {
        this.shadowColor = GetStyle(color);
        return this;
      }
    }, {
      key: "setShadowOffset",
      value: function setShadowOffset(offsetX, offsetY) {
        if (offsetX === undefined) {
          offsetX = 0;
        }

        if (offsetY === undefined) {
          offsetY = 0;
        }

        this.shadowOffsetX = offsetX;
        this.shadowOffsetY = offsetY;
        return this;
      }
    }, {
      key: "setShadowBlur",
      value: function setShadowBlur(blur) {
        if (blur === undefined) {
          blur = 0;
        }

        this.shaodwBlur = blur;
        return this;
      }
    }, {
      key: "setShadow",
      value: function setShadow(color, offsetX, offsetY, blur) {
        this.setShadowColor(color).setShadowOffset(offsetX, offsetY).setShadowBlur(blur);
        return this;
      }
    }, {
      key: "setOffsetX",
      value: function setOffsetX(offsetX) {
        if (offsetX === undefined) {
          offsetX = 0;
        }

        this.offsetX = offsetX;
        return this;
      }
    }, {
      key: "setOffsetY",
      value: function setOffsetY(offsetY) {
        if (offsetY === undefined) {
          offsetY = 0;
        }

        this.offsetY = offsetY;
        return this;
      }
    }, {
      key: "setOffset",
      value: function setOffset(offsetX, offsetY) {
        this.setOffsetX(offsetX).setOffsetY(offsetY);
        return this;
      }
    }, {
      key: "setAlign",
      value: function setAlign(align) {
        this.align = align;
        return this;
      }
    }, {
      key: "syncFont",
      value: function syncFont(context) {
        context.font = this.font;
        return this;
      }
    }, {
      key: "syncStyle",
      value: function syncStyle(context) {
        context.textBaseline = 'alphabetic';
        var hasFill = this.hasFill;
        var hasStroke = this.hasStroke;
        context.fillStyle = hasFill ? this.color : '#000';
        context.strokeStyle = hasStroke ? this.stroke : '#000';
        context.lineWidth = hasStroke ? this.strokeThickness : 0;
        context.lineCap = 'round';
        context.lineJoin = 'round';
        return this;
      }
    }, {
      key: "syncShadow",
      value: function syncShadow(context) {
        if (context.shadowColor != null) {
          context.shadowColor = this.shadowColor;
          context.shadowOffsetX = this.shadowOffsetX;
          context.shadowOffsetY = this.shadowOffsetY;
          context.shadowBlur = this.shadowBlur;
        } else {
          context.shadowColor = 0;
          context.shadowOffsetX = 0;
          context.shadowOffsetY = 0;
          context.shadowBlur = 0;
        }
      }
    }, {
      key: "getTextMetrics",
      value: function getTextMetrics(context, text) {
        this.syncFont(context).syncStyle(context);
        return context.measureText(text);
      }
    }]);

    return TextStyle;
  }();

  var SetFixedSize = function SetFixedSize(width, height) {
    if (width === undefined) {
      width = 0;
    }

    if (height === undefined) {
      height = 0;
    }

    if (width > 0 && height > 0) {
      if (this.fixedWidth !== width || this.fixedHeight !== height) {
        this.dirty = true;
      }
    } else {
      this.dirty = true;
    }

    this.fixedWidth = width;
    this.fixedHeight = height;
    return this;
  };

  var GetValue$2k = Phaser.Utils.Objects.GetValue;

  var GetPadding$1 = function GetPadding(padding, key) {
    if (key === undefined) {
      return padding;
    }

    return padding[key];
  };

  var SetPadding$1 = function SetPadding(padding, key, value) {
    var keyType = _typeof(key);

    if (keyType === 'string') {
      padding[key] = value;
    } else if (keyType === 'number') {
      padding.left = key;
      padding.right = key;
      padding.top = key;
      padding.bottom = key;
    } else {
      padding.left = GetValue$2k(key, 'left', 0);
      padding.right = GetValue$2k(key, 'right', 0);
      padding.top = GetValue$2k(key, 'top', 0);
      padding.bottom = GetValue$2k(key, 'bottom', 0);
    }
  };

  var SetPadding = function SetPadding(key, value) {
    var padding = this.padding;
    var paddingLeft = padding.left,
        paddingRight = padding.right,
        paddingTop = padding.top,
        paddingBottom = padding.bottom;
    SetPadding$1(padding, key, value);
    this.dirty = this.dirty || paddingLeft != padding.left || paddingRight != padding.right || paddingTop != padding.top || paddingBottom != padding.bottom;
    return this;
  };

  var GetPadding = function GetPadding(key) {
    return GetPadding$1(this.padding, key);
  };

  var ModifyTextStyle = function ModifyTextStyle(style) {
    this.textStyle.modify(style);
    return this;
  };

  var ResetTextStyle = function ResetTextStyle() {
    this.textStyle.copyFrom(this.defaultTextStyle);
    return this;
  };

  var RemoveChild$1 = function RemoveChild(bob) {
    this.poolManager.free(bob);
    RemoveItem(this.children.list, bob);
    this.lastAppendedChildren.length = 0;
    this.dirty = true;
    return this;
  };

  var RemoveChildren = function RemoveChildren() {
    this.poolManager.freeMultiple(this.children);
    this.children.length = 0;
    this.lastAppendedChildren.length = 0;
    this.dirty = true;
    return this;
  };

  var ClearContent = function ClearContent() {
    this.setText();
    return this;
  };

  var AddChild$1 = function AddChild(bob) {
    this.lastAppendedChildren.length = 0;

    if (Array.isArray(bob)) {
      var _this$children, _this$lastAppendedChi;

      (_this$children = this.children).push.apply(_this$children, _toConsumableArray(bob));

      (_this$lastAppendedChi = this.lastAppendedChildren).push.apply(_this$lastAppendedChi, _toConsumableArray(bob));
    } else {
      this.children.push(bob);
      this.lastAppendedChildren.push(bob);
    }

    return this;
  };

  var CharTypeName = 'text';
  var ImageTypeName = 'image';
  var CmdTypeName = 'command';

  var CanRender = function CanRender(bob) {
    var bobType = bob.type;
    return bobType === CharTypeName || bobType === ImageTypeName;
  };

  var IsNewLineChar = function IsNewLineChar(bob) {
    return bob.type === CharTypeName && bob.text === '\n';
  };

  var IsCommand = function IsCommand(bob) {
    return bob.type === CmdTypeName;
  };

  var CharData = /*#__PURE__*/function (_RenderBase) {
    _inherits(CharData, _RenderBase);

    var _super = _createSuper(CharData);

    function CharData(parent, text, style) {
      var _this;

      _classCallCheck(this, CharData);

      _this = _super.call(this, parent, CharTypeName);
      _this.style = new TextStyle(style);

      _this.setText(text);

      return _this;
    }

    _createClass(CharData, [{
      key: "autoRound",
      get: function get() {
        return this.parent.autoRound;
      }
    }, {
      key: "offsetX",
      get: function get() {
        return this.style.offsetX;
      },
      set: function set(value) {
        if (this.style) {
          this.style.offsetX = value;
        }
      }
    }, {
      key: "offsetY",
      get: function get() {
        return this.style.offsetY;
      },
      set: function set(value) {
        if (this.style) {
          this.style.offsetY = value;
        }
      }
    }, {
      key: "align",
      get: function get() {
        return this.style.align;
      },
      set: function set(value) {
        if (this.style) {
          this.style.align = value;
        }
      }
    }, {
      key: "modifyStyle",
      value: function modifyStyle(style) {
        this.setDirty(true);
        this.style.modify(style);
        return this;
      }
    }, {
      key: "modifyPorperties",
      value: function modifyPorperties(o) {
        if (!o) {
          return this;
        }

        this.modifyStyle(o);

        _get(_getPrototypeOf(CharData.prototype), "modifyPorperties", this).call(this, o);

        return this;
      }
    }, {
      key: "setText",
      value: function setText(text) {
        this.setDirty(this.text != text);
        this.text = text;
        this.updateTextSize();
        return this;
      }
    }, {
      key: "updateTextSize",
      value: function updateTextSize() {
        if (this.text === '\n' || this.text === '') {
          this.textWidth = 0;
          this.textHeight = 0;
        } else {
          var metrics = this.style.getTextMetrics(this.context, this.text);
          this.textWidth = metrics.width;
          var ascent, descent;

          if (metrics.hasOwnProperty('actualBoundingBoxAscent')) {
            ascent = metrics.actualBoundingBoxAscent;
            descent = metrics.actualBoundingBoxDescent;
          } else {
            ascent = 0;
            descent = 0;
          }

          this.textHeight = ascent + descent;
        }

        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this.textWidth * this.scaleX;
      },
      set: function set(value) {
        if (this.textWidth > 0) {
          this.scaleX = value / this.textWidth;
        } else {
          this.scaleX = 1;
        }
      }
    }, {
      key: "height",
      get: function get() {
        return this.textHeight * this.scaleY;
      },
      set: function set(value) {
        if (this.textHeight > 0) {
          this.scaleY = value / this.textHeight;
        } else {
          this.scaleY = 1;
        }
      }
    }, {
      key: "drawContent",
      value: function drawContent() {
        var textStyle = this.style;
        var hasFill = textStyle.hasFill,
            hasStroke = textStyle.hasStroke;

        if (!hasFill && !hasStroke) {
          return;
        }

        var context = this.context;
        textStyle.syncFont(context).syncStyle(context);

        if (hasStroke) {
          textStyle.syncShadow(context);
          context.strokeText(this.text, 0, 0);
        }

        if (hasFill) {
          textStyle.syncShadow(context);
          context.fillText(this.text, 0, 0);
        }
      }
    }, {
      key: "draw",
      value: function draw() {
        if (!this.visible || this.text === '' || this.text === '\n') {
          return this;
        }

        _get(_getPrototypeOf(CharData.prototype), "draw", this).call(this);
      }
    }]);

    return CharData;
  }(RenderBase);

  var AppendText$1 = function AppendText(text, style) {
    if (style) {
      this.textStyle.modify(style);
    }

    var bobArray = [];

    for (var i = 0, cnt = text.length; i < cnt; i++) {
      var _char = text.charAt(i);

      var bob = this.poolManager.allocate(CharTypeName);

      if (bob === null) {
        bob = new CharData(this, // parent
        _char, // text
        this.textStyle);
      } else {
        bob.setParent(this).setActive().modifyStyle(this.textStyle).setText(_char);
      } // bob.modifyPorperties(properties);  // Warning: Will modify text-style twice


      bobArray.push(bob);
    }

    this.addChild(bobArray);
    return this;
  };

  var SetText$2 = function SetText(text, style) {
    if (text === undefined) {
      text = '';
    }

    this.removeChildren();
    AppendText$1.call(this, text, style); // this.appendText might be override

    this.dirty = true;
    return this;
  };

  var ImageData = /*#__PURE__*/function (_RenderBase) {
    _inherits(ImageData, _RenderBase);

    var _super = _createSuper(ImageData);

    function ImageData(parent, key, frame) {
      var _this;

      _classCallCheck(this, ImageData);

      _this = _super.call(this, parent, ImageTypeName);

      _this.setTexture(key, frame);

      return _this;
    }

    _createClass(ImageData, [{
      key: "frameWidth",
      get: function get() {
        return this.frameObj ? this.frameObj.cutWidth : 0;
      }
    }, {
      key: "frameHeight",
      get: function get() {
        return this.frameObj ? this.frameObj.cutHeight : 0;
      }
    }, {
      key: "offsetY",
      get: function get() {
        return -this.height;
      },
      set: function set(value) {}
    }, {
      key: "key",
      get: function get() {
        return this._key;
      },
      set: function set(value) {
        this.setDirty(this._key != value);
        this._key = value;
      }
    }, {
      key: "frame",
      get: function get() {
        return this._frame;
      },
      set: function set(value) {
        this.setDirty(this._frame != value);
        this._frame = value;
      }
    }, {
      key: "setTexture",
      value: function setTexture(key, frame) {
        this.key = key;
        this.frame = frame;
        this.frameObj = this.scene.sys.textures.getFrame(key, frame);
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this.frameWidth * this.scaleX;
      },
      set: function set(value) {
        this.setDirty(this.width !== value);
        this.scaleX = value / this.frameWidth;
      }
    }, {
      key: "height",
      get: function get() {
        return this.frameHeight * this.scaleY;
      },
      set: function set(value) {
        this.setDirty(this.height !== value);
        this.scaleY = value / this.frameHeight;
      }
    }, {
      key: "setHeight",
      value: function setHeight(height, keepAspectRatio) {
        if (keepAspectRatio === undefined) {
          keepAspectRatio = false;
        }

        this.height = height;

        if (keepAspectRatio) {
          this.scaleX = this.scaleY;
        }

        return this;
      }
    }, {
      key: "drawContent",
      value: function drawContent() {
        var context = this.context;
        var frame = this.frameObj;
        var width = this.frameWidth,
            height = this.frameHeight;
        context.drawImage(frame.source.image, // image
        frame.cutX, frame.cutY, width, height, 0, 0, width, height);
      }
    }, {
      key: "draw",
      value: function draw() {
        if (!this.visible) {
          return this;
        }

        _get(_getPrototypeOf(ImageData.prototype), "draw", this).call(this);
      }
    }]);

    return ImageData;
  }(RenderBase);

  var AppendImage = function AppendImage(key, frame, properties) {
    var bob = this.poolManager.allocate(ImageTypeName);

    if (bob === null) {
      bob = new ImageData(this, // parent
      key, frame);
    } else {
      bob.setParent(this).setActive().setTexture(key, frame);
    }

    bob.modifyPorperties(properties);
    this.addChild(bob);
    return this;
  };

  var Command = /*#__PURE__*/function (_Base) {
    _inherits(Command, _Base);

    var _super = _createSuper(Command);

    function Command(parent, name, callback, param, scope) {
      var _this;

      _classCallCheck(this, Command);

      _this = _super.call(this, parent, CmdTypeName);

      _this.setName(name).setParameter(param).setCallback(callback, scope);

      return _this;
    }

    _createClass(Command, [{
      key: "setName",
      value: function setName(name) {
        this.name = name;
        return this;
      }
    }, {
      key: "setParameter",
      value: function setParameter(param) {
        this.param = param;
        return this;
      }
    }, {
      key: "setCallback",
      value: function setCallback(callback, scope) {
        this.callback = callback;
        this.scope = scope;
        return this;
      }
    }, {
      key: "exec",
      value: function exec() {
        var result;

        if (this.scope) {
          result = this.callback.call(this.scope, this.param, this.name);
        } else {
          result = this.callback(this.param, this.name);
        }

        return result;
      }
    }, {
      key: "draw",
      value: function draw() {}
    }, {
      key: "onFree",
      value: function onFree() {
        _get(_getPrototypeOf(Command.prototype), "onFree", this).call(this);

        this.setName().setCallback().setParameter();
      }
    }]);

    return Command;
  }(Base$1);

  var AppendCommand$3 = function AppendCommand(name, callback, param, scope) {
    var bob = this.poolManager.allocate(CmdTypeName);

    if (bob === null) {
      bob = new Command(this, // parent
      name, callback, param, scope);
    } else {
      bob.setParent(this).setActive().setName(name).setCallback(callback, scope).setParameter(param);
    }

    this.addChild(bob);
    return this;
  };

  var SetWrapConfig = function SetWrapConfig(config) {
    if (config === undefined) {
      config = {};
    }

    this.wrapConfig = config;
    return this;
  };

  var GetWord = function GetWord(children, startIndex, charMode, result) {
    if (result === undefined) {
      result = {
        word: [],
        width: 0
      };
    }

    result.word.length = 0;
    var endIndex = children.length;
    var currentIndex = startIndex;
    var word = result.word,
        wordWidth = 0;

    while (currentIndex < endIndex) {
      var child = children[currentIndex];

      if (child.type === CharTypeName && child.text !== ' ' && child.text !== '\n') {
        word.push(child);
        wordWidth += child.outerWidth;
        currentIndex++; // Continue
      } else {
        // Get non-text child, a space, or a new-line
        if (currentIndex === startIndex) {
          // Single child
          word.push(child);
          wordWidth += child.outerWidth;
        }

        break;
      }

      if (charMode) {
        // Word only contains 1 character
        break;
      }
    }

    result.width = wordWidth;
    return result;
  };

  var OffsetChildren = function OffsetChildren(children, offsetX, offsetY) {
    if (offsetX === 0 && offsetY === 0) {
      return;
    }

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];

      if (!CanRender(child)) {
        continue;
      }

      child.x += offsetX;
      child.y += offsetY;
    }
  };

  var GetChildrenAlign$1 = function GetChildrenAlign(children) {
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];

      if (child.align !== undefined) {
        return child.align;
      }
    }

    return undefined;
  };

  var AlignLines$1 = function AlignLines(result, width, height) {
    var hAlign = result.hAlign,
        vAlign = result.vAlign;
    var offsetX, offsetY;
    var linesHeight = result.linesHeight;

    switch (vAlign) {
      case 1: // center

      case 'center':
        offsetY = (height - linesHeight) / 2;
        break;

      case 2: // bottom

      case 'bottom':
        offsetY = height - linesHeight;
        break;

      default:
        offsetY = 0;
        break;
    }

    var lines = result.lines;

    for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
      var line = lines[li];
      var lineWidth = line.width,
          children = line.children;
      var lineHAlign = GetChildrenAlign$1(children);

      if (lineHAlign === undefined) {
        lineHAlign = hAlign;
      }

      switch (lineHAlign) {
        case 1: // center

        case 'center':
          offsetX = (width - lineWidth) / 2;
          break;

        case 2: // right

        case 'right':
          offsetX = width - lineWidth;
          break;

        default:
          offsetX = 0;
          break;
      }

      OffsetChildren(children, offsetX, offsetY);
    }
  };

  var GetValue$2j = Phaser.Utils.Objects.GetValue;

  var RunWordWrap$1 = function RunWordWrap(config) {
    // Parse parameters
    var startIndex = GetValue$2j(config, 'start', 0);
    var paddingTop = GetValue$2j(config, 'padding.top', 0);
    var paddingBottom = GetValue$2j(config, 'padding.bottom', 0); // Add extra space below last line
    // Get lineHeight, maxLines

    var lineHeight = GetValue$2j(config, 'lineHeight', undefined);
    var maxLines;

    if (lineHeight === undefined) {
      // Calculate lineHeight via maxLines, in fixedHeight mode
      maxLines = GetValue$2j(config, 'maxLines', 0);

      if (this.fixedHeight > 0) {
        var innerHeight = this.fixedHeight - this.padding.top - this.padding.bottom - paddingTop - paddingBottom;
        lineHeight = innerHeight / maxLines;
      } else {
        lineHeight = 0;
      }
    } else {
      if (this.fixedHeight > 0) {
        // Calculate maxLines via lineHeight, in fixedHeight mode
        maxLines = GetValue$2j(config, 'maxLines', undefined);

        if (maxLines === undefined) {
          var innerHeight = this.fixedHeight - this.padding.top - this.padding.bottom - paddingTop - paddingBottom;
          maxLines = Math.floor(innerHeight / lineHeight);
        }
      } else {
        maxLines = GetValue$2j(config, 'maxLines', 0); // Default is show all lines
      }
    }

    var showAllLines = maxLines === 0; // Get wrapWidth

    var wrapWidth = GetValue$2j(config, 'wrapWidth', undefined);

    if (wrapWidth === undefined) {
      if (this.fixedWidth > 0) {
        wrapWidth = this.fixedWidth - this.padding.left - this.padding.right;
      } else {
        wrapWidth = Infinity; // No word-wrap
      }
    }

    var letterSpacing = GetValue$2j(config, 'letterSpacing', 0);
    var hAlign = GetValue$2j(config, 'hAlign', 0);
    var vAlign = GetValue$2j(config, 'vAlign', 0);
    var charWrap = GetValue$2j(config, 'charWrap', false);
    var result = {
      start: startIndex,
      // Next start index
      isLastPage: false,
      // Is last page
      padding: {
        top: paddingTop,
        bottom: paddingBottom
      },
      lineHeight: lineHeight,
      maxLines: maxLines,
      wrapWidth: wrapWidth,
      letterSpacing: letterSpacing,
      hAlign: hAlign,
      vAlign: vAlign,
      charWrap: charWrap,
      children: [],
      // Word-wrap result
      lines: [],
      // Word-wrap result in lines
      maxLineWidth: 0,
      linesHeight: 0
    }; // Set all children to inactive

    var children = this.children;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setActive(false);
    } // Layout children


    wrapWidth += letterSpacing;
    var startX = this.padding.left,
        startY = this.padding.top + lineHeight + paddingTop,
        // Start(baseline) from 1st lineHeight, not 0
    x = startX,
        y = startY;
    var remainderWidth = wrapWidth,
        childIndex = startIndex,
        lastChildIndex = children.length;
    var resultChildren = result.children;
    var resultLines = result.lines,
        lastLine = [],
        lastLineWidth = 0,
        maxLineWidth = 0;
    var wordResult;

    while (childIndex < lastChildIndex) {
      // Append non-typeable child directly
      var child = children[childIndex];

      if (!CanRender(child)) {
        childIndex++;
        child.setActive();
        resultChildren.push(child);
        lastLine.push(child);
        continue;
      }

      wordResult = GetWord(children, childIndex, charWrap, wordResult);
      var word = wordResult.word;
      var charCnt = word.length;
      var wordWidth = wordResult.width + charCnt * letterSpacing;
      childIndex += charCnt; // Next line

      var isNewLineChar = IsNewLineChar(word[0]);

      if (remainderWidth < wordWidth || isNewLineChar) {
        // Add to result
        if (isNewLineChar) {
          var _char = word[0];

          _char.setActive().setPosition(x, y);

          resultChildren.push(_char);
          lastLine.push(_char);
        } // Move cursor


        x = startX;
        y += lineHeight;
        remainderWidth = wrapWidth;
        resultLines.push({
          children: lastLine,
          width: lastLineWidth
        });
        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        lastLineWidth = 0;
        lastLine = [];

        if (!showAllLines && resultLines.length === maxLines) {
          // Exceed maxLines
          break;
        } else if (isNewLineChar) {
          // Already add to result
          continue;
        }
      }

      remainderWidth -= wordWidth;
      lastLineWidth += wordWidth;

      for (var i = 0, cnt = word.length; i < cnt; i++) {
        var _char = word[i];

        _char.setActive().setPosition(x, y);

        resultChildren.push(_char);
        lastLine.push(_char);
        x += _char.outerWidth + letterSpacing;
      }
    }

    if (lastLine.length > 0) {
      resultLines.push({
        children: lastLine,
        width: lastLineWidth
      });
      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
    }

    result.start += resultChildren.length;
    result.isLastPage = result.start === lastChildIndex;
    result.maxLineWidth = maxLineWidth;
    result.linesHeight = resultLines.length * lineHeight + paddingTop + paddingBottom; // Calculate size of game object

    var width = this.fixedWidth > 0 ? this.fixedWidth : result.maxLineWidth + this.padding.left + this.padding.right;
    var height = this.fixedHeight > 0 ? this.fixedHeight : result.linesHeight + this.padding.top + this.padding.bottom; // Size might be changed after wrapping

    var innerWidth = width - this.padding.left - this.padding.right;
    var innerHeight = height - this.padding.top - this.padding.bottom - paddingTop - paddingBottom;
    AlignLines$1(result, innerWidth, innerHeight); // Resize

    this.setSize(width, height);
    return result;
  };

  var Merge$2 = Phaser.Utils.Objects.Merge;

  var RunWordWrap = function RunWordWrap(config) {
    if (config === undefined) {
      config = {};
    }

    return RunWordWrap$1.call(this, Merge$2(config, this.wrapConfig));
  };

  var AlignLines = function AlignLines(result, width, height) {
    var hAlign = result.hAlign,
        vAlign = result.vAlign;
    var offsetX, offsetY;
    var rtl = result.rtl;
    var lines = result.lines,
        lineWidth = result.lineWidth,
        linesWidth = result.linesWidth;

    switch (hAlign) {
      case 1: // center

      case 'center':
        offsetX = (width - linesWidth) / 2;
        break;

      case 2: // right

      case 'right':
        offsetX = width - linesWidth;
        break;

      default:
        // left
        offsetX = 0;
        break;
    }

    if (rtl) {
      offsetX += lineWidth;
    }

    for (var li = 0, lcnt = lines.length; li < lcnt; li++) {
      var line = lines[rtl ? lcnt - li - 1 : li];
      var children = line.children;
      var lineHeight = line.height;
      var lineVAlign = GetChildrenAlign(children);

      if (lineVAlign === undefined) {
        lineVAlign = vAlign;
      }

      switch (lineVAlign) {
        case 1: // center

        case 'center':
          offsetY = (height - lineHeight) / 2;
          break;

        case 2: // bottom

        case 'bottom':
          offsetY = height - lineHeight;
          break;

        default:
          // top
          offsetY = 0;
          break;
      }

      OffsetChildren(children, offsetX, offsetY);
      offsetX += lineWidth;
    }
  };

  var GetValue$2i = Phaser.Utils.Objects.GetValue;

  var RunVerticalWrap$1 = function RunVerticalWrap(config) {
    // Parse parameters
    var startIndex = GetValue$2i(config, 'start', 0);
    var extraTopPadding = GetValue$2i(config, 'padding.top', 0);
    var extraBottomPadding = GetValue$2i(config, 'padding.bottom', 0); // Add extra space below last character

    var extraLeftPadding = GetValue$2i(config, 'padding.left', 0);
    var extraRightPadding = GetValue$2i(config, 'padding.right', 0);
    var lineWidth = GetValue$2i(config, 'lineWidth', undefined);
    var maxLines;

    if (lineWidth === undefined) {
      // Calculate lineWidth via maxLines, in fixedWidth mode
      maxLines = GetValue$2i(config, 'maxLines', 0);

      if (this.fixedWidth > 0) {
        var innerWidth = this.fixedWidth - this.padding.left - this.padding.right - extraLeftPadding - extraRightPadding;
        lineWidth = innerWidth / maxLines;
      } else {
        lineWidth = 0;
      }
    } else {
      if (this.fixedWidth > 0) {
        // Calculate maxLines via lineWidth, in fixedWidth mode
        maxLines = GetValue$2i(config, 'maxLines', undefined);

        if (maxLines === undefined) {
          var innerWidth = this.fixedWidth - this.padding.left - this.padding.right;
          maxLines = Math.floor(innerWidth / lineWidth);
        }
      } else {
        maxLines = GetValue$2i(config, 'maxLines', 0); // Default is show all lines
      }
    }

    var showAllLines = maxLines === 0; // Get fixedChildHeight

    var fixedChildHeight = GetValue$2i(config, 'fixedChildHeight', undefined);

    if (fixedChildHeight === undefined) {
      var charPerLine = GetValue$2i(config, 'charPerLine', undefined);

      if (charPerLine !== undefined) {
        var innerHeight = this.fixedHeight - this.padding.top - this.padding.bottom - extraTopPadding - extraBottomPadding;
        fixedChildHeight = Math.floor(innerHeight / charPerLine);
      }
    } // Get wrapHeight


    var wrapHeight = GetValue$2i(config, 'wrapHeight', undefined);

    if (wrapHeight === undefined) {
      if (this.fixedHeight > 0) {
        wrapHeight = this.fixedHeight - this.padding.top - this.padding.bottom;
      } else {
        wrapHeight = Infinity; // No word-wrap
      }
    }

    var letterSpacing = GetValue$2i(config, 'letterSpacing', 0);
    var rtl = GetValue$2i(config, 'rtl', true);
    var hAlign = GetValue$2i(config, 'hAlign', rtl ? 2 : 0);
    var vAlign = GetValue$2i(config, 'vAlign', 0);
    var result = {
      start: startIndex,
      // Next start index
      isLastPage: false,
      // Is last page
      padding: {
        top: extraTopPadding,
        bottom: extraBottomPadding,
        left: extraLeftPadding,
        right: extraRightPadding
      },
      lineWidth: lineWidth,
      maxLines: maxLines,
      fixedChildHeight: fixedChildHeight,
      wrapHeight: wrapHeight,
      letterSpacing: letterSpacing,
      hAlign: hAlign,
      vAlign: vAlign,
      rtl: rtl,
      children: [],
      // Word-wrap result
      lines: [],
      // Word-wrap result in lines
      maxLineHeight: 0,
      linesWidth: 0
    }; // Set all children to active

    var children = this.children;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      children[i].setActive(false);
    } // Layout children


    wrapHeight += letterSpacing;
    var startX = this.padding.left + extraLeftPadding,
        // Reset x of each character in AlignLines method
    startY = this.padding.top + extraTopPadding,
        x = startX,
        y = startY;
    var remainderHeight = wrapHeight,
        childIndex = startIndex,
        lastChildIndex = children.length;
    var resultChildren = result.children;
    var resultLines = result.lines,
        lastLine = [],
        lastLineHeight = 0,
        maxLineHeight = 0;

    while (childIndex < lastChildIndex) {
      // Append non-typeable child directly
      var _char = children[childIndex];
      childIndex++;

      if (!CanRender(_char)) {
        _char.setActive();

        resultChildren.push(_char);
        lastLine.push(_char);
        continue;
      }

      var childHeight = (fixedChildHeight !== undefined ? fixedChildHeight : _char.height) + letterSpacing; // Next line

      var isNewLineChar = IsNewLineChar(_char);

      if (remainderHeight < childHeight || isNewLineChar) {
        // Add to result
        if (isNewLineChar) {
          _char.setActive().setPosition(x, y).setOrigin(0.5);

          resultChildren.push(_char);
          lastLine.push(_char);
        } // Move cursor


        x = startX;
        y = startY;
        remainderHeight = wrapHeight;
        resultLines.push({
          children: lastLine,
          height: lastLineHeight
        });
        maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
        lastLineHeight = 0;
        lastLine = [];

        if (!showAllLines && resultLines.length === maxLines) {
          // Exceed maxLines
          break;
        } else if (isNewLineChar) {
          // Already add to result                
          continue;
        }
      }

      remainderHeight -= childHeight;
      lastLineHeight += childHeight;

      _char.setActive().setPosition(x, y).setOrigin(0.5);

      resultChildren.push(_char);
      lastLine.push(_char);
      y += childHeight;
    }

    if (lastLine.length > 0) {
      resultLines.push({
        children: lastLine,
        height: lastLineHeight
      });
      maxLineHeight = Math.max(maxLineHeight, lastLineHeight);
    }

    result.start += resultChildren.length;
    result.isLastPage = result.start === lastChildIndex;
    result.maxLineHeight = maxLineHeight;
    result.linesWidth = resultLines.length * lineWidth + extraLeftPadding + extraRightPadding; // Calculate size of game object

    var width = this.fixedWidth > 0 ? this.fixedWidth : result.linesWidth + this.padding.left + this.padding.right;
    var height = this.fixedHeight > 0 ? this.fixedHeight : result.maxLineHeight + this.padding.top + this.padding.bottom; // Size might be changed after wrapping

    var innerWidth = width - this.padding.left - this.padding.right - extraLeftPadding - extraRightPadding;
    var innerHeight = height - this.padding.top - this.padding.bottom - extraTopPadding - extraBottomPadding;
    AlignLines(result, innerWidth, innerHeight); // Resize

    this.setSize(width, height);
    return result;
  };

  var Merge$1 = Phaser.Utils.Objects.Merge;

  var RunVerticalWrap = function RunVerticalWrap(config) {
    if (config === undefined) {
      config = {};
    }

    return RunVerticalWrap$1.call(this, Merge$1(config, this.wrapConfig));
  };

  var DrawContent$1 = function DrawContent() {
    this.clear();
    var width = this.fixedWidth > 0 ? this.fixedWidth : this.width;
    var height = this.fixedHeight > 0 ? this.fixedHeight : this.height;
    this.setSize(width, height);

    if (this.background.active) {
      this.background.draw();
    }

    var child;

    for (var i = 0, cnt = this.children.length; i < cnt; i++) {
      child = this.children[i];

      if (child.active && child.visible) {
        child.draw();
      }
    }

    if (this.innerBounds.active) {
      this.innerBounds.draw();
    }
  };

  var GetChildren = function GetChildren() {
    return this.children;
  };

  var GetLastAppendedChildren = function GetLastAppendedChildren() {
    return this.lastAppendedChildren;
  };

  var GetAll = Phaser.Utils.Array.GetAll;

  var GetActiveChildren = function GetActiveChildren() {
    return GetAll(this.children, 'active', true);
  };

  var Methods$7 = {
    setFixedSize: SetFixedSize,
    setPadding: SetPadding,
    getPadding: GetPadding,
    modifyTextStyle: ModifyTextStyle,
    resetTextStyle: ResetTextStyle,
    removeChild: RemoveChild$1,
    removeChildren: RemoveChildren,
    clearContent: ClearContent,
    addChild: AddChild$1,
    setText: SetText$2,
    appendText: AppendText$1,
    appendImage: AppendImage,
    appendCommand: AppendCommand$3,
    setWrapConfig: SetWrapConfig,
    runWordWrap: RunWordWrap,
    runVerticalWrap: RunVerticalWrap,
    drawContent: DrawContent$1,
    getChildren: GetChildren,
    getLastAppendedChildren: GetLastAppendedChildren,
    getActiveChildren: GetActiveChildren
  };

  var GetFastValue$1 = Phaser.Utils.Objects.GetFastValue;
  var Pools = {};

  var PoolManager = /*#__PURE__*/function () {
    function PoolManager(config) {
      _classCallCheck(this, PoolManager);

      this.pools = GetFastValue$1(config, 'pools', Pools);
    }

    _createClass(PoolManager, [{
      key: "free",
      value: function free(bob) {
        if (!this.pools) {
          return this;
        }

        var bobType = bob.type;

        if (!this.pools.hasOwnProperty(bobType)) {
          this.pools[bobType] = new Stack();
        }

        this.pools[bobType].push(bob);
        bob.onFree();
        return this;
      }
    }, {
      key: "freeMultiple",
      value: function freeMultiple(arr) {
        if (!this.pools) {
          return this;
        }

        for (var i = 0, cnt = arr.length; i < cnt; i++) {
          this.free(arr[i]);
        }

        return this;
      }
    }, {
      key: "allocate",
      value: function allocate(bobType) {
        if (!this.pools || !this.pools.hasOwnProperty(bobType)) {
          return null;
        }

        return this.pools[bobType].pop();
      }
    }]);

    return PoolManager;
  }();

  var IsPlainObject$s = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$2h = Phaser.Utils.Objects.GetValue;

  var DynamicText = /*#__PURE__*/function (_Canvas) {
    _inherits(DynamicText, _Canvas);

    var _super = _createSuper(DynamicText);

    function DynamicText(scene, x, y, fixedWidth, fixedHeight, config) {
      var _this;

      _classCallCheck(this, DynamicText);

      if (IsPlainObject$s(x)) {
        config = x;
        x = GetValue$2h(config, 'x', 0);
        y = GetValue$2h(config, 'y', 0);
        fixedWidth = GetValue$2h(config, 'width', 0);
        fixedHeight = GetValue$2h(config, 'height', 0);
      } else if (IsPlainObject$s(fixedWidth)) {
        config = fixedWidth;
        fixedWidth = GetValue$2h(config, 'width', 0);
        fixedHeight = GetValue$2h(config, 'height', 0);
      }

      var width = fixedWidth === 0 ? 1 : fixedWidth;
      var height = fixedHeight === 0 ? 1 : fixedHeight;
      _this = _super.call(this, scene, x, y, width, height);
      _this.type = 'rexDynamicText';
      _this.autoRound = true;
      _this.padding = {};
      var textStyleConfig = GetValue$2h(config, 'style', undefined);
      _this.defaultTextStyle = new TextStyle(textStyleConfig);
      _this.textStyle = _this.defaultTextStyle.clone();
      _this.background = new Background(_assertThisInitialized(_this), GetValue$2h(config, 'background', undefined));
      _this.innerBounds = new InnerBounds(_assertThisInitialized(_this), GetValue$2h(config, 'innerBounds', undefined));
      _this.children = [];
      _this.lastAppendedChildren = [];
      _this.poolManager = new PoolManager(config);

      _this.setFixedSize(fixedWidth, fixedHeight);

      _this.setPadding(GetValue$2h(config, 'padding', 0));

      _this.setWrapConfig(GetValue$2h(config, 'wrap', undefined));

      var text = GetValue$2h(config, 'text', undefined);

      if (text) {
        _this.setText(text);
      }

      return _this;
    }

    _createClass(DynamicText, [{
      key: "updateTexture",
      value: function updateTexture() {
        this.drawContent();

        _get(_getPrototypeOf(DynamicText.prototype), "updateTexture", this).call(this);

        return this;
      }
    }]);

    return DynamicText;
  }(Canvas);

  Object.assign(DynamicText.prototype, Methods$7);

  ObjectFactory.register('dynamicText', function (x, y, width, height, config) {
    var gameObject = new DynamicText(this.scene, x, y, width, height, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.DynamicText', DynamicText);

  var EventEmitterMethods = {
    setEventEmitter: function setEventEmitter(eventEmitter, EventEmitterClass) {
      if (EventEmitterClass === undefined) {
        EventEmitterClass = Phaser.Events.EventEmitter; // Use built-in EventEmitter class by default
      }

      this._privateEE = eventEmitter === true || eventEmitter === undefined;
      this._eventEmitter = this._privateEE ? new EventEmitterClass() : eventEmitter;
      return this;
    },
    destroyEventEmitter: function destroyEventEmitter() {
      if (this._eventEmitter && this._privateEE) {
        this._eventEmitter.shutdown();
      }

      return this;
    },
    getEventEmitter: function getEventEmitter() {
      return this._eventEmitter;
    },
    on: function on() {
      if (this._eventEmitter) {
        this._eventEmitter.on.apply(this._eventEmitter, arguments);
      }

      return this;
    },
    once: function once() {
      if (this._eventEmitter) {
        this._eventEmitter.once.apply(this._eventEmitter, arguments);
      }

      return this;
    },
    off: function off() {
      if (this._eventEmitter) {
        this._eventEmitter.off.apply(this._eventEmitter, arguments);
      }

      return this;
    },
    emit: function emit(event) {
      if (this._eventEmitter && event) {
        this._eventEmitter.emit.apply(this._eventEmitter, arguments);
      }

      return this;
    },
    addListener: function addListener() {
      if (this._eventEmitter) {
        this._eventEmitter.addListener.apply(this._eventEmitter, arguments);
      }

      return this;
    },
    removeListener: function removeListener() {
      if (this._eventEmitter) {
        this._eventEmitter.removeListener.apply(this._eventEmitter, arguments);
      }

      return this;
    },
    removeAllListeners: function removeAllListeners() {
      if (this._eventEmitter) {
        this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments);
      }

      return this;
    },
    listenerCount: function listenerCount() {
      if (this._eventEmitter) {
        return this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments);
      }

      return 0;
    },
    listeners: function listeners() {
      if (this._eventEmitter) {
        return this._eventEmitter.listeners.apply(this._eventEmitter, arguments);
      }

      return [];
    },
    eventNames: function eventNames() {
      if (this._eventEmitter) {
        return this._eventEmitter.eventNames.apply(this._eventEmitter, arguments);
      }

      return [];
    }
  };

  // https://github.com/sindresorhus/escape-string-regexp/blob/master/index.js
  var EscapeRegex = function EscapeRegex(s) {
    return s.replace(re0, '\\$&').replace(re1, '\\x2d');
  };

  var re0 = /[|\\{}()[\]^$+*?.]/g;
  var re1 = /-/g;

  var FLOAT = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i;

  var convert = function convert(s) {
    if (typeof s !== 'string') {
      return s;
    }

    if (s === '') {
      s = null;
    } else if (FLOAT.test(s)) {
      s = parseFloat(s);
    } else {
      if (s === 'false') {
        s = false;
      } else if (s === 'true') {
        s = true;
      }
    }

    return s;
  };

  var ParseValue$1 = function ParseValue(text, valueConverter) {
    if (text == null) {
      return [];
    }

    var values = text.split(',');

    for (var i = 0, cnt = values.length; i < cnt; i++) {
      values[i] = valueConverter(values[i]);
    }

    return values;
  };

  var DefaultTagExpression = "[a-z0-9-_.]+";
  var DefaultValueExpression = "[ #a-z-_.0-9,|&]+";

  var BypassValueConverter = function BypassValueConverter(s) {
    return s;
  };

  var BracketParser = /*#__PURE__*/function () {
    function BracketParser(config) {
      _classCallCheck(this, BracketParser);

      // Event emitter
      this.setEventEmitter(GetValue$2E(config, 'eventEmitter', undefined)); // Parameters for regex

      this.setTagExpression(GetValue$2E(config, 'regex.tag', DefaultTagExpression));
      this.setValueExpression(GetValue$2E(config, 'regex.value', DefaultValueExpression)); // Value convert

      this.setValueConverter(GetValue$2E(config, 'valueConvert', true)); // Brackets and generate regex

      var delimiters = GetValue$2E(config, 'delimiters', '<>');
      this.setDelimiters(delimiters[0], delimiters[1]);
      this.isRunning = false;
      this.isPaused = false;
      this.skipEventFlag = false;
      this.lastTagStart = null;
      this.lastTagEnd = null;
      this.lastContent = null;
    }

    _createClass(BracketParser, [{
      key: "shutdown",
      value: function shutdown() {
        this.destroyEventEmitter();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.shutdown();
      }
    }, {
      key: "setTagExpression",
      value: function setTagExpression(express) {
        this.tagExpression = express;
        return this;
      }
    }, {
      key: "setValueExpression",
      value: function setValueExpression(express) {
        this.valueExpression = express;
        return this;
      }
    }, {
      key: "setValueConverter",
      value: function setValueConverter(converter) {
        if (converter === true) {
          converter = convert;
        } else if (!converter) {
          converter = BypassValueConverter;
        }

        this.valueConverter = converter;
        return this;
      }
    }, {
      key: "setDelimiters",
      value: function setDelimiters(delimiterLeft, delimiterRight) {
        if (delimiterRight === undefined) {
          delimiterRight = delimiterLeft[1];
          delimiterLeft = delimiterLeft[0];
        }

        this.delimiterLeft = delimiterLeft;
        this.delimiterRight = delimiterRight;
        delimiterLeft = EscapeRegex(delimiterLeft);
        delimiterRight = EscapeRegex(delimiterRight);
        var tagOn = "".concat(delimiterLeft, "(").concat(this.tagExpression, ")(=(").concat(this.valueExpression, "))?").concat(delimiterRight);
        var tagOff = "".concat(delimiterLeft, "/(").concat(this.tagExpression, ")").concat(delimiterRight);
        this.reTagOn = RegExp(tagOn, 'i');
        this.reTagOff = RegExp(tagOff, 'i');
        this.reSplit = RegExp("".concat(tagOn, "|").concat(tagOff), 'gi');
        return this;
      }
    }, {
      key: "setSource",
      value: function setSource(source) {
        this.source = source;
        return this;
      }
    }, {
      key: "resetIndex",
      value: function resetIndex(index) {
        if (index === undefined) {
          index = 0;
        }

        this.progressIndex = index;
        this.reSplit.lastIndex = index;
        this.lastTagStart = null;
        this.lastTagEnd = null;
        this.lastContent = null;
        return this;
      }
    }, {
      key: "start",
      value: function start(source) {
        this.setSource(source).restart();
        return this;
      }
    }, {
      key: "restart",
      value: function restart() {
        this.resetIndex().next();
      }
    }, {
      key: "next",
      value: function next() {
        if (this.isPaused) {
          this.onResume();
        }

        var text = this.source,
            lastIndex = text.length;

        if (this.reSplit.lastIndex === 0) {
          this.onStart();
        }

        while (!this.isPaused) {
          var regexResult = this.reSplit.exec(text);

          if (!regexResult) {
            if (this.progressIndex < lastIndex) {
              this.onContent(text.substring(this.progressIndex, lastIndex));
            }

            this.onComplete();
            return;
          }

          var match = regexResult[0];
          var matchStart = this.reSplit.lastIndex - match.length;

          if (this.progressIndex < matchStart) {
            this.onContent(text.substring(this.progressIndex, matchStart));
          }

          if (this.reTagOff.test(match)) {
            this.onTagEnd(match);
          } else {
            this.onTagStart(match);
          }

          this.progressIndex = this.reSplit.lastIndex;
        }
      }
    }, {
      key: "skipEvent",
      value: function skipEvent() {
        this.skipEventFlag = true;
        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        if (!this.isPaused) {
          this.onPause();
        }

        return this;
      }
    }, {
      key: "onContent",
      value: function onContent(content) {
        this.emit('content', content);
        this.lastContent = content;
      }
    }, {
      key: "onTagStart",
      value: function onTagStart(tagContent) {
        var regexResult = tagContent.match(this.reTagOn);
        var tag = regexResult[1];
        var values = ParseValue$1(regexResult[3], this.valueConverter);
        this.skipEventFlag = false;
        this.emit.apply(this, ["+".concat(tag)].concat(_toConsumableArray(values)));

        if (!this.skipEventFlag) {
          this.emit.apply(this, ['+', tag].concat(_toConsumableArray(values)));
        }

        this.lastTagStart = tag;
      }
    }, {
      key: "onTagEnd",
      value: function onTagEnd(tagContent) {
        var tag = tagContent.match(this.reTagOff)[1];
        this.skipEventFlag = false;
        this.emit("-".concat(tag));

        if (!this.skipEventFlag) {
          this.emit('-', tag);
        }

        this.lastTagEnd = tag;
      }
    }, {
      key: "onStart",
      value: function onStart() {
        this.isRunning = true;
        this.emit('start', this);
      }
    }, {
      key: "onComplete",
      value: function onComplete() {
        this.isRunning = false;
        this.emit('complete', this);
        this.resetIndex();
      }
    }, {
      key: "onPause",
      value: function onPause() {
        this.isPaused = true;
        this.emit('pause', this);
      }
    }, {
      key: "onResume",
      value: function onResume() {
        this.isPaused = false;
        this.emit('resume', this);
      }
    }]);

    return BracketParser;
  }();

  Object.assign(BracketParser.prototype, EventEmitterMethods);

  var GetValue$2g = Phaser.Utils.Objects.GetValue;

  var OnParseColorTag = function OnParseColorTag(textPlayer, parser, config) {
    var tagName = GetValue$2g(config, 'tags.color', 'color');
    var defaultColor;
    parser.on('start', function () {
      defaultColor = textPlayer.textStyle.color;
    }).on("+".concat(tagName), function (color) {
      textPlayer.textStyle.setColor(color);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setColor(defaultColor);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setColor(defaultColor);
    });
  };

  var GetValue$2f = Phaser.Utils.Objects.GetValue;

  var OnParseStrokeColorTag = function OnParseStrokeColorTag(textPlayer, parser, config) {
    var tagName = GetValue$2f(config, 'tags.stroke', 'stroke');
    var defaultStroke;
    parser.on('start', function () {
      defaultStroke = textPlayer.textStyle.stroke;
      textPlayer.textStyle.setStrokeStyle(null);
    }).on("+".concat(tagName), function (color) {
      if (color === undefined) {
        color = defaultStroke;
      }

      textPlayer.textStyle.setStrokeStyle(color);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setStrokeStyle(null);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setStrokeStyle(defaultStroke);
    });
  };

  var GetValue$2e = Phaser.Utils.Objects.GetValue;

  var OnParseBoldTag$1 = function OnParseBoldTag(textPlayer, parser, config) {
    var tagName = GetValue$2e(config, 'tags.b', 'b');
    parser.on('start', function () {
      textPlayer.textStyle.setBold(false);
    }).on("+".concat(tagName), function () {
      textPlayer.textStyle.setBold(true);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setBold(false);
      parser.skipEvent();
    });
  };

  var GetValue$2d = Phaser.Utils.Objects.GetValue;

  var OnParseItalicTag = function OnParseItalicTag(textPlayer, parser, config) {
    var tagName = GetValue$2d(config, 'tags.i', 'i');
    parser.on('start', function () {
      textPlayer.textStyle.setItalic(false);
    }).on("+".concat(tagName), function () {
      textPlayer.textStyle.setItalic(true);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setItalic(false);
      parser.skipEvent();
    });
  };

  var GetValue$2c = Phaser.Utils.Objects.GetValue;

  var OnParseFontSizeTag = function OnParseFontSizeTag(textPlayer, parser, config) {
    var tagName = GetValue$2c(config, 'tags.size', 'size');
    var defaultFontSize;
    parser.on('start', function () {
      defaultFontSize = textPlayer.textStyle.fontSize;
    }).on("+".concat(tagName), function (fontSize) {
      textPlayer.textStyle.setFontSize(fontSize);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setFontSize(defaultFontSize);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setFontSize(defaultFontSize);
    });
  };

  var GetValue$2b = Phaser.Utils.Objects.GetValue;

  var OnParseOffsetYTag = function OnParseOffsetYTag(textPlayer, parser, config) {
    var tagName = GetValue$2b(config, 'tags.y', 'y');
    var defaultOffsetY;
    parser.on('start', function () {
      defaultOffsetY = textPlayer.textStyle.offsetY;
      textPlayer.textStyle.setOffsetY(0);
    }).on("+".concat(tagName), function (y) {
      if (y === undefined) {
        y = defaultOffsetY;
      }

      textPlayer.textStyle.setOffsetY(y);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setOffsetY(0);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setOffsetY(0);
    });
  };

  var GetValue$2a = Phaser.Utils.Objects.GetValue;

  var OnParseShadowColorTag = function OnParseShadowColorTag(textPlayer, parser, config) {
    var tagName = GetValue$2a(config, 'tags.shadow', 'shadow');
    var defaultShadowColor;
    parser.on('start', function () {
      defaultShadowColor = textPlayer.textStyle.shadowColor;
      textPlayer.textStyle.setShadowColor(null);
    }).on("+".concat(tagName), function (color) {
      if (color === undefined) {
        color = defaultShadowColor;
      }

      textPlayer.textStyle.setShadowColor(color);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setShadowColor(null);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setShadowColor(defaultShadowColor);
    });
  };

  var GetValue$29 = Phaser.Utils.Objects.GetValue;

  var OnParseAlignTag = function OnParseAlignTag(textPlayer, parser, config) {
    var tagName = GetValue$29(config, 'tags.align', 'align');
    parser.on("+".concat(tagName), function (align) {
      textPlayer.textStyle.setAlign(align);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      textPlayer.textStyle.setAlign();
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.textStyle.setAlign();
    });
  };

  var GetValue$28 = Phaser.Utils.Objects.GetValue;

  var OnParseImageTag = function OnParseImageTag(textPlayer, parser, config) {
    var tagName = GetValue$28(config, 'tags.img', 'img');
    parser.on("+".concat(tagName), function (name) {
      var imgData = textPlayer.imageManager.get(name);
      AppendImage.call(textPlayer, imgData.key, imgData.frame, {
        width: imgData.width,
        hieght: imgData.height,
        leftSpace: imgData.left,
        rightSpace: imgData.right
      });
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var GetValue$27 = Phaser.Utils.Objects.GetValue;

  var OnParseTypingSpeedTag = function OnParseTypingSpeedTag(textPlayer, parser, config) {
    var tagName = GetValue$27(config, 'tags.speed', 'speed');
    var defaultSpeed;
    parser.on('start', function () {
      defaultSpeed = textPlayer.typeWriter.speed;
    }).on("+".concat(tagName), function (speed) {
      AppendCommand$2(textPlayer, speed);
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      AppendCommand$2(textPlayer, defaultSpeed);
      parser.skipEvent();
    }).on('complete', function () {
      textPlayer.typeWriter.speed = defaultSpeed;
    });
  };

  var SetSpeed = function SetSpeed(speed) {
    this.typeWriter.setSpeed(speed); // this: textPlayer
  };

  var AppendCommand$2 = function AppendCommand(textPlayer, speed) {
    AppendCommand$3.call(textPlayer, 'speed', // name
    SetSpeed, // callback
    speed, // params
    textPlayer // scope
    );
  };

  var GetValue$26 = Phaser.Utils.Objects.GetValue;

  var OnParsePlaySoundEffectTag = function OnParsePlaySoundEffectTag(textPlayer, parser, config) {
    var tagName = GetValue$26(config, 'tags.se', 'se');
    parser.on("+".concat(tagName), function (name, fadeInTime) {
      AppendCommand$3.call(textPlayer, 'se', // name
      PlaySoundEffect, // callback
      [name, fadeInTime], // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var PlaySoundEffect = function PlaySoundEffect(params) {
    if (this.skipSoundEffect) {
      return;
    }

    var name = params[0];
    var fadeInTime = params[1];
    this.soundManager.playSoundEffect(name); // this: textPlayer

    if (fadeInTime) {
      this.soundManager.fadeInSoundEffect(fadeInTime);
    }
  };

  var GetValue$25 = Phaser.Utils.Objects.GetValue;

  var OnParseFadeInSoundEffectTag = function OnParseFadeInSoundEffectTag(textPlayer, parser, config) {
    var tagName = GetValue$25(config, 'tags.se.fadein', 'se.fadein');
    parser.on("+".concat(tagName), function (time) {
      AppendCommand$3.call(textPlayer, 'se.fadein', // name
      FadeInSoundEffect, // callback
      time, // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var FadeInSoundEffect = function FadeInSoundEffect(time) {
    // this: textPlayer
    this.soundManager.fadeInSoundEffect(time);
  };

  var GetValue$24 = Phaser.Utils.Objects.GetValue;

  var OnParseFadeOutSoundEffectTag = function OnParseFadeOutSoundEffectTag(textPlayer, parser, config) {
    var tagName = GetValue$24(config, 'tags.se.fadeout', 'se.fadeout');
    parser.on("+".concat(tagName), function (time, isStopped) {
      isStopped = isStopped === 'stop';
      AppendCommand$3.call(textPlayer, 'se.fadeout', // name
      FadeOutSoundEffect, // callback
      [time, isStopped], // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var FadeOutSoundEffect = function FadeOutSoundEffect(params) {
    var _this$soundManager;

    // this: textPlayer
    (_this$soundManager = this.soundManager).fadeOutSoundEffect.apply(_this$soundManager, _toConsumableArray(params));
  };

  var GetValue$23 = Phaser.Utils.Objects.GetValue;

  var OnParseSetSoundEffectVolumeTag = function OnParseSetSoundEffectVolumeTag(textPlayer, parser, config) {
    var tagName = GetValue$23(config, 'tags.se.volume', 'se.volume');
    parser.on("+".concat(tagName), function (name) {
      AppendCommand$3.call(textPlayer, 'se.volume', // name
      SetSoundEffectVolume, // callback
      name, // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var SetSoundEffectVolume = function SetSoundEffectVolume(name) {
    // this: textPlayer
    this.soundManager.setSoundEffectVolume(name);
  };

  var GetValue$22 = Phaser.Utils.Objects.GetValue;

  var OnParsePlayBackgroundMusicTag = function OnParsePlayBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = GetValue$22(config, 'tags.bgm', 'bgm');
    parser.on("+".concat(tagName), function (name, fadeInTime) {
      AppendCommand$3.call(textPlayer, 'bgm', // name
      PlayBackgroundMusic, // callback
      [name, fadeInTime], // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, 'bgm.stop', // name
      StopBackgroundMusic, // callback
      undefined, // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var PlayBackgroundMusic = function PlayBackgroundMusic(params) {
    var name = params[0];
    var fadeInTime = params[1]; // this: textPlayer

    this.soundManager.playBackgroundMusic(name);

    if (fadeInTime) {
      this.soundManager.fadeInBackgroundMusic(fadeInTime);
    }
  };

  var StopBackgroundMusic = function StopBackgroundMusic() {
    // this: textPlayer
    this.soundManager.stopBackgroundMusic();
  };

  var GetValue$21 = Phaser.Utils.Objects.GetValue;

  var OnParseFadeInBackgroundMusicTag = function OnParseFadeInBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = GetValue$21(config, 'tags.bgm.fadein', 'bgm.fadein');
    parser.on("+".concat(tagName), function (time) {
      AppendCommand$3.call(textPlayer, 'bgm.fadein', // name
      FadeInBackgroundMusic, // callback
      time, // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var FadeInBackgroundMusic = function FadeInBackgroundMusic(time) {
    // this: textPlayer
    this.soundManager.fadeInBackgroundMusic(time);
  };

  var GetValue$20 = Phaser.Utils.Objects.GetValue;

  var OnParseFadeOutBackgroundMusicTag = function OnParseFadeOutBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = GetValue$20(config, 'tags.bgm.fadeout', 'bgm.fadeout');
    parser.on("+".concat(tagName), function (time, isStopped) {
      AppendCommand$3.call(textPlayer, 'bgm.fadeout', // name
      FadeOutBackgroundMusic, // callback
      [time, isStopped], // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var FadeOutBackgroundMusic = function FadeOutBackgroundMusic(params) {
    var _this$soundManager;

    // this: textPlayer
    (_this$soundManager = this.soundManager).fadeOutBackgroundMusic.apply(_this$soundManager, _toConsumableArray(params));
  };

  var GetValue$1$ = Phaser.Utils.Objects.GetValue;

  var OnParseCrossFadeBackgroundMusicTag = function OnParseCrossFadeBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = GetValue$1$(config, 'tags.bgm.cross', 'bgm.cross');
    parser.on("+".concat(tagName), function (name, fadeTime) {
      AppendCommand$3.call(textPlayer, 'bgm.cross', // name
      CrossFadeBackgroundMusic, // callback
      [name, fadeTime], // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var CrossFadeBackgroundMusic = function CrossFadeBackgroundMusic(params) {
    var _this$soundManager;

    // this: textPlayer
    (_this$soundManager = this.soundManager).crossFadeBackgroundMusic.apply(_this$soundManager, _toConsumableArray(params));
  };

  var GetValue$1_ = Phaser.Utils.Objects.GetValue;

  var OnParsePauseBackgroundMusicTag = function OnParsePauseBackgroundMusicTag(textPlayer, parser, config) {
    var tagName = GetValue$1_(config, 'tags.bgm.pause', 'bgm.pause');
    parser.on("+".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, 'bgm.pause', // name
      PauseBackgroundMusic, // callback
      undefined, // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      AppendCommand$3.call(textPlayer, 'bgm.resume', // name
      ResumeBackgroundMusic, // callback
      undefined, // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var PauseBackgroundMusic = function PauseBackgroundMusic() {
    // this: textPlayer
    this.soundManager.pauseBackgroundMusic();
  };

  var ResumeBackgroundMusic = function ResumeBackgroundMusic() {
    // this: textPlayer
    this.soundManager.resumeBackgroundMusic();
  };

  var GetValue$1Z = Phaser.Utils.Objects.GetValue;

  var OnParseFadeInCameraTag = function OnParseFadeInCameraTag(textPlayer, parser, config) {
    var tagName = GetValue$1Z(config, 'tags.camera.fadein', 'camera.fadein');
    parser.on("+".concat(tagName), function (duration, red, green, blue) {
      AppendCommand$3.call(textPlayer, 'camera.fadein', // name
      PlayFadeInEffect, // callback
      [duration, red, green, blue], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var PlayFadeInEffect = function PlayFadeInEffect(params) {
    var _this$camera;

    // this: textPlayer
    (_this$camera = this.camera).fadeIn.apply(_this$camera, _toConsumableArray(params));
  };

  var GetValue$1Y = Phaser.Utils.Objects.GetValue;

  var OnParseFadeOutCameraTag = function OnParseFadeOutCameraTag(textPlayer, parser, config) {
    var tagName = GetValue$1Y(config, 'tags.camera.fadeout', 'camera.fadeout');
    parser.on("+".concat(tagName), function (duration, red, green, blue) {
      AppendCommand$3.call(textPlayer, 'camera.fadeout', // name
      PlayFadeOutEffect, // callback
      [duration, red, green, blue], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var PlayFadeOutEffect = function PlayFadeOutEffect(params) {
    var _this$camera;

    // this: textPlayer
    (_this$camera = this.camera).fadeOut.apply(_this$camera, _toConsumableArray(params));
  };

  var GetValue$1X = Phaser.Utils.Objects.GetValue;

  var OnParseShakeCameraTag = function OnParseShakeCameraTag(textPlayer, parser, config) {
    var tagName = GetValue$1X(config, 'tags.camera.shake', 'camera.shake');
    parser.on("+".concat(tagName), function (duration, intensity) {
      AppendCommand$3.call(textPlayer, 'camera.shake', // name
      PlayShakeEffect, // callback
      [duration, intensity], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var PlayShakeEffect = function PlayShakeEffect(params) {
    var _this$camera;

    // this: textPlayer
    (_this$camera = this.camera).shake.apply(_this$camera, _toConsumableArray(params));
  };

  var GetValue$1W = Phaser.Utils.Objects.GetValue;

  var OnParseFlashCameraTag = function OnParseFlashCameraTag(textPlayer, parser, config) {
    var tagName = GetValue$1W(config, 'tags.camera.flash', 'camera.flash');
    parser.on("+".concat(tagName), function (duration, red, green, blue) {
      AppendCommand$3.call(textPlayer, 'camera.flash', // name
      PlayFlashEffect, // callback
      [duration, red, green, blue], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var PlayFlashEffect = function PlayFlashEffect(params) {
    var _this$camera;

    // this: textPlayer
    (_this$camera = this.camera).flash.apply(_this$camera, _toConsumableArray(params));
  };

  var GetValue$1V = Phaser.Utils.Objects.GetValue;

  var OnParseZoomCameraTag = function OnParseZoomCameraTag(textPlayer, parser, config) {
    var tagName = GetValue$1V(config, 'tags.camera.zoom', 'camera.zoom');
    parser.on("+".concat(tagName), function (value) {
      AppendCommand$3.call(textPlayer, 'camera.zoom', // name
      Zoom, // callback
      value, // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("+".concat(tagName, ".to"), function (value, duration, ease) {
      AppendCommand$3.call(textPlayer, 'camera.zoom.to', // name
      ZoomTo, // callback
      [value, duration, ease], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var Zoom = function Zoom(value) {
    // this: textPlayer
    this.camera.setZoom(value);
  };

  var ZoomTo = function ZoomTo(params) {
    var _this$camera;

    // this: textPlayer
    (_this$camera = this.camera).zoomTo.apply(_this$camera, _toConsumableArray(params));
  };

  var GetValue$1U = Phaser.Utils.Objects.GetValue;
  var DegToRad$5 = Phaser.Math.DegToRad;

  var OnParseRotateCameraTag = function OnParseRotateCameraTag(textPlayer, parser, config) {
    var tagName = GetValue$1U(config, 'tags.camera.rotate', 'camera.rotate');
    parser.on("+".concat(tagName), function (value) {
      value = DegToRad$5(value);
      AppendCommand$3.call(textPlayer, 'camera.rotate', // name
      Rotate$1, // callback
      value, // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("+".concat(tagName, ".to"), function (value, duration, ease) {
      value = DegToRad$5(value);
      AppendCommand$3.call(textPlayer, 'camera.rotate.to', // name
      RotateTo, // callback
      [value, duration, ease], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var Rotate$1 = function Rotate(value) {
    // this: textPlayer
    this.camera.setRotation(value);
  };

  var RotateTo = function RotateTo(params) {
    var value = params[0];
    var duration = params[1];
    var ease = params[2]; // this: textPlayer

    this.camera.rotateTo(value, false, duration, ease);
  };

  var GetValue$1T = Phaser.Utils.Objects.GetValue;

  var OnParseScrollCameraTag = function OnParseScrollCameraTag(textPlayer, parser, config) {
    var tagName = GetValue$1T(config, 'tags.camera.scroll', 'camera.scroll');
    parser.on("+".concat(tagName), function (x, y) {
      AppendCommand$3.call(textPlayer, 'camera.scroll', // name
      Scroll, // callback
      [x, y], // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on("+".concat(tagName, ".to"), function (x, y, duration, ease) {
      AppendCommand$3.call(textPlayer, 'camera.scroll.to', // name
      ScrollTo, // callback
      [x, y, duration, ease], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var Scroll = function Scroll(params) {
    var _this$camera;

    // this: textPlayer
    (_this$camera = this.camera).setScroll.apply(_this$camera, _toConsumableArray(params));
  };

  var ScrollTo = function ScrollTo(params) {
    var x = params[0];
    var y = params[1];
    var duration = params[2];
    var ease = params[3]; // this: textPlayer

    var camera = this.camera;
    var xSave = camera.scrollX;
    var ySave = camera.scrollY;
    camera.setScroll(x, y);
    x += camera.centerX;
    y += camera.centerY;
    camera.setScroll(xSave, ySave); // x,y in pan() is the centerX, centerY

    camera.pan(x, y, duration, ease);
  };

  var GetValue$1S = Phaser.Utils.Objects.GetValue;

  var OnParseWaitTag = function OnParseWaitTag(textPlayer, parser, config) {
    var tagWait = GetValue$1S(config, 'tags.wait', 'wait');
    var tagClick = GetValue$1S(config, 'tags.click', 'click');
    parser.on("+".concat(tagWait), function (name) {
      AppendCommand$1(textPlayer, name);
      parser.skipEvent();
    }).on("-".concat(tagWait), function () {
      parser.skipEvent();
    }).on("+".concat(tagClick), function () {
      // Equal to [wait=click]
      AppendCommand$1(textPlayer, 'click');
      parser.skipEvent();
    }).on("-".concat(tagClick), function () {
      // Equal to [/wait]
      parser.skipEvent();
    });
  };

  var Wait$1 = function Wait(name) {
    this.typeWriter.wait(name); // this: textPlayer
  };

  var AppendCommand$1 = function AppendCommand(textPlayer, name) {
    AppendCommand$3.call(textPlayer, 'wait', // name
    Wait$1, // callback
    name, // params
    textPlayer // scope
    );
  };

  var GetValue$1R = Phaser.Utils.Objects.GetValue;

  var IsAddSpriteTag = function IsAddSpriteTag(tags, prefix) {
    // sprite.name
    return tags.length === 2 && tags[0] === prefix;
  };

  var OnParseAddSpriteTag = function OnParseAddSpriteTag(textPlayer, parser, config) {
    var prefix = GetValue$1R(config, 'sprite', 'sprite');

    if (!prefix) {
      return;
    }

    parser.on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [sprite.name=key,frame], or [sprite.name]


      var tags = tag.split('.');

      if (IsAddSpriteTag(tags, prefix)) {
        var name = tags[1];

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        AppendCommand$3.call(textPlayer, 'sprite.add', // name
        AddSprite, // callback
        [name].concat(args), // params
        textPlayer // scope
        );
      } else {
        return;
      }

      parser.skipEvent();
    }).on('-', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [/sprite.name]


      var tags = tag.split('.');

      if (IsAddSpriteTag(tags, prefix)) {
        var name = tags[1];
        AppendCommand$3.call(textPlayer, 'sprite.remove', // name
        RemoveSprite, // callback
        name, // params
        textPlayer // scope
        );
      } else {
        return;
      }

      parser.skipEvent();
    });
  };

  var AddSprite = function AddSprite(params) {
    var _this$spriteManager;

    // this: textPlayer
    (_this$spriteManager = this.spriteManager).add.apply(_this$spriteManager, _toConsumableArray(params));
  };

  var RemoveSprite = function RemoveSprite(name) {
    // this: textPlayer
    this.spriteManager.remove(name);
  };

  var GetValue$1Q = Phaser.Utils.Objects.GetValue;

  var OnParseRemoveAllSpritesTag = function OnParseRemoveAllSpritesTag(textPlayer, parser, config) {
    var prefix = GetValue$1Q(config, 'sprite', 'sprite');

    if (!prefix) {
      return;
    }

    parser.on('-', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [/sprite]


      if (tag === prefix) {
        AppendCommand$3.call(textPlayer, 'sprite.removeall', // name
        RemoveAllSprites, // callback
        undefined, // params
        textPlayer // scope
        );
      } else {
        return;
      }

      parser.skipEvent();
    });
  };

  var RemoveAllSprites = function RemoveAllSprites() {
    // this: textPlayer
    this.spriteManager.removeAll();
  };

  var GetValue$1P = Phaser.Utils.Objects.GetValue;

  var IsSetTextureTag = function IsSetTextureTag(tags, prefix) {
    // sprite.name.texture
    return tags.length === 3 && tags[0] === prefix && tags[2] === 'texture';
  };

  var OnParseSetTextureTag = function OnParseSetTextureTag(textPlayer, parser, config) {
    var prefix = GetValue$1P(config, 'sprite', 'sprite');

    if (!prefix) {
      return;
    }

    parser.on('+', function (tag, textureKey, frameKey) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [sprite.name.texture=key,frame]


      var tags = tag.split('.');

      if (IsSetTextureTag(tags, prefix)) {
        var name = tags[1];
        AppendCommand$3.call(textPlayer, 'sprite.texture', // name
        SetTexture, // callback
        [name, textureKey, frameKey], // params
        textPlayer // scope
        );
      } else {
        return;
      }

      parser.skipEvent();
    });
  };

  var SetTexture = function SetTexture(params) {
    var _this$spriteManager;

    // this: textPlayer
    (_this$spriteManager = this.spriteManager).setTexture.apply(_this$spriteManager, _toConsumableArray(params));
  };

  var GetValue$1O = Phaser.Utils.Objects.GetValue;

  var IsPlayAnimationTag = function IsPlayAnimationTag(tags, prefix) {
    // sprite.name.play 
    return tags.length === 3 && tags[0] === prefix && tags[2] === 'play';
  };

  var IsStopAnimationTag = function IsStopAnimationTag(tags, prefix) {
    // sprite.name.stop 
    return tags.length === 3 && tags[0] === prefix && tags[2] === 'stop';
  };

  var OnParsePlayAnimationTag = function OnParsePlayAnimationTag(textPlayer, parser, config) {
    var prefix = GetValue$1O(config, 'sprite', 'sprite');

    if (!prefix) {
      return;
    }

    parser.on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [sprite.name.play=key], or [sprite.name.play=key0,key1,...]


      var tags = tag.split('.');
      var name;

      if (IsPlayAnimationTag(tags, prefix)) {
        name = tags[1];
      } else {
        return;
      }

      var keys = Array.prototype.slice.call(arguments, 1);
      AppendCommand$3.call(textPlayer, 'sprite.play', // name
      PlayAnimation, // callback
      [name, keys], // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [sprite.name.stop]


      var tags = tag.split('.');
      var name;

      if (IsStopAnimationTag(tags, prefix)) {
        name = tags[1];
      } else {
        return;
      }

      AppendCommand$3.call(textPlayer, 'sprite.stop', // name
      StopAnimation, // callback
      name, // params
      textPlayer // scope
      );
      parser.skipEvent();
    }).on('-', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [/sprite.name.play]


      var tags = tag.split('.');
      var name;

      if (IsPlayAnimationTag(tags, prefix)) {
        name = tags[1];
      } else {
        return;
      }

      AppendCommand$3.call(textPlayer, 'sprite.stop', // name
      StopAnimation, // callback
      name, // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var PlayAnimation = function PlayAnimation(params) {
    var name = params[0];
    var keys = params[1];
    var key = keys.shift(); // this: textPlayer

    this.spriteManager.playAnimation(name, key);

    if (keys.length > 0) {
      this.spriteManager.chainAnimation(name, keys);
    }
  };

  var StopAnimation = function StopAnimation(name) {
    // this: textPlayer
    this.spriteManager.stopAnimation(name);
  };

  var GetValue$1N = Phaser.Utils.Objects.GetValue;

  var IsChainAnimationTag = function IsChainAnimationTag(tags, prefix) {
    // sprite.name.chain 
    return tags.length === 3 && tags[0] === prefix && tags[2] === 'chain';
  };

  var OnParseChainAnimationTag = function OnParseChainAnimationTag(textPlayer, parser, config) {
    var prefix = GetValue$1N(config, 'sprite', 'sprite');

    if (!prefix) {
      return;
    }

    parser.on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [sprite.name.chain=key]


      var tags = tag.split('.');
      var name;

      if (IsChainAnimationTag(tags, prefix)) {
        name = tags[1];
      } else {
        return;
      }

      var keys = Array.prototype.slice.call(arguments, 1);
      AppendCommand$3.call(textPlayer, 'sprite.chain', // name
      ChainAnimation, // callback
      [name, keys], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var ChainAnimation = function ChainAnimation(params) {
    var _this$spriteManager;

    // this: textPlayer
    (_this$spriteManager = this.spriteManager).chainAnimation.apply(_this$spriteManager, _toConsumableArray(params));
  };

  var GetValue$1M = Phaser.Utils.Objects.GetValue;

  var IsPauseAnimationTag = function IsPauseAnimationTag(tags, prefix) {
    // sprite.name.pause 
    return tags.length === 3 && tags[0] === prefix && tags[2] === 'pause';
  };

  var OnParsePauseAnimationTag = function OnParsePauseAnimationTag(textPlayer, parser, config) {
    var prefix = GetValue$1M(config, 'sprite', 'sprite');

    if (!prefix) {
      return;
    }

    parser.on('+', function (tag) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [sprite.name.chain=key]


      var tags = tag.split('.');
      var name;

      if (IsPauseAnimationTag(tags, prefix)) {
        name = tags[1];
      } else {
        return;
      }

      AppendCommand$3.call(textPlayer, 'sprite.pause', // name
      PauseAnimation, // callback
      name, // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var PauseAnimation = function PauseAnimation(name) {
    // this: textPlayer
    this.spriteManager.pauseAnimation(name);
  };

  var GetValue$1L = Phaser.Utils.Objects.GetValue;

  var IsSetPropertyTag = function IsSetPropertyTag(tags, prefix) {
    // sprite.name.prop
    return tags.length === 3 && tags[0] === prefix;
  };

  var OnParseSetSpritePropertyTag = function OnParseSetSpritePropertyTag(textPlayer, parser, config) {
    var prefix = GetValue$1L(config, 'sprite', 'sprite');

    if (!prefix) {
      return;
    }

    parser.on("+", function (tag, value) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [sprite.name.prop=value]


      var tags = tag.split('.');
      var name, property;

      if (IsSetPropertyTag(tags, prefix)) {
        name = tags[1];
        property = tags[2];
      } else {
        return;
      }

      AppendCommand$3.call(textPlayer, 'sprite.set', // name
      SetProperty, // callback
      [name, property, value], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var SetProperty = function SetProperty(params) {
    var _this$spriteManager;

    // this: textPlayer
    (_this$spriteManager = this.spriteManager).setProperty.apply(_this$spriteManager, _toConsumableArray(params));
  };

  var GetValue$1K = Phaser.Utils.Objects.GetValue;
  var EaseMode = {
    to: true,
    yoyo: true
  };

  var IsEasePropertyTag = function IsEasePropertyTag(tags, prefix) {
    // sprite.name.prop.to, or sprite.name.prop.yoyo
    return tags.length === 4 && tags[0] === prefix && EaseMode[tags[3]];
  };

  var OnParseEaseSpritePropertyTag = function OnParseEaseSpritePropertyTag(textPlayer, parser, config) {
    var prefix = GetValue$1K(config, 'sprite', 'sprite');

    if (!prefix) {
      return;
    }

    parser.on("+", function (tag, value, duration, ease) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      } // [sprite.name.prop.to=value,duration,ease]


      var tags = tag.split('.');
      var name, property, isYoyo;

      if (IsEasePropertyTag(tags, prefix)) {
        name = tags[1];
        property = tags[2];
        isYoyo = tags[3] === 'yoyo';
      } else {
        return;
      }

      AppendCommand$3.call(textPlayer, 'sprite.ease', // name
      EaseProperty, // callback
      [name, property, value, duration, ease, isYoyo], // params
      textPlayer // scope
      );
      parser.skipEvent();
    });
  };

  var EaseProperty = function EaseProperty(params) {
    var _this$spriteManager;

    // this: textPlayer
    (_this$spriteManager = this.spriteManager).easeProperty.apply(_this$spriteManager, _toConsumableArray(params));
  };

  var OnParseCustomTag = function OnParseCustomTag(textPlayer, parser, config) {
    parser.on('start', function () {
      textPlayer.emit('parser.start', parser);
    }).on('+', function (tagName) {
      if (parser.skipEventFlag) {
        // Has been processed before
        return;
      }

      var startTag = "+".concat(tagName);

      for (var _len = arguments.length, value = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        value[_key - 1] = arguments[_key];
      }

      textPlayer.emit.apply(textPlayer, ["parser.".concat(startTag), parser].concat(value));
      AppendCommand(textPlayer, startTag, value);
    }).on('-', function (tagName) {
      if (parser.skipEventFlag) {
        return;
      }

      var endTag = "-".concat(tagName);
      textPlayer.emit("parser.".concat(endTag), parser);
      AppendCommand(textPlayer, endTag);
    }).on('complete', function () {
      textPlayer.emit('parser.complete', parser);
    });
  };

  var FireEvent$1 = function FireEvent(param, tagName) {
    var eventName = "tag.".concat(tagName); // this: textPlayer

    if (param == null) {
      this.emit(eventName);
    } else {
      this.emit.apply(this, [eventName].concat(_toConsumableArray(param)));
    }
  };

  var AppendCommand = function AppendCommand(textPlayer, name, param) {
    AppendCommand$3.call(textPlayer, name, // name
    FireEvent$1, // callback
    param, // params
    textPlayer // scope
    );
  };

  var GetValue$1J = Phaser.Utils.Objects.GetValue;

  var OnParseBoldTag = function OnParseBoldTag(textPlayer, parser, config) {
    var tagName = GetValue$1J(config, 'tags.r', 'r');
    parser.on("+".concat(tagName), function () {
      AppendText$1.call(textPlayer, '\n');
      parser.skipEvent();
    }).on("-".concat(tagName), function () {
      parser.skipEvent();
    });
  };

  var OnParseContent = function OnParseContent(textPlayer, parser, config) {
    parser.on('content', function (content) {
      AppendText$1.call(textPlayer, content);
    });
  };

  var ParseCallbacks = [OnParseColorTag, OnParseStrokeColorTag, OnParseBoldTag$1, OnParseItalicTag, OnParseFontSizeTag, OnParseOffsetYTag, OnParseShadowColorTag, OnParseAlignTag, OnParseImageTag, OnParseTypingSpeedTag, OnParsePlaySoundEffectTag, OnParseFadeInSoundEffectTag, OnParseFadeOutSoundEffectTag, OnParseSetSoundEffectVolumeTag, OnParsePlayBackgroundMusicTag, OnParseFadeInBackgroundMusicTag, OnParseFadeOutBackgroundMusicTag, OnParseCrossFadeBackgroundMusicTag, OnParsePauseBackgroundMusicTag, OnParseFadeInCameraTag, OnParseFadeOutCameraTag, OnParseShakeCameraTag, OnParseFlashCameraTag, OnParseZoomCameraTag, OnParseRotateCameraTag, OnParseScrollCameraTag, OnParseWaitTag, OnParseAddSpriteTag, OnParseRemoveAllSpritesTag, OnParseSetTextureTag, OnParsePlayAnimationTag, OnParseChainAnimationTag, OnParsePauseAnimationTag, OnParseSetSpritePropertyTag, OnParseEaseSpritePropertyTag, // Add ParseSetSpritePropertyTag later    
  OnParseCustomTag, OnParseBoldTag, OnParseContent];

  var AddParseCallbacks = function AddParseCallbacks(textPlayer, parser, config) {
    for (var i = 0, cnt = ParseCallbacks.length; i < cnt; i++) {
      ParseCallbacks[i](textPlayer, parser, config);
    }
  };

  /*
  Skip line
  - An empty line, only has space
  - A comment line, start with commentLineStart ('//')
  */
  var PreProcess = function PreProcess(parser, source) {
    var comentLineStart = parser.commentLineStart;
    var lines = source.split('\n');

    for (var i = 0, cnt = lines.length; i < cnt; i++) {
      var line = lines[i];

      if (line === '') ; else if (line.trim().length === 0) {
        // An empty line, only has space
        lines[i] = '';
      } else if (comentLineStart && line.startsWith(comentLineStart)) {
        // A comment line, start with commentLineStart ('//')
        lines[i] = '';
      }
    } // Use [r] to put \n


    return lines.join('');
  };

  var GetValue$1I = Phaser.Utils.Objects.GetValue;

  var Parser = /*#__PURE__*/function (_BracketParser) {
    _inherits(Parser, _BracketParser);

    var _super = _createSuper(Parser);

    function Parser(textPlayer, config) {
      var _this;

      _classCallCheck(this, Parser);

      if (config === undefined) {
        config = {};
      }

      if (!config.hasOwnProperty('delimiters')) {
        config.delimiters = '[]';
      }

      _this = _super.call(this, config);
      AddParseCallbacks(textPlayer, _assertThisInitialized(_this), config);

      _this.setCommentLineStartSymbol(GetValue$1I(config, 'comment', '//'));

      return _this;
    }

    _createClass(Parser, [{
      key: "setCommentLineStartSymbol",
      value: function setCommentLineStartSymbol(symbol) {
        this.commentLineStart = symbol;
        return this;
      }
    }, {
      key: "start",
      value: function start(source) {
        _get(_getPrototypeOf(Parser.prototype), "start", this).call(this, PreProcess(this, source));

        return this;
      }
    }]);

    return Parser;
  }(BracketParser);

  var WaitEvent = function WaitEvent(eventEmitter, eventName) {
    return new Promise(function (resolve, reject) {
      eventEmitter.once(eventName, function () {
        resolve();
      });
    });
  };

  var WaitComplete = function WaitComplete(eventEmitter) {
    return WaitEvent(eventEmitter, 'complete');
  };

  var Start = function Start(children) {
    this.children = children;
    this.index = 0;
    this.isPageTyping = true;

    if (this.onTypeStart) {
      this.onTypeStart(children);
    }

    this.typing();
    return WaitComplete(this); // Promise
  };

  var TypingDelayTimerType = 'delay';
  var TypingAnimationTimerType = 'anim';

  var Typing = function Typing(offsetTime) {
    if (offsetTime === undefined) {
      offsetTime = 0;
    }

    var delay = 0;
    this.inTypingProcessLoop = true;

    while (this.inTypingProcessLoop) {
      var child = this.getNextChild();

      if (!child) {
        if (this.timeline.isRunning) {
          // Wait until last animationConfig is end
          this.timeline.once('complete', function () {
            this.isPageTyping = false;
            this.emit('complete');
          }, this);
        } else {
          this.isPageTyping = false;
          this.emit('complete');
        }

        break; // Leave this typing loop
      }

      if (CanRender(child)) {
        // Typing this char
        var animationConfig = this.animationConfig;

        if (animationConfig.duration > 0) {
          var animationTimer = this.timeline.addTimer({
            name: TypingAnimationTimerType,
            target: child,
            duration: animationConfig.duration,
            yoyo: animationConfig.yoyo,
            onStart: animationConfig.onStart,
            onProgress: animationConfig.onProgress,
            onComplete: animationConfig.onComplete
          });

          if (this.skipTypingAnimation) {
            animationTimer.seek(1);
          }
        } else {
          // No animationConfig, only invoke onStart callback
          if (animationConfig.onStart) {
            animationConfig.onStart(child, 0);
          }
        }

        this.textPlayer.emit('typing', child);
        delay += this.speed + offsetTime;
        offsetTime = 0;
        var isLastChild = this.index === this.children.length; // this.index: Point to next child

        if (delay > 0 && !isLastChild) {
          // Process next character later
          this.typingTimer = this.timeline.addTimer({
            name: TypingDelayTimerType,
            target: this,
            duration: delay,
            onComplete: function onComplete(target, t, timer) {
              target.typingTimer = undefined;
              Typing.call(target, timer.remainder);
            }
          });
          break; // Leave this typing loop                
        } // Process next child

      } else if (IsCommand(child)) {
        child.exec(); // Process next child
      }
    }

    this.inTypingProcessLoop = false;
  };

  var Pause$1 = function Pause() {
    // Pause typing timer and animation progresses
    this.timeline.pause();
    return this;
  };

  var Resume$1 = function Resume() {
    // Resume typing timer and animation progresses
    this.timeline.resume();
    return this;
  };

  var PauseTyping = function PauseTyping() {
    // Already in typingPaused state
    if (this.isTypingPaused) {
      return this;
    }

    if (this.typingTimer) {
      // Pause when typing timer is counting
      this.typingTimer.pause();
      this.isTypingPaused = true;
    } else if (this.inTypingProcessLoop) {
      // Pause in loop of typing(), by tag
      this.inTypingProcessLoop = false;
      this.isTypingPaused = true;
    }

    return this;
  };

  var ResumeTyping = function ResumeTyping(offsetTime) {
    // Already not in typingPaused state
    if (!this.isTypingPaused) {
      return this;
    }

    if (offsetTime === undefined) {
      offsetTime = 0;
    }

    if (this.typingTimer) {
      // Pause when typing timer is paused
      this.isTypingPaused = false;
      this.typingTimer.resume();
      this.typingTimer.remainder += offsetTime;
    } else if (this.isTypingPaused) {
      // Resume paused by tag
      this.isTypingPaused = false;
      this.typing(offsetTime);
    }

    return this;
  };

  // Internal events
  var RemoveWaitEvents = '_remove.wait';
  var StopPlayEvent = '_remove.play';
  var ClearEvents$1 = [RemoveWaitEvents, StopPlayEvent];

  var GetWrapCallback = function GetWrapCallback(textPlayer, callback, args, scope, removeFrom) {
    return function () {
      textPlayer.emit(RemoveWaitEvents, removeFrom); // Remove all wait events

      callback.apply(scope, args);
    };
  };

  var WaitCallback = function WaitCallback(textPlayer, postfixName, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'custom');
    var eventName = postfixName ? "wait.".concat(postfixName) : 'wait';
    textPlayer.emit(eventName, wrapCallback);
  };

  var DelayCall = function DelayCall(textPlayer, delay, callback, args, scope) {
    return textPlayer.typeWriter.timeline.delayCall(delay, callback, args, scope);
  };

  var WaitTime = function WaitTime(textPlayer, time, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'time');
    var timer; // Remove all wait events

    textPlayer.once(RemoveWaitEvents, function () {
      if (timer) {
        timer.remove();
        timer = undefined;
      }
    });
    timer = DelayCall(textPlayer, time, wrapCallback);
    textPlayer.emit('wait.time', time);
  };

  var WaitClick = function WaitClick(textPlayer, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'click');
    var clickEE = textPlayer.clickEE; // Remove all wait events

    textPlayer.once(RemoveWaitEvents, function () {
      clickEE.off('pointerdown', wrapCallback, textPlayer);
    });
    clickEE.once('pointerdown', wrapCallback, textPlayer);
    textPlayer.emit('wait.click');
  };

  var WaitMusic = function WaitMusic(textPlayer, music, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'music');

    if (music) {
      // Remove all wait events
      textPlayer.once(RemoveWaitEvents, function () {
        music.off('complete', wrapCallback, textPlayer);
      });
      music.once('complete', wrapCallback, textPlayer);
    }

    textPlayer.emit('wait.music', music);

    if (!music) {
      wrapCallback();
    }
  };

  var IsWaitCameraEffect = function IsWaitCameraEffect(name) {
    switch (name) {
      case 'camera.fadein':
      case 'camera.fadeout':
      case 'camera.flash':
      case 'camera.shake':
      case 'camera.zoom':
      case 'camera.rotate':
      case 'camera.scroll':
        return true;

      default:
        return false;
    }
  };

  var WaitCameraEffect = function WaitCameraEffect(textPlayer, effectName, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, "camera.".concat(effectName));
    var camera = textPlayer.camera;
    var effect, completeEventName;

    switch (effectName) {
      case 'camera.fadein':
        effect = camera.fadeEffect;
        completeEventName = 'camerafadeincomplete';
        break;

      case 'camera.fadeout':
        effect = camera.fadeEffect;
        completeEventName = 'camerafadeoutcomplete';
        break;

      case 'camera.flash':
        effect = camera.flashEffect;
        completeEventName = 'cameraflashcomplete';
        break;

      case 'camera.shake':
        effect = camera.shakeEffect;
        completeEventName = 'camerashakecomplete';
        break;

      case 'camera.zoom':
        effect = camera.zoomEffect;
        completeEventName = 'camerazoomcomplete';
        break;

      case 'camera.rotate':
        effect = camera.rotateToEffect;
        completeEventName = 'camerarotatecomplete';
        break;

      case 'camera.scroll':
        effect = camera.panEffect;
        completeEventName = 'camerapancomplete';
        break;
    }

    if (!effect.isRunning) {
      textPlayer.emit('wait.camera', effectName);
      wrapCallback();
    } else {
      // Remove all wait events
      textPlayer.once(RemoveWaitEvents, function (removeFrom) {
        camera.off(completeEventName, wrapCallback, textPlayer);
      });
      camera.once(completeEventName, wrapCallback, textPlayer);
      textPlayer.emit('wait.camera', effectName);
    }
  };

  var WaitKey = function WaitKey(textPlayer, keyName, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope, 'keydown');
    var eventName = "keydown-".concat(keyName.toUpperCase());
    var keyboard = textPlayer.scene.input.keyboard; // Remove all wait events

    textPlayer.once(RemoveWaitEvents, function () {
      keyboard.off(eventName, wrapCallback, textPlayer);
    });
    keyboard.once(eventName, wrapCallback, textPlayer);
    textPlayer.emit('wait.keydown', keyName);
  };

  var IsWaitSprite = function IsWaitSprite(name) {
    // sprite, sprite.name, sprite.name.prop
    var names = name.split('.');
    return names[0] === 'sprite' && names.length <= 3;
  };

  var WaitSprite = function WaitSprite(textPlayer, tag, callback, args, scope) {
    var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope);
    var tags = tag.split('.');
    var spriteManager = textPlayer.spriteManager;

    switch (tags.length) {
      case 1:
        // sprite: wait all sprites has beeen destroyed
        if (spriteManager.isEmpty) {
          textPlayer.emit('wait.sprite');
          wrapCallback();
        } else {
          // Remove all wait events
          textPlayer.once(RemoveWaitEvents, function (removeFrom) {
            spriteManager.off('empty', wrapCallback, textPlayer);
          });
          spriteManager.once('empty', wrapCallback, textPlayer);
          textPlayer.emit('wait.sprite');
        }

        break;

      case 2:
        // sprite.name: wait sprite.name has been destroyed
        var name = tags[1];

        if (spriteManager.has(name)) {
          var spriteData = textPlayer.spriteManager.get(name);
          var sprite = spriteData.sprite; // Remove all wait events

          textPlayer.once(RemoveWaitEvents, function () {
            sprite.off('destroy', wrapCallback, textPlayer);
          });
          sprite.once('destroy', wrapCallback, textPlayer);
          textPlayer.emit('wait.sprite', name);
        } else {
          textPlayer.emit('wait.sprite', name);
          wrapCallback();
        }

        break;

      case 3:
        // sprite.name.prop: wait ease sprite.name.prop has been completed
        var name = tags[1];
        var prop = tags[2];
        var task = textPlayer.spriteManager.getTweenTask(name, prop);

        if (task) {
          // Remove all wait events
          textPlayer.once(RemoveWaitEvents, function () {
            task.off('complete', wrapCallback, textPlayer);
          });
          task.once('complete', wrapCallback, textPlayer);
          textPlayer.emit('wait.sprite', name, prop);
        } else {
          textPlayer.emit('wait.sprite', name, prop);
          wrapCallback();
        }

        break;
    }
  };

  var KeyCodes = Phaser.Input.Keyboard.KeyCodes;

  var WaitMultiple = function WaitMultiple(textPlayer, names, callback, args, scope) {
    if (typeof names === 'string' && names.length > 1 && names.indexOf('|') !== -1) {
      names = names.split('|');
    } else {
      names = [names];
    }

    for (var i = 0, cnt = names.length; i < cnt; i++) {
      var name = names[i];

      if (name == null || name === 'wait') {
        // Wait event
        WaitCallback(textPlayer, undefined, callback, args, scope);
      } else if (typeof name === 'number' || !isNaN(name)) {
        // A number, or a number string
        WaitTime(textPlayer, parseFloat(name), callback, args, scope);
      } else if (name === 'click') {
        // 'click'
        WaitClick(textPlayer, callback, args, scope);
      } else if (name === 'se') {
        var music = textPlayer.soundManager.getLastSoundEffect();
        WaitMusic(textPlayer, music, callback, args, scope);
      } else if (name === 'bgm') {
        var music = textPlayer.soundManager.getBackgroundMusic();
        WaitMusic(textPlayer, music, callback, args, scope);
      } else if (KeyCodes.hasOwnProperty(name.toUpperCase())) {
        WaitKey(textPlayer, name, callback, args, scope);
      } else if (IsWaitCameraEffect(name)) {
        WaitCameraEffect(textPlayer, name, callback, args, scope);
      } else if (IsWaitSprite(name)) {
        WaitSprite(textPlayer, name, callback, args, scope);
      } else {
        WaitCallback(textPlayer, name, callback, args, scope);
      }
    }
  };

  var Wait = function Wait(name) {
    // Already in typingPaused state, or ignore any wait
    if (this.ignoreWait) {
      return this;
    }

    this.pauseTyping();
    WaitMultiple(this.textPlayer, name, this.resumeTyping, [], this);
    return this;
  };

  var SetTimeScale$1 = function SetTimeScale(value) {
    this.timeline.setTimeScale(value);
    return this;
  };

  var SetIgnoreWait$1 = function SetIgnoreWait(value) {
    if (value === undefined) {
      value = true;
    }

    this.ignoreWait = value;
    return this;
  };

  var SetSkipTypingAnimation = function SetSkipTypingAnimation(value) {
    if (value === undefined) {
      value = true;
    }

    this.skipTypingAnimation = value;

    if (value) {
      // Skip current playing typing-animation
      var timers = this.timeline.getTimers(TypingAnimationTimerType);

      for (var i = 0, cnt = timers.length; i < cnt; i++) {
        timers[i].seek(1);
      }
    }

    return this;
  };

  var SetSkipSoundEffect = function SetSkipSoundEffect(value) {
    if (value === undefined) {
      value = true;
    }

    this.skipSoundEffect = value;

    if (value) {
      var soundManager = this.textPlayer._soundManager;

      if (soundManager) {
        soundManager.fadeOutAllSoundEffects(100, true);
      }
    }

    return this;
  };

  var SkipCurrentTypingDelay = function SkipCurrentTypingDelay() {
    if (this.typingTimer) {
      this.typingTimer.seek(1);
    }

    return this;
  };

  var Methods$6 = {
    start: Start,
    typing: Typing,
    pause: Pause$1,
    resume: Resume$1,
    pauseTyping: PauseTyping,
    resumeTyping: ResumeTyping,
    wait: Wait,
    setTimeScale: SetTimeScale$1,
    setIgnoreWait: SetIgnoreWait$1,
    setSkipTypingAnimation: SetSkipTypingAnimation,
    setSkipSoundEffect: SetSkipSoundEffect,
    skipCurrentTypingDelay: SkipCurrentTypingDelay
  };

  var SceneClass = Phaser.Scene;

  var IsSceneObject = function IsSceneObject(object) {
    return object instanceof SceneClass;
  };

  var GetSceneObject = function GetSceneObject(object) {
    if (object == null || _typeof(object) !== 'object') {
      return null;
    } else if (IsSceneObject(object)) {
      // object = scene
      return object;
    } else if (object.scene && IsSceneObject(object.scene)) {
      // object = game object
      return object.scene;
    } else if (object.parent && object.parent.scene && IsSceneObject(object.parent.scene)) {
      // parent = bob object
      return object.parent.scene;
    }
  };

  var GetValue$1H = Phaser.Utils.Objects.GetValue;

  var ComponentBase = /*#__PURE__*/function () {
    function ComponentBase(parent, config) {
      _classCallCheck(this, ComponentBase);

      this.parent = parent; // gameObject or scene

      this.scene = GetSceneObject(parent);
      this.isShutdown = false; // Event emitter, default is private event emitter

      this.setEventEmitter(GetValue$1H(config, 'eventEmitter', true)); // Register callback of parent destroy event, also see `shutdown` method

      if (this.parent && this.parent === this.scene) {
        // parent is a scene
        this.scene.sys.events.once('shutdown', this.onSceneDestroy, this);
      } else if (this.parent && this.parent.once) {
        // bob object does not have event emitter
        this.parent.once('destroy', this.onParentDestroy, this);
      }
    }

    _createClass(ComponentBase, [{
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        } // parent might not be shutdown yet


        if (this.parent && this.parent === this.scene) {
          // parent is a scene
          this.scene.sys.events.off('shutdown', this.onSceneDestroy, this);
        } else if (this.parent && this.parent.once) {
          // bob object does not have event emitter
          this.parent.off('destroy', this.onParentDestroy, this);
        }

        this.destroyEventEmitter();
        this.parent = undefined;
        this.scene = undefined;
        this.isShutdown = true;
      }
    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        this.shutdown(fromScene);
      }
    }, {
      key: "onSceneDestroy",
      value: function onSceneDestroy() {
        this.destroy(true);
      }
    }, {
      key: "onParentDestroy",
      value: function onParentDestroy(parent, fromScene) {
        this.destroy(fromScene);
      }
    }]);

    return ComponentBase;
  }();
  Object.assign(ComponentBase.prototype, EventEmitterMethods);

  var GetValue$1G = Phaser.Utils.Objects.GetValue;

  var TickTask = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TickTask, _ComponentBase);

    var _super = _createSuper(TickTask);

    function TickTask(parent, config) {
      var _this;

      _classCallCheck(this, TickTask);

      _this = _super.call(this, parent, config);
      _this._isRunning = false;
      _this.isPaused = false;
      _this.tickingState = false;

      _this.setTickingMode(GetValue$1G(config, 'tickingMode', 1)); // boot() later


      return _this;
    } // override


    _createClass(TickTask, [{
      key: "boot",
      value: function boot() {
        if (this.tickingMode === 2 && !this.tickingState) {
          this.startTicking();
        }
      } // override

    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        this.stop();

        if (this.tickingState) {
          this.stopTicking();
        }

        _get(_getPrototypeOf(TickTask.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "setTickingMode",
      value: function setTickingMode(mode) {
        if (typeof mode === 'string') {
          mode = TICKINGMODE[mode];
        }

        this.tickingMode = mode;
      } // override

    }, {
      key: "startTicking",
      value: function startTicking() {
        this.tickingState = true;
      } // override

    }, {
      key: "stopTicking",
      value: function stopTicking() {
        this.tickingState = false;
      }
    }, {
      key: "isRunning",
      get: function get() {
        return this._isRunning;
      },
      set: function set(value) {
        if (this._isRunning === value) {
          return;
        }

        this._isRunning = value;

        if (this.tickingMode === 1 && value != this.tickingState) {
          if (value) {
            this.startTicking();
          } else {
            this.stopTicking();
          }
        }
      }
    }, {
      key: "start",
      value: function start() {
        this.isPaused = false;
        this.isRunning = true;
        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        // Only can ba paused in running state
        if (this.isRunning) {
          this.isPaused = true;
          this.isRunning = false;
        }

        return this;
      }
    }, {
      key: "resume",
      value: function resume() {
        // Only can ba resumed in paused state (paused from running state)
        if (this.isPaused) {
          this.isRunning = true;
        }

        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.isPaused = false;
        this.isRunning = false;
        return this;
      }
    }, {
      key: "complete",
      value: function complete() {
        this.isPaused = false;
        this.isRunning = false;
        this.emit('complete', this.parent, this);
      }
    }]);

    return TickTask;
  }(ComponentBase);

  var TICKINGMODE = {
    'no': 0,
    'lazy': 1,
    'always': 2
  };

  var GetValue$1F = Phaser.Utils.Objects.GetValue;

  var BaseClock = /*#__PURE__*/function (_TickTask) {
    _inherits(BaseClock, _TickTask);

    var _super = _createSuper(BaseClock);

    function BaseClock(parent, config) {
      var _this;

      _classCallCheck(this, BaseClock);

      _this = _super.call(this, parent, config);

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(BaseClock, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.isRunning = GetValue$1F(o, 'isRunning', false);
        this.timeScale = GetValue$1F(o, 'timeScale', 1);
        this.now = GetValue$1F(o, 'now', 0);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          isRunning: this.isRunning,
          timeScale: this.timeScale,
          now: this.now,
          tickingMode: this.tickingMode
        };
      } // Override
      // startTicking() { }
      // Override
      // stopTicking() {}

    }, {
      key: "start",
      value: function start(startAt) {
        if (startAt === undefined) {
          startAt = 0;
        }

        this.delta = 0;
        this.now = startAt;

        _get(_getPrototypeOf(BaseClock.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "seek",
      value: function seek(time) {
        this.now = time;
        return this;
      }
    }, {
      key: "setTimeScale",
      value: function setTimeScale(value) {
        this.timeScale = value;
        return this;
      }
    }, {
      key: "tick",
      value: function tick(delta) {
        delta *= this.timeScale;
        this.now += delta;
        this.delta = delta;
        this.emit('update', this.now, this.delta);
        return this;
      }
    }]);

    return BaseClock;
  }(TickTask);

  var Clock = /*#__PURE__*/function (_BaseClock) {
    _inherits(Clock, _BaseClock);

    var _super = _createSuper(Clock);

    function Clock() {
      _classCallCheck(this, Clock);

      return _super.apply(this, arguments);
    }

    _createClass(Clock, [{
      key: "startTicking",
      value: function startTicking() {
        _get(_getPrototypeOf(Clock.prototype), "startTicking", this).call(this);

        this.scene.sys.events.on('update', this.update, this);
      }
    }, {
      key: "stopTicking",
      value: function stopTicking() {
        _get(_getPrototypeOf(Clock.prototype), "stopTicking", this).call(this);

        if (this.scene) {
          // Scene might be destoryed
          this.scene.sys.events.off('update', this.update, this);
        }
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (!this.isRunning || this.timeScale === 0) {
          return this;
        }

        this.tick(delta);
        return this;
      }
    }]);

    return Clock;
  }(BaseClock);

  var Yoyo = function Yoyo(t, threshold) {
    if (threshold === undefined) {
      threshold = 0.5;
    }

    if (t <= threshold) {
      t = t / threshold;
    } else {
      t = 1 - (t - threshold) / (1 - threshold);
    }

    return t;
  };

  var Clamp$b = Phaser.Math.Clamp;

  var Timer$2 = /*#__PURE__*/function () {
    function Timer(timeline, config) {
      _classCallCheck(this, Timer);

      this.setTimeline(timeline).reset(config);
    }

    _createClass(Timer, [{
      key: "setTimeline",
      value: function setTimeline(timeline) {
        this.timeline = timeline;
        return this;
      }
    }, {
      key: "setName",
      value: function setName(name) {
        this.name = name;
        return this;
      }
    }, {
      key: "setCallbacks",
      value: function setCallbacks(target, onStart, onProgress, onComplete) {
        this.target = target;
        this.onStart = onStart;
        this.onProgress = onProgress;
        this.onComplete = onComplete;
        return this;
      }
    }, {
      key: "setDuration",
      value: function setDuration(duration, yoyo) {
        if (yoyo === undefined) {
          yoyo = false;
        }

        this.duration = duration;
        this.remainder = duration;
        this.t = 0;
        this.yoyo = yoyo;
        return this;
      }
    }, {
      key: "setPaused",
      value: function setPaused(state) {
        this.isPaused = state;
        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        this.isPaused = true;
        return this;
      }
    }, {
      key: "resume",
      value: function resume() {
        this.isPaused = false;
        return this;
      }
    }, {
      key: "setRemoved",
      value: function setRemoved(state) {
        this.removed = state;
        return this;
      }
    }, {
      key: "remove",
      value: function remove() {
        this.removed = true;
        return this;
      }
    }, {
      key: "seek",
      value: function seek(t) {
        this.remainder = this.duration * (1 - t);
        return this;
      }
    }, {
      key: "reset",
      value: function reset(o) {
        this.setName(o.name).setDuration(o.duration, o.yoyo).setCallbacks(o.target, o.onStart, o.onProgress, o.onComplete).setPaused(false).setRemoved(false);
        return this;
      }
    }, {
      key: "onFree",
      value: function onFree() {
        this.setTimeline().setCallbacks();
      }
    }, {
      key: "getProgress",
      value: function getProgress() {
        var value = 1 - this.remainder / this.duration;
        value = Clamp$b(value, 0, 1);

        if (this.yoyo) {
          value = Yoyo(value);
        }

        return value;
      }
    }, {
      key: "setProgress",
      value: function setProgress(value) {
        value = Clamp$b(value, 0, 1);
        this.remainder = this.duration * (1 - value);
      }
    }, {
      key: "runCallback",
      value: function runCallback(callback) {
        if (!callback) {
          return;
        }

        callback(this.target, this.t, this);
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (this.removed) {
          return true;
        } else if (this.isPaused) {
          return false;
        }

        this.remainder -= delta;
        this.t = this.getProgress();
        this.runCallback(this.onProgress);
        var isCompleted = this.remainder <= 0;

        if (isCompleted) {
          this.runCallback(this.onComplete);
        }

        return isCompleted;
      }
    }]);

    return Timer;
  }();

  var TimerPool$1 = /*#__PURE__*/function (_Pool) {
    _inherits(TimerPool, _Pool);

    var _super = _createSuper(TimerPool);

    function TimerPool() {
      _classCallCheck(this, TimerPool);

      return _super.apply(this, arguments);
    }

    _createClass(TimerPool, [{
      key: "allocate",
      value: function allocate() {
        return this.pop();
      }
    }, {
      key: "free",
      value: function free(timer) {
        timer.onFree();
        this.push(timer);
      }
    }, {
      key: "freeMultiple",
      value: function freeMultiple(arr) {
        for (var i = 0, cnt = arr.length; i < cnt; i++) {
          this.free(arr[i]);
        }

        return this;
      }
    }]);

    return TimerPool;
  }(Stack);

  var GetValue$1E = Phaser.Utils.Objects.GetValue;
  var TimerPool = new TimerPool$1();

  var Timeline = /*#__PURE__*/function (_Clock) {
    _inherits(Timeline, _Clock);

    var _super = _createSuper(Timeline);

    function Timeline(parent, config) {
      var _this;

      _classCallCheck(this, Timeline);

      _this = _super.call(this, parent, config);
      _this.addedTimers = [];
      _this.timers = [];
      _this.timerPool = GetValue$1E(config, 'pool', TimerPool);
      return _this;
    }

    _createClass(Timeline, [{
      key: "shutdown",
      value: function shutdown() {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        this.timerPool.freeMultiple(this.addedTimers).freeMultiple(this.timers);
        this.timerPool = undefined;
        this.addedTimers = undefined;
        this.timers = undefined;

        _get(_getPrototypeOf(Timeline.prototype), "shutdown", this).call(this);
      }
    }, {
      key: "addTimer",
      value: function addTimer(config) {
        var timer = this.timerPool.allocate();

        if (!timer) {
          timer = new Timer$2(this, config);
        } else {
          timer.setTimeline(this).reset(config);
        }

        this.addedTimers.push(timer);
        timer.runCallback(timer.onStart);

        if (!this.isRunning) {
          this.start();
        }

        return timer;
      }
    }, {
      key: "delayCall",
      value: function delayCall(delay, callback, args, scope) {
        var timer = this.addTimer({
          duration: delay,
          onComplete: function onComplete(target, t, timer) {
            if (args === undefined) {
              args = [];
            }

            args.push(timer);
            callback.apply(scope, args);
          }
        });
        return timer;
      }
    }, {
      key: "getTimers",
      value: function getTimers(name) {
        var timers = [];
        var timerQueues = [this.addedTimers, this.timers];

        for (var ti = 0, tcnt = timerQueues.length; ti < tcnt; ti++) {
          var timerQueue = timerQueues[ti];

          for (var i = 0, cnt = timerQueue.length; i < cnt; i++) {
            var timer = timerQueue[i];

            if (timer.name === name) {
              timers.push(timer);
            }
          }
        }

        return timers;
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        var _this$timers;

        _get(_getPrototypeOf(Timeline.prototype), "update", this).call(this, time, delta);

        (_this$timers = this.timers).push.apply(_this$timers, _toConsumableArray(this.addedTimers));

        this.addedTimers.length = 0;
        var pendingTimers = [];

        for (var i = 0, cnt = this.timers.length; i < cnt; i++) {
          var timer = this.timers[i];
          var isStopped = timer.update(this.now, this.delta);

          if (isStopped) {
            this.timerPool.free(timer); // Free timer
          } else {
            pendingTimers.push(timer); // Add to timer queue
          }
        }

        this.timers = pendingTimers;

        if (this.timers.length === 0 && this.addedTimers.length === 0) {
          this.complete(); // Emit 'complete' event
        }
      }
    }]);

    return Timeline;
  }(Clock);

  var GetValue$1D = Phaser.Utils.Objects.GetValue;

  var TypeWriter = /*#__PURE__*/function () {
    function TypeWriter(textPlayer, config) {
      _classCallCheck(this, TypeWriter);

      this.setEventEmitter();
      this.textPlayer = textPlayer;
      this.isPageTyping = false;
      this.timeline = new Timeline(textPlayer);
      this.typingTimer = undefined; // Typing delay

      this.pauseTypingTimer = undefined; // Wait time

      this.inTypingProcessLoop = false; // Used in this.typing()

      this.isTypingPaused = false; // Used in this.wait(), this.pauseTyping(), this.resumeTyping()

      this.setIgnoreWait(false);
      this.setSkipTypingAnimation(false);
      this.setTypingStartCallback(GetValue$1D(config, 'onTypingStart', SetChildrenInvisible));
      this.setSpeed(GetValue$1D(config, 'speed', 250));
      this.setAnimationConfig(GetValue$1D(config, 'animation', undefined));
    }

    _createClass(TypeWriter, [{
      key: "destroy",
      value: function destroy() {
        this.destroyEventEmitter();
        this.textPlayer = undefined;
        this.timeline.destroy();
        this.timeline = undefined;
        this.typingTimer = undefined;
        this.pauseTypingTimer = undefined;
        this.onTypeStart = undefined;
        this.animationConfig = undefined;
      }
    }, {
      key: "setSpeed",
      value: function setSpeed(speed) {
        this.speed = speed;
        return this;
      }
    }, {
      key: "setTypingStartCallback",
      value: function setTypingStartCallback(callback) {
        this.onTypeStart = callback;
        return this;
      }
    }, {
      key: "setAnimationConfig",
      value: function setAnimationConfig(config) {
        if (config === undefined) {
          config = {};
        } else if (config === false) {
          config = {
            duration: 0
          };
        }

        if (!config.hasOwnProperty('duration')) {
          // Apply default duration
          config.duration = 1000;
        }

        if (!config.hasOwnProperty('onStart')) {
          // Apply default onStart callback
          config.onStart = SetChildVisible;
        }

        this.animationConfig = config;
        return this;
      }
    }, {
      key: "getNextChild",
      value: function getNextChild() {
        var child = this.children[this.index];
        this.index = Math.min(this.index + 1, this.children.length); // Point to next child

        return child;
      }
    }]);

    return TypeWriter;
  }();

  var SetChildVisible = function SetChildVisible(child) {
    if (child.setVisible) {
      child.setVisible();
    }
  };

  var SetChildrenInvisible = function SetChildrenInvisible(children) {
    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];

      if (child.setVisible) {
        child.setVisible(false);
      }
    }
  };

  Object.assign(TypeWriter.prototype, EventEmitterMethods, Methods$6);

  var SceneUpdateTickTask = /*#__PURE__*/function (_TickTask) {
    _inherits(SceneUpdateTickTask, _TickTask);

    var _super = _createSuper(SceneUpdateTickTask);

    function SceneUpdateTickTask() {
      _classCallCheck(this, SceneUpdateTickTask);

      return _super.apply(this, arguments);
    }

    _createClass(SceneUpdateTickTask, [{
      key: "startTicking",
      value: function startTicking() {
        _get(_getPrototypeOf(SceneUpdateTickTask.prototype), "startTicking", this).call(this);

        this.scene.sys.events.on('update', this.update, this);
      }
    }, {
      key: "stopTicking",
      value: function stopTicking() {
        _get(_getPrototypeOf(SceneUpdateTickTask.prototype), "stopTicking", this).call(this);

        if (this.scene) {
          // Scene might be destoryed
          this.scene.sys.events.off('update', this.update, this);
        }
      } // update(time, delta) {
      //     
      // }

    }]);

    return SceneUpdateTickTask;
  }(TickTask);

  var GetValue$1C = Phaser.Utils.Objects.GetValue;
  var Clamp$a = Phaser.Math.Clamp;

  var Timer$1 = /*#__PURE__*/function () {
    function Timer(config) {
      _classCallCheck(this, Timer);

      this.resetFromJSON(config);
    }

    _createClass(Timer, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.state = GetValue$1C(o, 'state', IDLE$8);
        this.timeScale = GetValue$1C(o, 'timeScale', 1);
        this.delay = GetValue$1C(o, 'delay', 0);
        this.repeat = GetValue$1C(o, 'repeat', 0);
        this.repeatCounter = GetValue$1C(o, 'repeatCounter', 0);
        this.duration = GetValue$1C(o, 'duration', 0);
        this.nowTime = GetValue$1C(o, 'nowTime', 0);
        this.justRestart = GetValue$1C(o, 'justRestart', false);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          state: this.state,
          timeScale: this.timeScale,
          delay: this.delay,
          repeat: this.repeat,
          repeatCounter: this.repeatCounter,
          duration: this.duration,
          nowTime: this.nowTime,
          justRestart: this.justRestart
        };
      }
    }, {
      key: "destroy",
      value: function destroy() {}
    }, {
      key: "setTimeScale",
      value: function setTimeScale(timeScale) {
        this.timeScale = timeScale;
        return this;
      }
    }, {
      key: "setDelay",
      value: function setDelay(delay) {
        if (delay === undefined) {
          delay = 0;
        }

        this.delay = delay;
        return this;
      }
    }, {
      key: "setDuration",
      value: function setDuration(duration) {
        this.duration = duration;
        return this;
      }
    }, {
      key: "setRepeat",
      value: function setRepeat(repeat) {
        this.repeat = repeat;
        return this;
      }
    }, {
      key: "setRepeatInfinity",
      value: function setRepeatInfinity() {
        this.repeat = -1;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        this.nowTime = this.delay > 0 ? -this.delay : 0;
        this.state = this.nowTime >= 0 ? COUNTDOWN : DELAY;
        this.repeatCounter = 0;
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.state = IDLE$8;
        return this;
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (this.state === IDLE$8 || this.state === DONE || delta === 0 || this.timeScale === 0) {
          return;
        }

        this.nowTime += delta * this.timeScale;
        this.state = this.nowTime >= 0 ? COUNTDOWN : DELAY;
        this.justRestart = false;

        if (this.nowTime >= this.duration) {
          if (this.repeat === -1 || this.repeatCounter < this.repeat) {
            this.repeatCounter++;
            this.justRestart = true;
            this.nowTime -= this.duration;
          } else {
            this.nowTime = this.duration;
            this.state = DONE;
          }
        }
      }
    }, {
      key: "t",
      get: function get() {
        var t;

        switch (this.state) {
          case IDLE$8:
          case DELAY:
            t = 0;
            break;

          case COUNTDOWN:
            t = this.nowTime / this.duration;
            break;

          case DONE:
            t = 1;
            break;
        }

        return Clamp$a(t, 0, 1);
      },
      set: function set(value) {
        value = Clamp$a(value, -1, 1);

        if (value < 0) {
          this.state = DELAY;
          this.nowTime = -this.delay * value;
        } else {
          this.state = COUNTDOWN;
          this.nowTime = this.duration * value;

          if (value === 1 && this.repeat !== 0) {
            this.repeatCounter++;
          }
        }
      }
    }, {
      key: "setT",
      value: function setT(t) {
        this.t = t;
        return this;
      }
    }, {
      key: "isIdle",
      get: function get() {
        return this.state === IDLE$8;
      }
    }, {
      key: "isDelay",
      get: function get() {
        return this.state === DELAY;
      }
    }, {
      key: "isCountDown",
      get: function get() {
        return this.state === COUNTDOWN;
      }
    }, {
      key: "isRunning",
      get: function get() {
        return this.state === DELAY || this.state === COUNTDOWN;
      }
    }, {
      key: "isDone",
      get: function get() {
        return this.state === DONE;
      }
    }, {
      key: "isOddIteration",
      get: function get() {
        return (this.repeatCounter & 1) === 1;
      }
    }, {
      key: "isEvenIteration",
      get: function get() {
        return (this.repeatCounter & 1) === 0;
      }
    }]);

    return Timer;
  }();

  var IDLE$8 = 0;
  var DELAY = 1;
  var COUNTDOWN = 2;
  var DONE = -1;

  var TimerTickTask = /*#__PURE__*/function (_TickTask) {
    _inherits(TimerTickTask, _TickTask);

    var _super = _createSuper(TimerTickTask);

    function TimerTickTask(parent, config) {
      var _this;

      _classCallCheck(this, TimerTickTask);

      _this = _super.call(this, parent, config);
      _this.timer = new Timer$1(); // boot() later 

      return _this;
    } // override


    _createClass(TimerTickTask, [{
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        _get(_getPrototypeOf(TimerTickTask.prototype), "shutdown", this).call(this, fromScene);

        this.timer.destroy();
        this.timer = undefined;
      }
    }, {
      key: "start",
      value: function start() {
        this.timer.start();

        _get(_getPrototypeOf(TimerTickTask.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.timer.stop();

        _get(_getPrototypeOf(TimerTickTask.prototype), "stop", this).call(this);

        return this;
      }
    }, {
      key: "complete",
      value: function complete() {
        this.timer.stop();

        _get(_getPrototypeOf(TimerTickTask.prototype), "complete", this).call(this);

        return this;
      }
    }]);

    return TimerTickTask;
  }(SceneUpdateTickTask);

  var GetValue$1B = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue$5 = Phaser.Utils.Objects.GetAdvancedValue;
  var GetEaseFunction = Phaser.Tweens.Builders.GetEaseFunction;

  var EaseValueTaskBase = /*#__PURE__*/function (_TickTask) {
    _inherits(EaseValueTaskBase, _TickTask);

    var _super = _createSuper(EaseValueTaskBase);

    function EaseValueTaskBase() {
      _classCallCheck(this, EaseValueTaskBase);

      return _super.apply(this, arguments);
    }

    _createClass(EaseValueTaskBase, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.timer.resetFromJSON(GetValue$1B(o, 'timer'));
        this.setEnable(GetValue$1B(o, 'enable', true));
        this.setTarget(GetValue$1B(o, 'target', this.parent));
        this.setDelay(GetAdvancedValue$5(o, 'delay', 0));
        this.setDuration(GetAdvancedValue$5(o, 'duration', 1000));
        this.setEase(GetValue$1B(o, 'ease', 'Linear'));
        this.setRepeat(GetValue$1B(o, 'repeat', 0));
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e == undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "setTarget",
      value: function setTarget(target) {
        if (target === undefined) {
          target = this.parent;
        }

        this.target = target;
        return this;
      }
    }, {
      key: "setDelay",
      value: function setDelay(time) {
        this.delay = time;
        return this;
      }
    }, {
      key: "setDuration",
      value: function setDuration(time) {
        this.duration = time;
        return this;
      }
    }, {
      key: "setEase",
      value: function setEase(ease) {
        if (ease === undefined) {
          ease = 'Linear';
        }

        this.ease = ease;
        this.easeFn = GetEaseFunction(ease);
        return this;
      }
    }, {
      key: "setRepeat",
      value: function setRepeat(repeat) {
        this.repeat = repeat;
        return this;
      } // Override

    }, {
      key: "start",
      value: function start() {
        // Ignore start if timer is running, i.e. in DELAY, o RUN state
        if (this.timer.isRunning) {
          return this;
        }

        _get(_getPrototypeOf(EaseValueTaskBase.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "restart",
      value: function restart() {
        this.timer.stop();
        this.start.apply(this, arguments);
        return this;
      }
    }, {
      key: "stop",
      value: function stop(toEnd) {
        if (toEnd === undefined) {
          toEnd = false;
        }

        _get(_getPrototypeOf(EaseValueTaskBase.prototype), "stop", this).call(this);

        if (toEnd) {
          this.timer.setT(1);
          this.updateGameObject(this.target, this.timer);
          this.complete();
        }

        return this;
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (!this.isRunning || !this.enable || !this.parent.active) {
          return this;
        }

        var target = this.target,
            timer = this.timer;
        timer.update(time, delta); // isDelay, isCountDown, isDone

        if (!timer.isDelay) {
          this.updateGameObject(target, timer);
        }

        this.emit('update', target, this);

        if (timer.isDone) {
          this.complete();
        }

        return this;
      } // Override

    }, {
      key: "updateGameObject",
      value: function updateGameObject(target, timer) {}
    }]);

    return EaseValueTaskBase;
  }(TimerTickTask);

  var GetValue$1A = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue$4 = Phaser.Utils.Objects.GetAdvancedValue;
  var Linear$b = Phaser.Math.Linear;

  var Fade$2 = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(Fade, _EaseValueTaskBase);

    var _super = _createSuper(Fade);

    function Fade(scene, sound, config) {
      var _this;

      _classCallCheck(this, Fade);

      sound.scene = scene;
      sound.active = true;
      _this = _super.call(this, sound, config); // this.parent = sound
      // this.timer

      _this.volume = {};

      _this.resetFromJSON(config);

      return _this;
    }

    _createClass(Fade, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Fade.prototype), "resetFromJSON", this).call(this, o);

        this.setMode(GetValue$1A(o, 'mode', 0));
        this.setEnable(GetValue$1A(o, 'enable', true));
        this.setVolumeRange(GetAdvancedValue$4(o, 'volume.start', this.parent.volume), GetAdvancedValue$4(o, 'volume.end', 0));
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = MODE$4[m];
        }

        this.mode = m;
        return this;
      }
    }, {
      key: "setVolumeRange",
      value: function setVolumeRange(start, end) {
        this.volume.start = start;
        this.volume.end = end;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        if (this.timer.isRunning) {
          return this;
        }

        this.parent.setVolume(this.volume.start);
        this.timer.setDelay(this.delay).setDuration(this.duration);

        _get(_getPrototypeOf(Fade.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(sound, timer) {
        sound.volume = Linear$b(this.volume.start, this.volume.end, timer.t);
      }
    }, {
      key: "complete",
      value: function complete() {
        _get(_getPrototypeOf(Fade.prototype), "complete", this).call(this);

        switch (this.mode) {
          case 1:
            this.parent.stop();
            break;

          case 2:
            this.parent.destroy();
            break;
        }

        return this;
      }
    }]);

    return Fade;
  }(EaseValueTaskBase);

  var MODE$4 = {
    stop: 1,
    destroy: 2
  };

  var FadeIn$1 = function FadeIn(scene, sound, duration, endVolume, startVolume) {
    if (endVolume === undefined) {
      endVolume = 1;
    }

    if (startVolume === undefined) {
      startVolume = 0;
    }

    var config = {
      mode: 0,
      volume: {
        start: startVolume,
        end: endVolume
      },
      duration: duration
    }; // create sound instance by key

    if (typeof sound === 'string') {
      sound = scene.sys.sound.add(sound);
    }

    var fade;

    if (sound.hasOwnProperty('_fade')) {
      fade = sound._fade;
      fade.stop().resetFromJSON(config);
    } else {
      fade = new Fade$2(scene, sound, config);
      sound._fade = fade;
    }

    fade.start();

    if (!sound.isPlaying) {
      sound.setVolume(startVolume).play();
    }

    return sound;
  };

  var FadeOut = function FadeOut(scene, sound, duration, destroy) {
    if (destroy === undefined) {
      destroy = true;
    }

    var config = {
      mode: destroy ? 2 : 1,
      // 1: stop, 2: destroy
      volume: {
        start: sound.volume,
        end: 0
      },
      duration: duration
    };
    var fade;

    if (sound.hasOwnProperty('_fade')) {
      fade = sound._fade;
      fade.stop().resetFromJSON(config);
    } else {
      fade = new Fade$2(scene, sound, config);
      sound._fade = fade;
    }

    fade.start();

    if (!sound.isPlaying) {
      sound.play();
    }

    return sound;
  };

  var GetValue$1z = Phaser.Utils.Objects.GetValue;
  var RemoveItem$9 = Phaser.Utils.Array.Remove;

  var SoundManager = /*#__PURE__*/function () {
    function SoundManager(scene, config) {
      _classCallCheck(this, SoundManager);

      this.scene = scene; // Sound effect will be destroyed when completed

      this.soundEffects = []; // Background music will be (fade out)destroyed when play next one.

      this.backgroundMusic = undefined;
      this.setBackgroundMusicLoopValue(GetValue$1z(config, 'bgm.loop', true));
      this.setBackgroundMusicFadeTime(GetValue$1z(config, 'bgm.fade', 500));
      var initialBackgroundMusic = GetValue$1z(config, 'bgm.initial', undefined);

      if (initialBackgroundMusic) {
        this.setCurrentBackgroundMusic(initialBackgroundMusic);
      }
    }

    _createClass(SoundManager, [{
      key: "destroy",
      value: function destroy(fromScene) {
        if (this.soundEffects.length && !fromScene) {
          for (var i = this.soundEffects.length - 1; i >= 0; i--) {
            this.soundEffects[i].destroy();
          }
        }

        this.soundEffects.length = 0;

        if (this.backgroundMusic && !fromScene) {
          this.backgroundMusic.destroy();
        }

        this.backgroundMusic = undefined;
        this.scene = undefined;
      }
    }, {
      key: "setBackgroundMusicLoopValue",
      value: function setBackgroundMusicLoopValue(value) {
        this.backgroundMusicLoopValue = value;
        return this;
      }
    }, {
      key: "setBackgroundMusicFadeTime",
      value: function setBackgroundMusicFadeTime(time) {
        this.backgroundMusicFadeTime = time;
        return this;
      }
    }, {
      key: "getSoundEffects",
      value: function getSoundEffects() {
        return this.soundEffects;
      }
    }, {
      key: "getLastSoundEffect",
      value: function getLastSoundEffect() {
        return this.soundEffects[this.soundEffects.length - 1];
      }
    }, {
      key: "getBackgroundMusic",
      value: function getBackgroundMusic() {
        return this.backgroundMusic;
      }
    }, {
      key: "playSoundEffect",
      value: function playSoundEffect(key) {
        var soundEffect = this.scene.sys.sound.add(key);
        this.soundEffects.push(soundEffect);
        soundEffect.once('complete', function () {
          soundEffect.destroy(); // SoundManager has been destroyed

          if (!this.scene) {
            return;
          }

          RemoveItem$9(this.soundEffects, soundEffect);
        }, this).once('destroy', function () {
          // SoundManager has been destroyed
          if (!this.scene) {
            return;
          }

          RemoveItem$9(this.soundEffects, soundEffect);
        }, this).play();
        return this;
      }
    }, {
      key: "setSoundEffectVolume",
      value: function setSoundEffectVolume(volume) {
        var soundEffect = this.getLastSoundEffect();

        if (soundEffect) {
          soundEffect.setVolume(volume);
        }

        return this;
      }
    }, {
      key: "fadeInSoundEffect",
      value: function fadeInSoundEffect(time) {
        var soundEffect = this.getLastSoundEffect();

        if (soundEffect) {
          FadeIn$1(this.scene, soundEffect, time);
        }

        return this;
      }
    }, {
      key: "fadeOutSoundEffect",
      value: function fadeOutSoundEffect(time, isStopped) {
        var soundEffect = this.getLastSoundEffect();

        if (soundEffect) {
          FadeOut(this.scene, soundEffect, time, isStopped);
        }

        return this;
      }
    }, {
      key: "fadeOutAllSoundEffects",
      value: function fadeOutAllSoundEffects(time, isStopped) {
        for (var i = this.soundEffects.length - 1; i >= 0; i--) {
          FadeOut(this.scene, this.soundEffects[i], time, isStopped);
        }

        return this;
      }
    }, {
      key: "setCurrentBackgroundMusic",
      value: function setCurrentBackgroundMusic(music) {
        this.backgroundMusic = music;

        if (music) {
          music.setLoop(this.backgroundMusicLoopValue);
          music.once('complete', function () {
            this.backgroundMusic.destroy();
            this.backgroundMusic = undefined;
          }, this).once('destroy', function () {
            this.backgroundMusic = undefined;
          }, this);

          if (!music.isPlaying) {
            music.play();
          }
        }
      }
    }, {
      key: "playBackgroundMusic",
      value: function playBackgroundMusic(key) {
        // Don't re-play the same background music
        if (this.backgroundMusic && this.backgroundMusic.key === key) {
          return this;
        }

        this.stopBackgroundMusic(); // Stop previous background music

        this.setCurrentBackgroundMusic(this.scene.sys.sound.add(key));

        if (this.backgroundMusicFadeTime > 0) {
          this.fadeInBackgroundMusic(this.backgroundMusicFadeTime);
        }

        return this;
      }
    }, {
      key: "pauseBackgroundMusic",
      value: function pauseBackgroundMusic() {
        if (this.backgroundMusic) {
          this.backgroundMusic.pause();
        }

        return this;
      }
    }, {
      key: "resumeBackgroundMusic",
      value: function resumeBackgroundMusic() {
        if (this.backgroundMusic) {
          this.backgroundMusic.resume();
        }

        return this;
      }
    }, {
      key: "stopBackgroundMusic",
      value: function stopBackgroundMusic() {
        if (this.backgroundMusic) {
          if (this.backgroundMusicFadeTime > 0) {
            this.fadeOutBackgroundMusic(this.backgroundMusicFadeTime, true);
          } else {
            this.backgroundMusic.stop();
            this.backgroundMusic.destroy();
            this.backgroundMusic = undefined;
          }
        }

        return this;
      }
    }, {
      key: "fadeInBackgroundMusic",
      value: function fadeInBackgroundMusic(time) {
        if (this.backgroundMusic) {
          FadeIn$1(this.scene, this.backgroundMusic, time);
        }

        return this;
      }
    }, {
      key: "fadeOutBackgroundMusic",
      value: function fadeOutBackgroundMusic(time, isStopped) {
        if (this.backgroundMusic) {
          FadeOut(this.scene, this.backgroundMusic, time, isStopped);
        }

        return this;
      }
    }, {
      key: "crossFadeBackgroundMusic",
      value: function crossFadeBackgroundMusic(key, time) {
        var backgroundMusicFadeTimeSave = this.backgroundMusicFadeTime;
        this.backgroundMusicFadeTime = 0;
        this.fadeOutBackgroundMusic(time, true).playBackgroundMusic(key).fadeInBackgroundMusic(time);
        this.backgroundMusicFadeTime = backgroundMusicFadeTimeSave;
        return this;
      }
    }]);

    return SoundManager;
  }();

  var SpriteData = /*#__PURE__*/function () {
    function SpriteData(spriteManager, sprite, name) {
      _classCallCheck(this, SpriteData);

      this.spriteManager = spriteManager;
      this.sprite = sprite.setName(name);
      this.tweens = {};
      this.name = name;
    }

    _createClass(SpriteData, [{
      key: "scene",
      get: function get() {
        return this.spriteManager.scene;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.freeSprite().freeTweens();
        this.spriteManager = undefined;
      }
    }, {
      key: "freeSprite",
      value: function freeSprite() {
        this.sprite.destroy();
        this.sprite = undefined;
        return this;
      }
    }, {
      key: "freeTweens",
      value: function freeTweens() {
        var tweenTasks = this.tweens;

        for (var propName in tweenTasks) {
          tweenTasks[propName].remove();
          delete tweenTasks[propName];
        }

        return this;
      }
    }, {
      key: "setProperty",
      value: function setProperty(property, value) {
        this.sprite[property] = value;
        return this;
      }
    }, {
      key: "easeProperty",
      value: function easeProperty(property, value, duration, ease, isYoyo, _onComplete) {
        var tweenTasks = this.tweens;

        if (tweenTasks.hasOwnProperty(property)) {
          tweenTasks[property].remove();
        }

        var config = {
          targets: this.sprite,
          duration: duration,
          ease: ease,
          yoyo: isYoyo,
          onComplete: function onComplete() {
            tweenTasks[property].remove();
            delete tweenTasks[property];

            if (_onComplete) {
              _onComplete();
            }
          },
          onCompleteScope: this
        };
        config[property] = value;
        tweenTasks[property] = this.scene.tweens.add(config);
        return this;
      }
    }, {
      key: "setTexture",
      value: function setTexture(textureKey, frameKey) {
        this.sprite.setTexture(textureKey, frameKey);
        return this;
      }
    }, {
      key: "playAnimation",
      value: function playAnimation(key) {
        this.sprite.play(key);
        return this;
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation() {
        this.sprite.stop();
        return this;
      }
    }, {
      key: "chainAnimation",
      value: function chainAnimation(keys) {
        this.sprite.chain(keys);
        return this;
      }
    }, {
      key: "pauseAnimation",
      value: function pauseAnimation() {
        this.sprite.anims.pause();
        return this;
      }
    }]);

    return SpriteData;
  }();

  var GetR = function GetR(colorInt) {
    return colorInt >> 16 & 0xff;
  };

  var GetG = function GetG(colorInt) {
    return colorInt >> 8 & 0xff;
  };

  var GetB = function GetB(colorInt) {
    return colorInt & 0xff;
  };

  var MaskR = ~(0xff << 16) & 0xffffff;
  var MaskG = ~(0xff << 8) & 0xffffff;
  var MaskB = ~0xff & 0xffffff;

  var SetR = function SetR(colorInt, r) {
    return (r & 0xff) << 16 | colorInt & MaskR;
  };

  var SetG = function SetG(colorInt, g) {
    return (g & 0xff) << 8 | colorInt & MaskG;
  };

  var SetB = function SetB(colorInt, b) {
    return b & 0xff | colorInt & MaskB;
  };

  var SetRGB = function SetRGB(colorInt, r, g, b) {
    return (r & 0xff) << 16 | (g & 0xff) << 8 | b & 0xff;
  };

  var AddTintRGBProperties = function AddTintRGBProperties(gameObject, tintRGB) {
    // Don't attach properties again
    if (gameObject.hasOwnProperty('tintR')) {
      return gameObject;
    }

    if (tintRGB === undefined) {
      tintRGB = 0xffffff;
    }

    var tintR = GetR(tintRGB);
    var tintG = GetG(tintRGB);
    var tintB = GetB(tintRGB); // Override tint property

    Object.defineProperty(gameObject, 'tint', {
      get: function get() {
        return tintRGB;
      },
      set: function set(value) {
        value = Math.floor(value) & 0xffffff;
        gameObject.setTint(value);

        if (tintRGB !== value) {
          tintRGB = value;
          tintR = GetR(tintRGB);
          tintG = GetG(tintRGB);
          tintB = GetB(tintRGB); // gameObject.emit('_tintchange', value, tintR, tintG, tintB);
        }
      }
    });
    Object.defineProperty(gameObject, 'tintR', {
      get: function get() {
        return tintR;
      },
      set: function set(value) {
        value = Math.floor(value) & 0xff;

        if (tintR !== value) {
          tintR = value;
          gameObject.tint = SetR(tintRGB, value);
        }
      }
    });
    Object.defineProperty(gameObject, 'tintG', {
      get: function get() {
        return tintG;
      },
      set: function set(value) {
        value = Math.floor(value) & 0xff;

        if (tintG !== value) {
          tintG = value;
          gameObject.tint = SetG(tintRGB, value);
        }
      }
    });
    Object.defineProperty(gameObject, 'tintB', {
      get: function get() {
        return tintB;
      },
      set: function set(value) {
        value = Math.floor(value) & 0xff;

        if (tintB !== value) {
          tintB = value;
          gameObject.tint = SetB(tintRGB, value);
        }
      }
    });
    Object.defineProperty(gameObject, 'tintGray', {
      get: function get() {
        return Math.floor((tintR + tintG + tintB) / 3);
      },
      set: function set(value) {
        value = Math.floor(value) & 0xff;

        if (tintR !== value || tintG !== value || tintB !== value) {
          tintR = value;
          tintG = value;
          tintB = value;
          gameObject.tint = SetRGB(tintRGB, value, value, value);
        }
      }
    });
    gameObject.tint = tintRGB;
    return gameObject;
  };

  var IsEmpty = function IsEmpty(source) {
    for (var k in source) {
      return false;
    }

    return true;
  };

  var GetValue$1y = Phaser.Utils.Objects.GetValue;
  var RemoveItem$8 = Phaser.Utils.Array.Remove;

  var SpriteManager = /*#__PURE__*/function () {
    function SpriteManager(scene, config) {
      _classCallCheck(this, SpriteManager);

      this.scene = scene;
      this.setEventEmitter(GetValue$1y(config, 'eventEmitter', undefined));
      this.setCreateCallback(GetValue$1y(config, 'createCallback', 'sprite'));
      this.setSpriteFadeTime(GetValue$1y(config, 'fade', 500));
      this.sprites = {};
      this.removedSprites = [];
    }

    _createClass(SpriteManager, [{
      key: "destroy",
      value: function destroy(fromScene) {
        this.clear(!fromScene);
        this.createCallback = undefined;
        this.scene = undefined;
      }
    }, {
      key: "setCreateCallback",
      value: function setCreateCallback(callback) {
        if (callback === 'sprite') {
          this.createCallback = function (scene, textureKey, frameName) {
            return scene.add.sprite(0, 0, textureKey, frameName);
          };
        } else if (callback === 'image') {
          this.createCallback = function (scene, textureKey, frameName) {
            return scene.add.image(0, 0, textureKey, frameName);
          };
        } else {
          this.createCallback = callback;
        }

        return this;
      }
    }, {
      key: "setSpriteFadeTime",
      value: function setSpriteFadeTime(time) {
        this.fadeTime = time;
        return this;
      }
    }, {
      key: "has",
      value: function has(name) {
        return this.sprites.hasOwnProperty(name);
      }
    }, {
      key: "get",
      value: function get(name) {
        return this.sprites[name];
      }
    }, {
      key: "getTweenTask",
      value: function getTweenTask(name, prop) {
        if (this.has(name)) {
          var tweenTasks = this.get(name).tweens;

          if (tweenTasks.hasOwnProperty(prop)) {
            return tweenTasks[prop];
          }
        }

        return null;
      }
    }, {
      key: "isEmpty",
      get: function get() {
        return IsEmpty(this.sprites) && this.removedSprites.length === 0;
      }
    }, {
      key: "clear",
      value: function clear(destroyChild) {
        if (destroyChild === undefined) {
          destroyChild = true;
        }

        for (var name in this.sprites) {
          if (destroyChild) {
            this.sprites[name].destroy();
          }

          delete this.sprites[name];
        }

        this.removedSprites.length = 0;
        return this;
      }
    }, {
      key: "add",
      value: function add(name, textureKey, frameName) {
        this.remove(name);
        var sprite;

        if (arguments.length === 3) {
          sprite = this.createCallback(this.scene, textureKey, frameName);
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          sprite = this.createCallback.apply(this, [this.scene].concat(_toConsumableArray(args)));
        }

        if (this.fadeTime > 0) {
          AddTintRGBProperties(sprite);
        }

        sprite.once('destroy', function () {
          RemoveItem$8(this.removedSprites, sprite);

          if (this.isEmpty) {
            this.emit('empty');
          }
        }, this);
        var spriteData = new SpriteData(this, sprite, name);
        this.sprites[name] = spriteData;

        if (this.fadeTime > 0) {
          spriteData.setProperty('tintGray', 0).easeProperty('tintGray', 255, this.fadeTime);
        }

        return this;
      }
    }, {
      key: "setProperty",
      value: function setProperty(name, property, value) {
        if (!this.has(name)) {
          return this;
        }

        this.get(name).setProperty(property, value);
        return this;
      }
    }, {
      key: "easeProperty",
      value: function easeProperty(name, property, value, duration, ease, isYoyo, onComplete) {
        if (!this.has(name)) {
          return this;
        }

        if (duration === undefined) {
          duration = 1000;
        }

        if (ease === undefined) {
          ease = 'Linear';
        }

        this.get(name).easeProperty(property, value, duration, ease, isYoyo, onComplete);
        return this;
      }
    }, {
      key: "remove",
      value: function remove(name) {
        if (!this.has(name)) {
          return this;
        }

        var spriteData = this.get(name);
        delete this.sprites[name];
        this.removedSprites.push(spriteData.sprite);

        if (this.fadeTime > 0) {
          spriteData.easeProperty('tintGray', // property
          0, // to value
          this.fadeTime, // duration
          'Linear', // ease 
          false, // yoyo
          function () {
            // onComplete
            spriteData.destroy();
          });
        } else {
          spriteData.destroy();
        }

        return this;
      }
    }, {
      key: "removeAll",
      value: function removeAll() {
        for (var name in this.sprites) {
          this.remove(name);
        }

        return this;
      }
    }, {
      key: "setTexture",
      value: function setTexture(name, textureKey, frameKey) {
        if (!this.has(name)) {
          return this;
        }

        this.get(name).setTexture(textureKey, frameKey);
        return this;
      }
    }, {
      key: "playAnimation",
      value: function playAnimation(name, key) {
        if (!this.has(name)) {
          this.add(name);
        }

        this.get(name).playAnimation(key);
        return this;
      }
    }, {
      key: "stopAnimation",
      value: function stopAnimation(name) {
        if (!this.has(name)) {
          return this;
        }

        this.get(name).stopAnimation();
        return this;
      }
    }, {
      key: "chainAnimation",
      value: function chainAnimation(name, keys) {
        if (!this.has(name)) {
          return this;
        }

        this.get(name).chainAnimation(keys);
        return this;
      }
    }, {
      key: "pauseAnimation",
      value: function pauseAnimation(name) {
        if (!this.has(name)) {
          return this;
        }

        this.get(name).pauseAnimation();
        return this;
      }
    }]);

    return SpriteManager;
  }();

  Object.assign(SpriteManager.prototype, EventEmitterMethods);

  var SetClickTarget = function SetClickTarget(target) {
    if (IsSceneObject(target)) {
      this.clickEE = target.input;
    } else {
      // Assume that target is a game object
      this.clickEE = target.setInteractive();
    }

    return this;
  };

  var SetTargetCamera = function SetTargetCamera(camera) {
    this.camera = camera;
    return this;
  };

  var SetNextPageInput = function SetNextPageInput(input) {
    var textPlayer = this;

    if (!input) {
      this.nextPageInput = null;
    } else if (typeof input === 'function') {
      this.nextPageInput = function (callback, args, scope) {
        var wrapCallback = GetWrapCallback(textPlayer, callback, args, scope);
        input.call(textPlayer, wrapCallback);
      };
    } else {
      this.nextPageInput = function (callback, args, scope) {
        WaitMultiple(textPlayer, input, callback, args, scope);
      };
    }
  };

  var AddImage = function AddImage(key, config) {
    this.imageManager.add(key, config);
    return this;
  };

  var Play = function Play(content) {
    if (this.isPlaying) {
      return this;
    }

    this.removeChildren();
    this.parser.start(content); // Parse bbcode-content

    this.isPlaying = true;
    this.once('complete', function () {
      this.isPlaying = false;
    }, this);
    this.lastWrapResult = undefined;
    this.typingNextPage();
    return this;
  };

  var PlayPromise = function PlayPromise(content) {
    var promise = WaitComplete(this);
    this.play(content);
    return promise;
  };

  var GetValue$1x = Phaser.Utils.Objects.GetValue;

  var TypingNextPage = function TypingNextPage() {
    if (!this.isPlaying || this.isPageTyping) {
      return this;
    }

    var wrapCallback = GetValue$1x(this.wrapConfig, 'callback', this.runWordWrap);

    if (typeof wrapCallback === 'string') {
      wrapCallback = this[wrapCallback];
    }

    var result = wrapCallback.call(this, this.lastWrapResult);
    this.lastWrapResult = result;
    this.emit('page.start');

    var OnTypingPageComplete = function OnTypingPageComplete() {
      this.emit(StopPlayEvent); // Clear registed StopPlayEvent

      if (result.isLastPage) {
        this.emit('complete');
      } else {
        this.emit('page.complete');

        if (this.nextPageInput) {
          this.nextPageInput(TypingNextPage, [], this);
        }
      }
    }; // Remove event when typing pages has been canceled


    this.once(StopPlayEvent, function () {
      this.typeWriter.off('complete', OnTypingPageComplete, this);
    });
    this.typeWriter.once('complete', OnTypingPageComplete, this).start(result.children);
  };

  var Pause = function Pause() {
    // Pause typing timer and animation progresses
    this.typeWriter.pause();
    return this;
  };

  var Resume = function Resume() {
    // Resume typing timer and animation progresses
    this.typeWriter.resume();
    return this;
  };

  var SetTimeScale = function SetTimeScale(value) {
    this.typeWriter.setTimeScale(value);
    return this;
  };

  var SetIgnoreWait = function SetIgnoreWait(value) {
    this.typeWriter.setIgnoreWait(value);
    return this;
  };

  var ShowPage = function ShowPage() {
    // Only can work after playing, and before processing last child
    if (!this.isPlaying || !this.isPageTyping) {
      return this;
    } // Save parameters


    var typingSpeedSave = this.typeWriter.speed;
    var ignoreWaitSave = this.typeWriter.ignoreWait;
    var skipTypingAnimationSave = this.typeWriter.skipTypingAnimation;
    var skipSoundEffectSave = this.typeWriter.skipSoundEffect;
    this.typeWriter.once('complete', function () {
      // Recover parameters
      this.typeWriter.setSpeed(typingSpeedSave).setIgnoreWait(ignoreWaitSave).setSkipTypingAnimation(skipTypingAnimationSave).setSkipSoundEffect(skipSoundEffectSave);
    }, this).setSpeed(0).skipCurrentTypingDelay().setIgnoreWait(true).setSkipTypingAnimation(true).setSkipSoundEffect(true);
    return this;
  };

  var Methods$5 = {
    setClickTarget: SetClickTarget,
    setTargetCamera: SetTargetCamera,
    setNextPageInput: SetNextPageInput,
    addImage: AddImage,
    play: Play,
    playPromise: PlayPromise,
    typingNextPage: TypingNextPage,
    pause: Pause,
    resume: Resume,
    setTimeScale: SetTimeScale,
    setIgnoreWait: SetIgnoreWait,
    showPage: ShowPage
  };

  var ClearEvents = function ClearEvents(textPlayer) {
    for (var i = 0, cnt = ClearEvents$1.length; i < cnt; i++) {
      textPlayer.emit(ClearEvents$1[i]);
    }
  };

  var IsPlainObject$r = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$1w = Phaser.Utils.Objects.GetValue;

  var TextPlayer = /*#__PURE__*/function (_DynamicText) {
    _inherits(TextPlayer, _DynamicText);

    var _super = _createSuper(TextPlayer);

    function TextPlayer(scene, x, y, fixedWidth, fixedHeight, config) {
      var _this;

      _classCallCheck(this, TextPlayer);

      if (IsPlainObject$r(x)) {
        config = x;
      } else if (IsPlainObject$r(fixedWidth)) {
        config = fixedWidth;
      }

      if (config === undefined) {
        config = {};
      } // Don't set text in DynamicText's constructor


      var content = config.text;
      delete config.text;
      _this = _super.call(this, scene, x, y, fixedWidth, fixedHeight, config);
      _this.type = 'rexTextPlayer';
      _this.parser = new Parser(_assertThisInitialized(_this), GetValue$1w(config, 'parser', undefined));
      _this.typeWriter = new TypeWriter(_assertThisInitialized(_this), GetValue$1w(config, 'typing', undefined));
      _this._imageManager = undefined;
      var imageData = GetValue$1w(config, 'images', undefined);

      if (imageData) {
        _this.addImage(imageData);
      }

      _this._soundManager = undefined;
      var soundManagerConfig = GetValue$1w(config, 'sounds', undefined);

      if (soundManagerConfig) {
        _this._soundManager = new SoundManager(_this.scene, soundManagerConfig);
      }

      _this.setTargetCamera(GetValue$1w(config, 'camera', _this.scene.sys.cameras.main));

      _this._spriteManager = undefined;
      var spriteManagerConfig = GetValue$1w(config, 'sprites', undefined);

      if (spriteManagerConfig) {
        _this._spriteManager = new SpriteManager(_this.scene, spriteManagerConfig);
      }

      _this.setClickTarget(GetValue$1w(config, 'clickTarget', _assertThisInitialized(_this))); // this.clickEE


      _this.setNextPageInput(GetValue$1w(config, 'nextPageInput', null));

      _this.isPlaying = false;

      if (content) {
        _this.play(content);
      }

      return _this;
    }

    _createClass(TextPlayer, [{
      key: "imageManager",
      get: function get() {
        if (this._imageManager === undefined) {
          this._imageManager = new ImageManager(this.scene);
        }

        return this._imageManager;
      }
    }, {
      key: "soundManager",
      get: function get() {
        if (this._soundManager === undefined) {
          this._soundManager = new SoundManager(this.scene);
        }

        return this._soundManager;
      }
    }, {
      key: "spriteManager",
      get: function get() {
        if (this._spriteManager === undefined) {
          this._spriteManager = new SpriteManager(this.scene);
        }

        return this._spriteManager;
      }
    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        ClearEvents(this);
        this.parser.destroy();
        this.parser = undefined;
        this.typeWriter.destroy(fromScene);
        this.typeWriter = undefined;

        if (this._imageManager) {
          this._imageManager.destroy(fromScene);
        }

        this._imageManager = undefined;

        if (this._soundManager) {
          this._soundManager.destroy(fromScene);
        }

        this._soundManager = undefined;
        this.camera = undefined;

        if (this._spriteManager) {
          this._spriteManager.destroy(fromScene);
        }

        this._spriteManager = undefined;
        this.clickEE = undefined;

        _get(_getPrototypeOf(TextPlayer.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "isPageTyping",
      get: function get() {
        return this.typeWriter.isPageTyping;
      }
    }]);

    return TextPlayer;
  }(DynamicText);

  Object.assign(TextPlayer.prototype, Methods$5);

  ObjectFactory.register('textPlayer', function (x, y, width, height, config) {
    var gameObject = new TextPlayer(this.scene, x, y, width, height, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.TextPlayer', TextPlayer);

  var DrawCircle = function DrawCircle(canvas, context, x, y, rx, ry, fillStyle, strokeStyle, lineWidth, startAngle, endAngle, anticlockwise) {
    if (startAngle === undefined) {
      startAngle = 0;
    }

    if (endAngle === undefined) {
      endAngle = 2 * Math.PI;
    }

    if (anticlockwise === undefined) {
      anticlockwise = false;
    }

    context.beginPath();
    context.ellipse(x, y, rx, ry, 0, startAngle, endAngle, anticlockwise);

    if (fillStyle != null) {
      context.fillStyle = fillStyle;
      context.fill();
    }

    if (strokeStyle != null) {
      context.strokeStyle = strokeStyle;
      context.lineWidth = lineWidth;
      context.stroke();
    }
  };

  var DrawText = function DrawText(canvas, context, x, y, text, font, fillStyle, strokeStyle, lineWidth, textAlign, textBaseline) {
    if (lineWidth === undefined && strokeStyle != null) {
      lineWidth = 2;
    }

    if (textAlign === undefined) {
      textAlign = 'start';
    }

    if (textBaseline === undefined) {
      textBaseline = 'alphabetic';
    }

    context.font = font;
    context.textAlign = textAlign;
    context.textBaseline = textBaseline;
    context.fillStyle = fillStyle;
    context.strokeStyle = strokeStyle;
    context.lineWidth = lineWidth;
    context.lineCap = 'round';
    context.lineJoin = 'round';

    if (strokeStyle != null && strokeStyle !== 'none' && lineWidth > 0) {
      context.strokeText(text, x, y);
    }

    if (fillStyle != null && fillStyle !== 'none') {
      context.fillText(text, x, y);
    }
  };

  var DrawContent = function DrawContent() {
    var x = this.radius;
    var lineWidth = this.thickness * this.radius;
    var barRadius = this.radius - lineWidth / 2;
    var centerRadius = this.radius - lineWidth;
    var canvas = this.canvas,
        context = this.context; // Draw track

    if (this.trackColor && lineWidth > 0) {
      context.save();
      DrawCircle(canvas, context, x, x, barRadius, barRadius, undefined, this.trackColor, lineWidth);
      context.restore();
    } // Draw bar


    if (this.barColor && barRadius > 0) {
      var anticlockwise, startAngle, endAngle;

      if (this.value === 1) {
        anticlockwise = false;
        startAngle = 0;
        endAngle = 2 * Math.PI;
      } else {
        anticlockwise = this.anticlockwise;
        startAngle = this.startAngle;
        var deltaAngle = 2 * Math.PI * (anticlockwise ? 1 - this.value : this.value);
        endAngle = deltaAngle + startAngle;
      }

      context.save();
      DrawCircle(canvas, context, x, x, barRadius, barRadius, undefined, this.barColor, lineWidth, startAngle, endAngle, anticlockwise);
      context.restore();
    } // Draw center


    if (this.centerColor && centerRadius > 0) {
      var fillStyle;

      if (this.centerColor2) {
        fillStyle = this.context.createRadialGradient(x, x, 0, x, x, centerRadius);
        fillStyle.addColorStop(0, this.centerColor);
        fillStyle.addColorStop(1, this.centerColor2);
      } else {
        fillStyle = this.centerColor;
      }

      context.save();
      DrawCircle(canvas, context, x, x, centerRadius, centerRadius, fillStyle);
      context.restore();
    } // Draw text


    if (this.textFormatCallback && (this.textColor || this.textStrokeColor)) {
      context.save();
      DrawText(canvas, context, x, x, this.getFormatText(), this.textFont, this.textColor, this.textStrokeColor, this.textStrokeThickness, 'center', // textAlign
      'middle' // textBaseline
      );
      context.restore();
    }
  };

  var GetValue$1v = Phaser.Utils.Objects.GetValue;
  var Linear$a = Phaser.Math.Linear;

  var EaseValueTask = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(EaseValueTask, _EaseValueTaskBase);

    var _super = _createSuper(EaseValueTask);

    function EaseValueTask(gameObject, config) {
      var _this;

      _classCallCheck(this, EaseValueTask);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;
      // this.timer

      _this.resetFromJSON();

      _this.boot();

      return _this;
    }

    _createClass(EaseValueTask, [{
      key: "start",
      value: function start(config) {
        if (this.timer.isRunning) {
          return this;
        }

        var target = this.target;
        this.propertyKey = GetValue$1v(config, 'key', 'value');
        var currentValue = target[this.propertyKey];
        this.fromValue = GetValue$1v(config, 'from', currentValue);
        this.toValue = GetValue$1v(config, 'to', currentValue);
        this.setEase(GetValue$1v(config, 'ease', this.ease));
        this.setDuration(GetValue$1v(config, 'duration', this.duration));
        this.timer.setDuration(this.duration);
        target[this.propertyKey] = this.fromValue;

        _get(_getPrototypeOf(EaseValueTask.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(target, timer) {
        var t = timer.t;
        t = this.easeFn(t);
        target[this.propertyKey] = Linear$a(this.fromValue, this.toValue, t);
      }
    }]);

    return EaseValueTask;
  }(EaseValueTaskBase);

  var Percent$6 = Phaser.Math.Percent;

  var SetEaseValuePropName = function SetEaseValuePropName(name) {
    this.easeValuePropName = name;
    return this;
  };

  var SetEaseValueDuration = function SetEaseValueDuration(duration) {
    this.easeValueDuration = duration;
    return this;
  };

  var SetEaseValueFunction = function SetEaseValueFunction(ease) {
    this.easeFunction = ease;
    return this;
  };

  var StopEaseValue = function StopEaseValue() {
    if (this.easeValueTask) {
      this.easeValueTask.stop();
    }

    return this;
  };

  var EaseValueTo = function EaseValueTo(value, min, max) {
    if (value === undefined || value === null) {
      return this;
    }

    if (min !== undefined) {
      value = Percent$6(value, min, max);
    }

    if (this.easeValueTask === undefined) {
      this.easeValueTask = new EaseValueTask(this, {
        eventEmitter: null
      });
    }

    this.easeValueTask.restart({
      key: this.easeValuePropName,
      to: value,
      duration: this.easeValueDuration,
      ease: this.easeFunction
    });
    return this;
  };

  var EaseValueMethods = {
    setEaseValuePropName: SetEaseValuePropName,
    setEaseValueDuration: SetEaseValueDuration,
    setEaseValueFunction: SetEaseValueFunction,
    stopEaseValue: StopEaseValue,
    easeValueTo: EaseValueTo
  };

  var GetValue$1u = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$q = Phaser.Utils.Objects.IsPlainObject;
  var Clamp$9 = Phaser.Math.Clamp;
  var Linear$9 = Phaser.Math.Linear;
  var Percent$5 = Phaser.Math.Percent;
  var DefaultStartAngle$1 = Phaser.Math.DegToRad(270);

  var CircularProgress$1 = /*#__PURE__*/function (_Canvas) {
    _inherits(CircularProgress, _Canvas);

    var _super = _createSuper(CircularProgress);

    function CircularProgress(scene, x, y, radius, barColor, value, config) {
      var _this;

      _classCallCheck(this, CircularProgress);

      if (IsPlainObject$q(x)) {
        config = x;
        x = GetValue$1u(config, 'x', 0);
        y = GetValue$1u(config, 'y', 0);
        radius = GetValue$1u(config, 'radius', 1);
        barColor = GetValue$1u(config, 'barColor', undefined);
        value = GetValue$1u(config, 'value', 0);
      }

      var width = radius * 2;
      _this = _super.call(this, scene, x, y, width, width);
      _this.type = 'rexCircularProgressCanvas';
      _this.eventEmitter = GetValue$1u(config, 'eventEmitter', _assertThisInitialized(_this));

      _this.setRadius(radius);

      _this.setTrackColor(GetValue$1u(config, 'trackColor', undefined));

      _this.setBarColor(barColor);

      _this.setCenterColor(GetValue$1u(config, 'centerColor', undefined));

      _this.setThickness(GetValue$1u(config, 'thickness', 0.2));

      _this.setStartAngle(GetValue$1u(config, 'startAngle', DefaultStartAngle$1));

      _this.setAnticlockwise(GetValue$1u(config, 'anticlockwise', false));

      _this.setTextColor(GetValue$1u(config, 'textColor', undefined));

      _this.setTextStrokeColor(GetValue$1u(config, 'textStrokeColor', undefined), GetValue$1u(config, 'textStrokeThickness', undefined));

      var textFont = GetValue$1u(config, 'textFont', undefined);

      if (textFont) {
        _this.setTextFont(textFont);
      } else {
        _this.setTextFont(GetValue$1u(config, 'textSize', '16px'), GetValue$1u(config, 'textFamily', 'Courier'), GetValue$1u(config, 'textStyle', ''));
      }

      _this.setTextFormatCallback(GetValue$1u(config, 'textFormatCallback', undefined), GetValue$1u(config, 'textFormatCallbackScope', undefined));

      var callback = GetValue$1u(config, 'valuechangeCallback', null);

      if (callback !== null) {
        var scope = GetValue$1u(config, 'valuechangeCallbackScope', undefined);

        _this.eventEmitter.on('valuechange', callback, scope);
      }

      _this.setEaseValuePropName('value').setEaseValueDuration(GetValue$1u(config, 'easeValue.duration', 0)).setEaseValueFunction(GetValue$1u(config, 'easeValue.ease', 'Linear'));

      _this.setValue(value);

      return _this;
    }

    _createClass(CircularProgress, [{
      key: "resize",
      value: function resize(width, height) {
        width = Math.floor(Math.min(width, height));

        if (width === this.width) {
          return this;
        }

        _get(_getPrototypeOf(CircularProgress.prototype), "resize", this).call(this, width, width);

        this.setRadius(width / 2);
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        value = Clamp$9(value, 0, 1);
        var oldValue = this._value;
        var valueChanged = oldValue != value;
        this.dirty = this.dirty || valueChanged;
        this._value = value;

        if (valueChanged) {
          this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
      }
    }, {
      key: "setValue",
      value: function setValue(value, min, max) {
        if (value === undefined || value === null) {
          return this;
        }

        if (min !== undefined) {
          value = Percent$5(value, min, max);
        }

        this.value = value;
        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, min, max) {
        if (min !== undefined) {
          inc = Percent$5(inc, min, max);
        }

        this.value += inc;
        return this;
      }
    }, {
      key: "getValue",
      value: function getValue(min, max) {
        var value = this.value;

        if (min !== undefined) {
          value = Linear$9(min, max, value);
        }

        return value;
      }
    }, {
      key: "radius",
      get: function get() {
        return this._radius;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._radius != value;
        this._radius = value;
        var width = value * 2;
        this.resize(width, width);
      }
    }, {
      key: "setRadius",
      value: function setRadius(radius) {
        this.radius = radius;
        return this;
      }
    }, {
      key: "trackColor",
      get: function get() {
        return this._trackColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._trackColor != value;
        this._trackColor = value;
      }
    }, {
      key: "setTrackColor",
      value: function setTrackColor(color) {
        this.trackColor = color;
        return this;
      }
    }, {
      key: "barColor",
      get: function get() {
        return this._barColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._barColor != value;
        this._barColor = value;
      }
    }, {
      key: "setBarColor",
      value: function setBarColor(color) {
        this.barColor = color;
        return this;
      }
    }, {
      key: "startAngle",
      get: function get() {
        return this._startAngle;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._startAngle != value;
        this._startAngle = value;
      }
    }, {
      key: "setStartAngle",
      value: function setStartAngle(angle) {
        this.startAngle = angle;
        return this;
      }
    }, {
      key: "anticlockwise",
      get: function get() {
        return this._anticlockwise;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._anticlockwise != value;
        this._anticlockwise = value;
      }
    }, {
      key: "setAnticlockwise",
      value: function setAnticlockwise(anticlockwise) {
        if (anticlockwise === undefined) {
          anticlockwise = true;
        }

        this.anticlockwise = anticlockwise;
        return this;
      }
    }, {
      key: "thickness",
      get: function get() {
        return this._thickness;
      },
      set: function set(value) {
        value = Clamp$9(value, 0, 1);
        this.dirty = this.dirty || this._thickness != value;
        this._thickness = value;
      }
    }, {
      key: "setThickness",
      value: function setThickness(thickness) {
        this.thickness = thickness;
        return this;
      }
    }, {
      key: "centerColor",
      get: function get() {
        return this._centerColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._centerColor != value;
        this._centerColor = value;
      }
    }, {
      key: "centerColor2",
      get: function get() {
        return this._centerColor2;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._centerColor2 != value;
        this._centerColor2 = value;
      }
    }, {
      key: "setCenterColor",
      value: function setCenterColor(color, color2) {
        this.centerColor = color;
        this.centerColor2 = color2;
        return this;
      }
    }, {
      key: "textColor",
      get: function get() {
        return this._textColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._textColor != value;
        this._textColor = value;
      }
    }, {
      key: "setTextColor",
      value: function setTextColor(color) {
        this.textColor = color;
        return this;
      }
    }, {
      key: "textStrokeColor",
      get: function get() {
        return this._textStrokeColor;
      },
      set: function set(value) {
        value = GetStyle(value, this.canvas, this.context);
        this.dirty = this.dirty || this._textStrokeColor != value;
        this._textStrokeColor = value;
      }
    }, {
      key: "textStrokeThickness",
      get: function get() {
        return this._textStrokeThickness;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._textStrokeThickness != value;
        this._textStrokeThickness = value;
      }
    }, {
      key: "setTextStrokeColor",
      value: function setTextStrokeColor(color, thickness) {
        if (thickness === undefined) {
          thickness = 2;
        }

        this.textStrokeColor = color;
        this.textStrokeThickness = thickness;
        return this;
      }
    }, {
      key: "textFont",
      get: function get() {
        return this._textFont;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._textFont != value;
        this._textFont = value;
      }
    }, {
      key: "setTextFont",
      value: function setTextFont(fontSize, fontFamily, fontStyle) {
        var font;

        if (fontFamily === undefined) {
          font = fontSize;
        } else {
          font = fontStyle + ' ' + fontSize + ' ' + fontFamily;
        }

        this.textFont = font;
        return this;
      }
    }, {
      key: "setTextFormatCallback",
      value: function setTextFormatCallback(callback, scope) {
        this.textFormatCallback = callback;
        this.textFormatCallbackScope = scope;
        return this;
      }
    }, {
      key: "updateTexture",
      value: function updateTexture() {
        this.clear();
        DrawContent.call(this);

        _get(_getPrototypeOf(CircularProgress.prototype), "updateTexture", this).call(this);

        return this;
      }
    }, {
      key: "getFormatText",
      value: function getFormatText(value) {
        if (value === undefined) {
          value = this.value;
        }

        var text;

        if (this.textFormatCallbackScope) {
          text = this.textFormatCallback(value);
        } else {
          text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
        }

        return text;
      }
    }]);

    return CircularProgress;
  }(Canvas);

  Object.assign(CircularProgress$1.prototype, EaseValueMethods);

  ObjectFactory.register('circularProgressCanvas', function (x, y, radius, barColor, value, config) {
    var gameObject = new CircularProgress$1(this.scene, x, y, radius, barColor, value, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.CircularProgressCanvas', CircularProgress$1);

  var GetCalcMatrix = Phaser.GameObjects.GetCalcMatrix;

  var WebGLRenderer = function WebGLRenderer(renderer, src, camera, parentMatrix) {
    src.updateData();
    camera.addToRenderList(src);
    var pipeline = renderer.pipelines.set(src.pipeline);
    var result = GetCalcMatrix(src, camera, parentMatrix);
    var calcMatrix = pipeline.calcMatrix.copyFrom(result.calc);
    var dx = src._displayOriginX;
    var dy = src._displayOriginY;
    var alpha = camera.alpha * src.alpha;
    renderer.pipelines.preBatch(src);
    var shapes = src.geom;

    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      shapes[i].webglRender(pipeline, calcMatrix, alpha, dx, dy);
    }

    renderer.pipelines.postBatch(src);
  };

  var SetTransform = Phaser.Renderer.Canvas.SetTransform;

  var CanvasRenderer = function CanvasRenderer(renderer, src, camera, parentMatrix) {
    src.updateData();
    camera.addToRenderList(src);
    var ctx = renderer.currentContext;

    if (SetTransform(renderer, ctx, src, camera, parentMatrix)) {
      var dx = src._displayOriginX;
      var dy = src._displayOriginY;
      var shapes = src.geom;

      for (var i = 0, cnt = shapes.length; i < cnt; i++) {
        shapes[i].canvasRender(ctx, dx, dy);
      } //  Restore the context saved in SetTransform


      ctx.restore();
    }
  };

  var Render = {
    renderWebGL: WebGLRenderer,
    renderCanvas: CanvasRenderer
  };

  var Shape = Phaser.GameObjects.Shape;
  var RemoveItem$7 = Phaser.Utils.Array.Remove;

  var BaseShapes = /*#__PURE__*/function (_Shape) {
    _inherits(BaseShapes, _Shape);

    var _super = _createSuper(BaseShapes);

    function BaseShapes(scene, x, y, width, height) {
      var _this;

      _classCallCheck(this, BaseShapes);

      if (x === undefined) {
        x = 0;
      }

      if (y === undefined) {
        y = 0;
      }

      if (width === undefined) {
        width = 0;
      }

      if (height === undefined) {
        height = width;
      }

      _this = _super.call(this, scene, 'rexShapes', []);
      _this._width = -1;
      _this._height = -1;
      _this.dirty = true;
      _this.isSizeChanged = true;
      _this.shapes = {};

      _this.setPosition(x, y);

      _this.setSize(width, height);

      _this.updateDisplayOrigin();

      return _this;
    }

    _createClass(BaseShapes, [{
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this.setSize(value, this._height);
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this.setSize(this._width, value);
      }
    }, {
      key: "setDirty",
      value: function setDirty(value) {
        if (value === undefined) {
          value = true;
        }

        this.dirty = value;
        return this;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.isSizeChanged = this.isSizeChanged || this._width !== width || this._height !== height;
        this.dirty = this.dirty || this.isSizeChanged;
        this._width = width;
        this._height = height;
        this.updateDisplayOrigin();
        var input = this.input;

        if (input && !input.customHitArea) {
          input.hitArea.width = width;
          input.hitArea.height = height;
        }

        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        this.setSize(width, height);
        return this;
      }
    }, {
      key: "fillColor",
      get: function get() {
        return this._fillColor;
      },
      set: function set(value) {
        this.setFillStyle(value, this._fillAlpha);
      }
    }, {
      key: "fillAlpha",
      get: function get() {
        return this._fillAlpha;
      },
      set: function set(value) {
        this.setFillStyle(this._fillColor, value);
      }
    }, {
      key: "setFillStyle",
      value: function setFillStyle(color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }

        this.dirty = this.dirty || this.fillColor !== color || this.fillAlpha !== alpha;
        this._fillColor = color;
        this._fillAlpha = alpha;
        return this;
      }
    }, {
      key: "lineWidth",
      get: function get() {
        return this._lineWidth;
      },
      set: function set(value) {
        this.setStrokeStyle(value, this._strokeColor, this._strokeAlpha);
      }
    }, {
      key: "strokeColor",
      get: function get() {
        return this._strokeColor;
      },
      set: function set(value) {
        this.setStrokeStyle(this._lineWidth, value, this._strokeAlpha);
      }
    }, {
      key: "strokeAlpha",
      get: function get() {
        return this._strokeAlpha;
      },
      set: function set(value) {
        this.setStrokeStyle(this._lineWidth, this._strokeColor, value);
      }
    }, {
      key: "setStrokeStyle",
      value: function setStrokeStyle(lineWidth, color, alpha) {
        if (alpha === undefined) {
          alpha = 1;
        }

        this.dirty = this.dirty || this.lineWidth !== lineWidth || this.strokeColor !== color || this.strokeAlpha !== alpha;
        this._lineWidth = lineWidth;
        this._strokeColor = color;
        this._strokeAlpha = alpha;
        return this;
      }
    }, {
      key: "updateShapes",
      value: function updateShapes() {}
    }, {
      key: "updateData",
      value: function updateData() {
        if (!this.dirty) {
          return this;
        }

        this.updateShapes();
        var shapes = this.geom;

        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
          var shape = shapes[i];

          if (shape.dirty) {
            shape.updateData();
          }
        }

        this.isSizeChanged = false;
        this.dirty = false;
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.geom.length = 0;
        Clear(this.shapes);
        return this;
      }
    }, {
      key: "getShape",
      value: function getShape(name) {
        return this.shapes[name];
      }
    }, {
      key: "getShapes",
      value: function getShapes() {
        return this.geom;
      }
    }, {
      key: "addShape",
      value: function addShape(shape) {
        this.geom.push(shape);
        var name = shape.name;

        if (name) {
          this.shapes[name] = shape;
        }

        this.dirty = true;
        return this;
      }
    }, {
      key: "deleteShape",
      value: function deleteShape(name) {
        var shape = this.getShape(name);

        if (shape) {
          delete this.shapes[name];
          RemoveItem$7(this.geom, shape);
        }

        return this;
      }
    }]);

    return BaseShapes;
  }(Shape);

  Object.assign(BaseShapes.prototype, Render);

  var FillStyle = function FillStyle(color, alpha) {
    if (color === undefined) {
      this.isFilled = false;
    } else {
      if (alpha === undefined) {
        alpha = 1;
      }

      this.isFilled = true;
      this.fillColor = color;
      this.fillAlpha = alpha;
    }

    return this;
  };

  var LineStyle = function LineStyle(lineWidth, color, alpha) {
    if (lineWidth === undefined || color === undefined) {
      this.isStroked = false;
    } else {
      if (alpha === undefined) {
        alpha = 1;
      }

      this.isStroked = true;
      this.lineWidth = lineWidth;
      this.strokeColor = color;
      this.strokeAlpha = alpha;
    }

    return this;
  };

  var StyleMethods = {
    fillStyle: FillStyle,
    lineStyle: LineStyle
  };

  var BaseGeom = /*#__PURE__*/function () {
    function BaseGeom() {
      _classCallCheck(this, BaseGeom);

      this.name = undefined;
      this.dirty = true;
      this.data = undefined;
      this.isFilled = false;
      this.fillColor = undefined;
      this.fillAlpha = 1;
      this.isStroked = false;
      this.lineWidth = 1;
      this.strokeColor = undefined;
      this.strokeAlpha = 1;
    }

    _createClass(BaseGeom, [{
      key: "setName",
      value: function setName(name) {
        this.name = name;
        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.fillStyle().lineStyle();
        return this;
      }
    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {}
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {}
    }, {
      key: "updateData",
      value: function updateData() {
        this.dirty = false;
      }
    }]);

    return BaseGeom;
  }();

  Object.assign(BaseGeom.prototype, StyleMethods, DataMethods);

  var Earcut = Phaser.Geom.Polygon.Earcut;

  var PathBase = /*#__PURE__*/function (_BaseGeom) {
    _inherits(PathBase, _BaseGeom);

    var _super = _createSuper(PathBase);

    function PathBase() {
      var _this;

      _classCallCheck(this, PathBase);

      _this = _super.call(this);
      _this.pathData = [];
      _this.pathIndexes = [];
      _this.closePath = false;
      return _this;
    }

    _createClass(PathBase, [{
      key: "updateData",
      value: function updateData() {
        this.pathIndexes = Earcut(this.pathData);

        _get(_getPrototypeOf(PathBase.prototype), "updateData", this).call(this);

        return this;
      }
    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {
        if (this.isFilled) {
          FillPathWebGL(pipeline, calcMatrix, this, alpha, dx, dy);
        }

        if (this.isStroked) {
          StrokePathWebGL(pipeline, this, alpha, dx, dy);
        }
      }
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {
        var path = this.pathData;
        var pathLength = path.length - 1;
        var px1 = path[0] - dx;
        var py1 = path[1] - dy;
        ctx.beginPath();
        ctx.moveTo(px1, py1);

        if (!this.closePath) {
          pathLength -= 2;
        }

        for (var i = 2; i < pathLength; i += 2) {
          var px2 = path[i] - dx;
          var py2 = path[i + 1] - dy;
          ctx.lineTo(px2, py2);
        }

        if (this.closePath) {
          ctx.closePath();
        }

        if (this.isFilled) {
          FillStyleCanvas(ctx, this);
          ctx.fill();
        }

        if (this.isStroked) {
          LineStyleCanvas(ctx, this);
          ctx.stroke();
        }
      }
    }]);

    return PathBase;
  }(BaseGeom);

  var DegToRad$4 = Phaser.Math.DegToRad;

  var Arc = /*#__PURE__*/function (_PathBase) {
    _inherits(Arc, _PathBase);

    var _super = _createSuper(Arc);

    function Arc(x, y, radiusX, radiusY, startAngle, endAngle, anticlockwise, pie) {
      var _this;

      _classCallCheck(this, Arc);

      if (x === undefined) {
        x = 0;
      }

      if (y === undefined) {
        y = 0;
      }

      if (radiusX === undefined) {
        radiusX = 0;
      }

      if (radiusY === undefined) {
        radiusY = 0;
      }

      if (startAngle === undefined) {
        startAngle = 0;
      }

      if (endAngle === undefined) {
        endAngle = 360;
      }

      if (anticlockwise === undefined) {
        anticlockwise = false;
      }

      if (pie === undefined) {
        pie = false;
      }

      _this = _super.call(this);

      _this.setCenterPosition(x, y);

      _this.setRadius(radiusX, radiusY);

      _this.setAngle(startAngle, endAngle, anticlockwise);

      _this.setPie(pie);

      _this.setIterations(32);

      return _this;
    }

    _createClass(Arc, [{
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x !== value;
        this._x = value;
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y !== value;
        this._y = value;
      }
    }, {
      key: "setCenterPosition",
      value: function setCenterPosition(x, y) {
        if (y === undefined) {
          y = x;
        }

        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "radiusX",
      get: function get() {
        return this._radiusX;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._radiusX !== value;
        this._radiusX = value;
      }
    }, {
      key: "radiusY",
      get: function get() {
        return this._radiusY;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._radiusY !== value;
        this._radiusY = value;
      }
    }, {
      key: "setRadius",
      value: function setRadius(radiusX, radiusY) {
        if (radiusY === undefined) {
          radiusY = radiusX;
        }

        this.radiusX = radiusX;
        this.radiusY = radiusY;
        return this;
      }
    }, {
      key: "startAngle",
      get: function get() {
        return this._startAngle;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._startAngle !== value;
        this._startAngle = value;
      }
    }, {
      key: "endAngle",
      get: function get() {
        return this._endAngle;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._endAngle !== value;
        this._endAngle = value;
      }
    }, {
      key: "anticlockwise",
      get: function get() {
        return this._anticlockwise;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._anticlockwise !== value;
        this._anticlockwise = value;
      }
    }, {
      key: "setAngle",
      value: function setAngle(startAngle, endAngle, anticlockwise) {
        // startAngle, endAngle in degrees
        if (anticlockwise === undefined) {
          anticlockwise = false;
        }

        this.startAngle = startAngle;
        this.endAngle = endAngle;
        this.anticlockwise = anticlockwise;
        return this;
      }
    }, {
      key: "pie",
      get: function get() {
        return this._pie;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._pie !== value;
        this._pie = value;
      }
    }, {
      key: "setPie",
      value: function setPie(pie) {
        if (pie === undefined) {
          pie = true;
        }

        this.pie = pie;
        return this;
      }
    }, {
      key: "iterations",
      get: function get() {
        return this._iterations;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._iterations !== value;
        this._iterations = value;
      }
    }, {
      key: "setIterations",
      value: function setIterations(iterations) {
        this.iterations = iterations;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;

        if (this.pie) {
          this.pathData.push(this.x, this.y);
        }

        ArcTo$1(this.x, this.y, this.radiusX, this.radiusY, this.startAngle, this.endAngle, this.anticlockwise, this.iterations, this.pathData);

        if (this.pie) {
          this.pathData.push(this.x, this.y);
        }

        this.pathData.push(this.pathData[0], this.pathData[1]);

        _get(_getPrototypeOf(Arc.prototype), "updateData", this).call(this);

        return this;
      }
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {
        ctx.beginPath();
        var x = this.x - dx,
            y = this.y - dy,
            startAngle = DegToRad$4(this.startAngle),
            endAngle = DegToRad$4(this.endAngle);

        if (this.pie) {
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(startAngle) * this.radiusX, y + Math.sin(startAngle) * this.radiusY);
        }

        ctx.ellipse(x, y, this.radiusX, this.radiusY, 0, startAngle, endAngle, this.anticlockwise);

        if (this.pie) {
          ctx.lineTo(x, y);
        }

        if (this.isFilled) {
          FillStyleCanvas(ctx, this);
          ctx.fill();
        }

        if (this.isStroked) {
          LineStyleCanvas(ctx, this);
          ctx.stroke();
        }
      }
    }]);

    return Arc;
  }(PathBase);

  var Circle = /*#__PURE__*/function (_Arc) {
    _inherits(Circle, _Arc);

    var _super = _createSuper(Circle);

    function Circle(x, y, radius) {
      _classCallCheck(this, Circle);

      return _super.call(this, x, y, radius, radius, 0, 360);
    }

    return _createClass(Circle);
  }(Arc);

  var Curve = /*#__PURE__*/function (_PathBase) {
    _inherits(Curve, _PathBase);

    var _super = _createSuper(Curve);

    function Curve(curve) {
      var _this;

      _classCallCheck(this, Curve);

      _this = _super.call(this);

      _this.setCurve(curve);

      _this.setIterations(32);

      return _this;
    }

    _createClass(Curve, [{
      key: "curve",
      get: function get() {
        return this._curve;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._curve !== value;
        this._curve = value;
      }
    }, {
      key: "setCurve",
      value: function setCurve(curve) {
        this.curve = curve;
        return this;
      }
    }, {
      key: "iterations",
      get: function get() {
        return this._iterations;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._iterations !== value;
        this._iterations = value;
      }
    }, {
      key: "setIterations",
      value: function setIterations(iterations) {
        this.iterations = iterations;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;
        var points = this.curve.getPoints(this.iterations);

        for (var i = 0, cnt = points.length; i < cnt; i++) {
          this.pathData.push(points[i].x, points[i].y);
        }

        this.pathData.push(points[0].x, points[0].y);

        _get(_getPrototypeOf(Curve.prototype), "updateData", this).call(this);

        return this;
      }
    }]);

    return Curve;
  }(PathBase);

  var Ellipse = /*#__PURE__*/function (_Arc) {
    _inherits(Ellipse, _Arc);

    var _super = _createSuper(Ellipse);

    function Ellipse(x, y, radiusX, radiusY) {
      _classCallCheck(this, Ellipse);

      return _super.call(this, x, y, radiusX, radiusY, 0, 360);
    }

    return _createClass(Ellipse);
  }(Arc);

  var Line = /*#__PURE__*/function (_PathBase) {
    _inherits(Line, _PathBase);

    var _super = _createSuper(Line);

    function Line(x0, y0, x1, y1) {
      var _this;

      _classCallCheck(this, Line);

      if (x0 === undefined) {
        x0 = 0;
      }

      if (y0 === undefined) {
        y0 = 0;
      }

      if (x1 === undefined) {
        x1 = 0;
      }

      if (y1 === undefined) {
        y1 = 0;
      }

      _this = _super.call(this);

      _this.setP0(x0, y0);

      _this.setP1(x1, y1);

      return _this;
    }

    _createClass(Line, [{
      key: "x0",
      get: function get() {
        return this._x0;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x0 !== value;
        this._x0 = value;
      }
    }, {
      key: "y0",
      get: function get() {
        return this._y0;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y0 !== value;
        this._y0 = value;
      }
    }, {
      key: "setP0",
      value: function setP0(x, y) {
        this.x0 = x;
        this.y0 = y;
        return this;
      }
    }, {
      key: "x1",
      get: function get() {
        return this._x1;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x1 !== value;
        this._x1 = value;
      }
    }, {
      key: "y1",
      get: function get() {
        return this._y1;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y1 !== value;
        this._y1 = value;
      }
    }, {
      key: "setP1",
      value: function setP1(x, y) {
        this.x1 = x;
        this.y1 = y;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;
        this.pathData.push(this.x0, this.y0);
        this.pathData.push(this.x1, this.y1);
        this.pathData.push(this.x0, this.y0);

        _get(_getPrototypeOf(Line.prototype), "updateData", this).call(this);

        return this;
      }
    }]);

    return Line;
  }(PathBase);

  var StartAt = function StartAt(x, y, pathData) {
    pathData.length = 0;
    pathData.push(x, y);
    return pathData;
  };

  var QuadraticBezierInterpolation = Phaser.Math.Interpolation.QuadraticBezier;

  var QuadraticBezierTo = function QuadraticBezierTo(cx, cy, x, y, iterations, pathData) {
    var pathDataCnt = pathData.length;
    var p0x = pathData[pathDataCnt - 2];
    var p0y = pathData[pathDataCnt - 1];

    for (var i = 1, last = iterations - 1; i <= last; i++) {
      var t = i / last;
      pathData.push(QuadraticBezierInterpolation(t, p0x, cx, x), QuadraticBezierInterpolation(t, p0y, cy, y));
    }

    return pathData;
  };

  var PointRotateAround$1 = Phaser.Math.RotateAround;

  var RotateAround$3 = function RotateAround(centerX, centerY, angle, pathData) {
    var point = {
      x: 0,
      y: 0
    };

    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
      point.x = pathData[i];
      point.y = pathData[i + 1];
      PointRotateAround$1(point, centerX, centerY, angle);
      pathData[i] = point.x;
      pathData[i + 1] = point.y;
    }

    return pathData;
  };

  var Offset = function Offset(x, y, pathData) {
    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
      pathData[i] += x;
      pathData[i + 1] += y;
    }

    return pathData;
  };

  var ToPoints = function ToPoints(pathData, points) {
    if (points === undefined) {
      points = [];
    }

    for (var i = 0, cnt = pathData.length - 1; i < cnt; i += 2) {
      points.push({
        x: pathData[i],
        y: pathData[i + 1]
      });
    }

    return points;
  };

  var Polygon = Phaser.Geom.Polygon;

  var ToPolygon = function ToPolygon(pathData, polygon) {
    if (polygon === undefined) {
      polygon = new Polygon();
    }

    polygon.setTo(pathData);
    return polygon;
  };

  var DegToRad$3 = Phaser.Math.DegToRad;

  var PathData = /*#__PURE__*/function () {
    function PathData(pathData) {
      _classCallCheck(this, PathData);

      if (pathData === undefined) {
        pathData = [];
      }

      this.pathData = pathData;
      this.closePath = false;
      this.setIterations(32);
      this.lastPointX = undefined;
      this.lastPointY = undefined;
    }

    _createClass(PathData, [{
      key: "setIterations",
      value: function setIterations(iterations) {
        this.iterations = iterations;
        return this;
      }
    }, {
      key: "startAt",
      value: function startAt(x, y) {
        StartAt(x, y, this.pathData);
        this.lastPointX = x;
        this.lastPointY = y;
        return this;
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y, relative) {
        if (relative === undefined) {
          relative = false;
        }

        if (relative) {
          x += this.lastPointX;
          y += this.lastPointY;
        }

        LineTo(x, y, this.pathData);
        this.lastPointX = x;
        this.lastPointY = y;
        return this;
      }
    }, {
      key: "verticalLineTo",
      value: function verticalLineTo(x, relative) {
        this.lineTo(x, this.lastPointY, relative);
        return this;
      }
    }, {
      key: "horizontalLineTo",
      value: function horizontalLineTo(y, relative) {
        this.lineTo(this.lastPointX, y, relative);
        return this;
      }
    }, {
      key: "ellipticalArc",
      value: function ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
        if (anticlockwise === undefined) {
          anticlockwise = false;
        }

        ArcTo$1(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise, this.iterations, this.pathData);
        var pathDataCnt = this.pathData.length;
        this.lastPointX = this.pathData[pathDataCnt - 2];
        this.lastPointY = this.pathData[pathDataCnt - 1];
        return this;
      }
    }, {
      key: "arc",
      value: function arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
        this.ellipticalArc(centerX, centerY, radius, radius, startAngle, endAngle, anticlockwise);
        return this;
      }
    }, {
      key: "quadraticBezierTo",
      value: function quadraticBezierTo(cx, cy, x, y) {
        QuadraticBezierTo(cx, cy, x, y, this.iterations, this.pathData);
        this.lastPointX = x;
        this.lastPointY = y;
        this.lastCX = cx;
        this.lastCY = cy;
        return this;
      }
    }, {
      key: "smoothQuadraticBezierTo",
      value: function smoothQuadraticBezierTo(x, y) {
        var cx = this.lastPointX * 2 - this.lastCX;
        var cy = this.lastPointY * 2 - this.lastCY;
        this.quadraticBezierTo(cx, cy, x, y);
        return this;
      }
    }, {
      key: "cubicBezierCurveTo",
      value: function cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y) {
        QuadraticBezierTo(cx0, cy0, cx1, cy1, x, y, this.iterations, this.pathData);
        this.lastPointX = x;
        this.lastPointY = y;
        this.lastCX = cx1;
        this.lastCY = cy1;
        return this;
      }
    }, {
      key: "smoothCubicBezierCurveTo",
      value: function smoothCubicBezierCurveTo(cx1, cy1, x, y) {
        var cx0 = this.lastPointX * 2 - this.lastCX;
        var cy0 = this.lastPointY * 2 - this.lastCY;
        this.cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y);
        return this;
      }
    }, {
      key: "close",
      value: function close() {
        this.closePath = true;
        return this;
      }
    }, {
      key: "end",
      value: function end() {
        this.pathData.push(this.lastPointX, this.lastPointY);
        return this;
      }
    }, {
      key: "rotateAround",
      value: function rotateAround(centerX, centerY, angle) {
        if (this.pathData.length === 0) {
          return this;
        }

        angle = DegToRad$3(angle);
        RotateAround$3(centerX, centerY, angle, this.pathData);
        var pathDataCnt = this.pathData.length;
        this.lastPointX = this.pathData[pathDataCnt - 2];
        this.lastPointY = this.pathData[pathDataCnt - 1];

        if (this.lastCX !== undefined) {
          var point = {
            x: this.lastCX,
            y: this.lastCY
          };
          PointRotateAround(point, centerX, centerY, angle);
          this.lastCX = point.x;
          this.lastCY = point.y;
        }

        return this;
      }
    }, {
      key: "offset",
      value: function offset(x, y) {
        Offset(x, y, this.pathData);
        return this;
      }
    }, {
      key: "toPoints",
      value: function toPoints() {
        return ToPoints(this.pathData);
      }
    }, {
      key: "toPolygon",
      value: function toPolygon(polygon) {
        return ToPolygon(this.pathData, polygon);
      }
    }, {
      key: "draw",
      value: function draw(graphics, isFill, isStroke) {
        var points = this.toPoints();

        if (isFill) {
          graphics.fillPoints(points, this.closePath, this.closePath);
        }

        if (isStroke) {
          graphics.strokePoints(points, this.closePath, this.closePath);
        }

        return this;
      }
    }]);

    return PathData;
  }();

  var Lines = /*#__PURE__*/function (_PathBase) {
    _inherits(Lines, _PathBase);

    var _super = _createSuper(Lines);

    function Lines() {
      var _this;

      _classCallCheck(this, Lines);

      _this = _super.call(this);
      _this.builder = new PathData(_this.pathData);
      return _this;
    }

    _createClass(Lines, [{
      key: "iterations",
      get: function get() {
        return this.builder.iterations;
      },
      set: function set(value) {
        this.dirty = this.dirty || this.builder.iterations !== value;
        this.builder.setIterations(value);
      }
    }, {
      key: "setIterations",
      value: function setIterations(iterations) {
        this.iterations = iterations;
        return this;
      }
    }, {
      key: "lastPointX",
      get: function get() {
        return this.builder.lastPointX;
      }
    }, {
      key: "lastPointY",
      get: function get() {
        return this.builder.lastPointY;
      }
    }, {
      key: "startAt",
      value: function startAt(x, y) {
        this.builder.startAt(x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y, relative) {
        this.builder.lineTo(x, y, relative);
        this.dirty = true;
        return this;
      }
    }, {
      key: "verticalLineTo",
      value: function verticalLineTo(x, relative) {
        this.builder.verticalLineTo(x, relative);
        this.dirty = true;
        return this;
      }
    }, {
      key: "horizontalLineTo",
      value: function horizontalLineTo(y, relative) {
        this.builder.horizontalLineTo(y, relative);
        this.dirty = true;
        return this;
      }
    }, {
      key: "ellipticalArc",
      value: function ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise) {
        this.builder.ellipticalArc(centerX, centerY, radiusX, radiusY, startAngle, endAngle, anticlockwise);
        this.dirty = true;
        return this;
      }
    }, {
      key: "arc",
      value: function arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise) {
        this.builder.arc(centerX, centerY, radius, startAngle, endAngle, anticlockwise);
        this.dirty = true;
        return this;
      }
    }, {
      key: "quadraticBezierTo",
      value: function quadraticBezierTo(cx, cy, x, y) {
        this.builder.quadraticBezierTo(cx, cy, x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "smoothQuadraticBezierTo",
      value: function smoothQuadraticBezierTo(x, y) {
        this.builder.smoothQuadraticBezierTo(x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "cubicBezierCurveTo",
      value: function cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y) {
        this.builder.cubicBezierCurveTo(cx0, cy0, cx1, cy1, x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "smoothCubicBezierCurveTo",
      value: function smoothCubicBezierCurveTo(cx1, cy1, x, y) {
        this.builder.smoothCubicBezierCurveTo(cx1, cy1, x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "close",
      value: function close() {
        this.builder.close();
        this.closePath = this.builder.closePath;
        this.dirty = true;
        return this;
      }
    }, {
      key: "end",
      value: function end() {
        this.builder.end();
        this.dirty = true;
        return this;
      }
    }, {
      key: "rotateAround",
      value: function rotateAround(centerX, centerY, angle) {
        this.builder.rotateAround(centerX, centerY, angle);
        this.dirty = true;
        return this;
      }
    }, {
      key: "offset",
      value: function offset(x, y) {
        this.builder.offset(x, y);
        this.dirty = true;
        return this;
      }
    }, {
      key: "toPolygon",
      value: function toPolygon(polygon) {
        return this.builder.toPolygon(polygon);
      }
    }]);

    return Lines;
  }(PathBase);

  var GetTint$1 = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;

  var Rectangle$4 = /*#__PURE__*/function (_BaseGeom) {
    _inherits(Rectangle, _BaseGeom);

    var _super = _createSuper(Rectangle);

    function Rectangle(x, y, width, height) {
      var _this;

      _classCallCheck(this, Rectangle);

      if (x === undefined) {
        x = 0;
      }

      if (y === undefined) {
        y = 0;
      }

      if (width === undefined) {
        width = 0;
      }

      if (height === undefined) {
        height = width;
      }

      _this = _super.call(this);
      _this.pathData = [];
      _this.closePath = true;

      _this.setTopLeftPosition(x, y);

      _this.setSize(width, height);

      return _this;
    }

    _createClass(Rectangle, [{
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x !== value;
        this._x = value;
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y !== value;
        this._y = value;
      }
    }, {
      key: "setTopLeftPosition",
      value: function setTopLeftPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        return this._width;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._width !== value;
        this._width = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this._height;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._height !== value;
        this._height = value;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.width = width;
        this.height = height;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;
        var x0 = this.x,
            x1 = x0 + this.width,
            y0 = this.y,
            y1 = y0 + this.height;
        this.pathData.push(x0, y0);
        this.pathData.push(x1, y0);
        this.pathData.push(x1, y1);
        this.pathData.push(x0, y1);
        this.pathData.push(x0, y0);

        _get(_getPrototypeOf(Rectangle.prototype), "updateData", this).call(this);

        return this;
      }
    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {
        if (this.isFilled) {
          var fillTint = pipeline.fillTint;
          var fillTintColor = GetTint$1(this.fillColor, this.fillAlpha * alpha);
          fillTint.TL = fillTintColor;
          fillTint.TR = fillTintColor;
          fillTint.BL = fillTintColor;
          fillTint.BR = fillTintColor;
          pipeline.batchFillRect(-dx + this.x, -dy + this.y, this.width, this.height);
        }

        if (this.isStroked) {
          StrokePathWebGL(pipeline, this, alpha, dx, dy);
        }
      }
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {
        if (this.isFilled) {
          FillStyleCanvas(ctx, this);
          ctx.fillRect(-dx, -dy, this.width, this.height);
        }

        if (this.isStroked) {
          LineStyleCanvas(ctx, this);
          ctx.beginPath();
          ctx.rect(-dx, -dy, this.width, this.height);
          ctx.stroke();
        }
      }
    }]);

    return Rectangle;
  }(BaseGeom);

  var GetTint = Phaser.Renderer.WebGL.Utils.getTintAppendFloatAlpha;

  var Triangle = /*#__PURE__*/function (_BaseGeom) {
    _inherits(Triangle, _BaseGeom);

    var _super = _createSuper(Triangle);

    function Triangle(x0, y0, x1, y1, x2, y2) {
      var _this;

      _classCallCheck(this, Triangle);

      if (x0 === undefined) {
        x0 = 0;
      }

      if (y0 === undefined) {
        y0 = 0;
      }

      if (x1 === undefined) {
        x1 = 0;
      }

      if (y1 === undefined) {
        y1 = 0;
      }

      if (x2 === undefined) {
        x2 = 0;
      }

      if (y2 === undefined) {
        y2 = 0;
      }

      _this = _super.call(this);
      _this.pathData = [];
      _this.closePath = true;

      _this.setP0(x0, y0);

      _this.setP1(x1, y1);

      _this.setP2(x2, y2);

      return _this;
    }

    _createClass(Triangle, [{
      key: "x0",
      get: function get() {
        return this._x0;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x0 !== value;
        this._x0 = value;
      }
    }, {
      key: "y0",
      get: function get() {
        return this._y0;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y0 !== value;
        this._y0 = value;
      }
    }, {
      key: "setP0",
      value: function setP0(x, y) {
        this.x0 = x;
        this.y0 = y;
        return this;
      }
    }, {
      key: "x1",
      get: function get() {
        return this._x1;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x1 !== value;
        this._x1 = value;
      }
    }, {
      key: "y1",
      get: function get() {
        return this._y1;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y1 !== value;
        this._y1 = value;
      }
    }, {
      key: "setP1",
      value: function setP1(x, y) {
        this.x1 = x;
        this.y1 = y;
        return this;
      }
    }, {
      key: "x2",
      get: function get() {
        return this._x2;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._x2 !== value;
        this._x2 = value;
      }
    }, {
      key: "y2",
      get: function get() {
        return this._y2;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._y2 !== value;
        this._y2 = value;
      }
    }, {
      key: "setP2",
      value: function setP2(x, y) {
        this.dirty = this.dirty || this.x2 !== x || this.y2 !== y;
        this.x2 = x;
        this.y2 = y;
        return this;
      }
    }, {
      key: "updateData",
      value: function updateData() {
        this.pathData.length = 0;
        this.pathData.push(this.x0, this.y0);
        this.pathData.push(this.x1, this.y1);
        this.pathData.push(this.x2, this.y2);
        this.pathData.push(this.x0, this.y0);

        _get(_getPrototypeOf(Triangle.prototype), "updateData", this).call(this);

        return this;
      }
    }, {
      key: "webglRender",
      value: function webglRender(pipeline, calcMatrix, alpha, dx, dy) {
        if (this.isFilled) {
          var fillTintColor = GetTint(this.fillColor, this.fillAlpha * alpha);
          var x0 = this.x0 - dx;
          var y0 = this.y0 - dy;
          var x1 = this.x1 - dx;
          var y1 = this.y1 - dy;
          var x2 = this.x2 - dx;
          var y2 = this.y2 - dy;
          var tx0 = calcMatrix.getX(x0, y0);
          var ty0 = calcMatrix.getY(x0, y0);
          var tx1 = calcMatrix.getX(x1, y1);
          var ty1 = calcMatrix.getY(x1, y1);
          var tx2 = calcMatrix.getX(x2, y2);
          var ty2 = calcMatrix.getY(x2, y2);
          pipeline.batchTri(tx0, ty0, tx1, ty1, tx2, ty2, fillTintColor, fillTintColor, fillTintColor);
        }

        if (this.isStroked) {
          StrokePathWebGL(pipeline, this, alpha, dx, dy);
        }
      }
    }, {
      key: "canvasRender",
      value: function canvasRender(ctx, dx, dy) {
        var x1 = this.x1 - dx;
        var y1 = this.y1 - dy;
        var x2 = this.x2 - dx;
        var y2 = this.y2 - dy;
        var x3 = this.x3 - dx;
        var y3 = this.y3 - dy;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.lineTo(x3, y3);
        ctx.closePath();

        if (this.isFilled) {
          FillStyleCanvas(ctx, this);
          ctx.fill();
        }

        if (this.isStroked) {
          LineStyleCanvas(ctx, this);
          ctx.stroke();
        }
      }
    }]);

    return Triangle;
  }(BaseGeom);

  var GetValue$1t = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$p = Phaser.Utils.Objects.IsPlainObject;
  var Clamp$8 = Phaser.Math.Clamp;
  var Linear$8 = Phaser.Math.Linear;
  var Percent$4 = Phaser.Math.Percent;
  var DefaultStartAngle = Phaser.Math.DegToRad(270);
  var RadToDeg$3 = Phaser.Math.RadToDeg;

  var CircularProgress = /*#__PURE__*/function (_BaseShapes) {
    _inherits(CircularProgress, _BaseShapes);

    var _super = _createSuper(CircularProgress);

    function CircularProgress(scene, x, y, radius, barColor, value, config) {
      var _this;

      _classCallCheck(this, CircularProgress);

      if (IsPlainObject$p(x)) {
        config = x;
        x = GetValue$1t(config, 'x', 0);
        y = GetValue$1t(config, 'y', 0);
        radius = GetValue$1t(config, 'radius', 1);
        barColor = GetValue$1t(config, 'barColor', undefined);
        value = GetValue$1t(config, 'value', 0);
      }

      var width = radius * 2;
      _this = _super.call(this, scene, x, y, width, width);
      _this.type = 'rexCircularProgress';
      _this.eventEmitter = GetValue$1t(config, 'eventEmitter', _assertThisInitialized(_this));

      _this.addShape(new Circle().setName('track')).addShape(new Arc().setName('bar')).addShape(new Circle().setName('center'));

      _this.setRadius(radius);

      _this.setTrackColor(GetValue$1t(config, 'trackColor', undefined));

      _this.setBarColor(barColor);

      _this.setCenterColor(GetValue$1t(config, 'centerColor', undefined));

      _this.setThickness(GetValue$1t(config, 'thickness', 0.2));

      _this.setStartAngle(GetValue$1t(config, 'startAngle', DefaultStartAngle));

      _this.setAnticlockwise(GetValue$1t(config, 'anticlockwise', false));

      var callback = GetValue$1t(config, 'valuechangeCallback', null);

      if (callback !== null) {
        var scope = GetValue$1t(config, 'valuechangeCallbackScope', undefined);

        _this.eventEmitter.on('valuechange', callback, scope);
      }

      _this.setEaseValuePropName('value').setEaseValueDuration(GetValue$1t(config, 'easeValue.duration', 0)).setEaseValueFunction(GetValue$1t(config, 'easeValue.ease', 'Linear'));

      _this.setValue(value);

      return _this;
    }

    _createClass(CircularProgress, [{
      key: "resize",
      value: function resize(width, height) {
        width = Math.floor(Math.min(width, height));

        if (width === this.width) {
          return this;
        }

        _get(_getPrototypeOf(CircularProgress.prototype), "resize", this).call(this, width, width);

        this.setRadius(width / 2);
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        value = Clamp$8(value, 0, 1);
        var oldValue = this._value;
        var valueChanged = oldValue != value;
        this.dirty = this.dirty || valueChanged;
        this._value = value;

        if (valueChanged) {
          this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
      }
    }, {
      key: "setValue",
      value: function setValue(value, min, max) {
        if (value === undefined || value === null) {
          return this;
        }

        if (min !== undefined) {
          value = Percent$4(value, min, max);
        }

        this.value = value;
        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, min, max) {
        if (min !== undefined) {
          inc = Percent$4(inc, min, max);
        }

        this.value += inc;
        return this;
      }
    }, {
      key: "getValue",
      value: function getValue(min, max) {
        var value = this.value;

        if (min !== undefined) {
          value = Linear$8(min, max, value);
        }

        return value;
      }
    }, {
      key: "radius",
      get: function get() {
        return this._radius;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._radius != value;
        this._radius = value;
        var width = value * 2;
        this.resize(width, width);
      }
    }, {
      key: "setRadius",
      value: function setRadius(radius) {
        this.radius = radius;
        return this;
      }
    }, {
      key: "trackColor",
      get: function get() {
        return this._trackColor;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._trackColor != value;
        this._trackColor = value;
      }
    }, {
      key: "setTrackColor",
      value: function setTrackColor(color) {
        this.trackColor = color;
        return this;
      }
    }, {
      key: "barColor",
      get: function get() {
        return this._barColor;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._barColor != value;
        this._barColor = value;
      }
    }, {
      key: "setBarColor",
      value: function setBarColor(color) {
        this.barColor = color;
        return this;
      }
    }, {
      key: "startAngle",
      get: function get() {
        return this._startAngle;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._startAngle != value;
        this._startAngle = value;
      }
    }, {
      key: "setStartAngle",
      value: function setStartAngle(angle) {
        this.startAngle = angle;
        return this;
      }
    }, {
      key: "anticlockwise",
      get: function get() {
        return this._anticlockwise;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._anticlockwise != value;
        this._anticlockwise = value;
      }
    }, {
      key: "setAnticlockwise",
      value: function setAnticlockwise(anticlockwise) {
        if (anticlockwise === undefined) {
          anticlockwise = true;
        }

        this.anticlockwise = anticlockwise;
        return this;
      }
    }, {
      key: "thickness",
      get: function get() {
        return this._thickness;
      },
      set: function set(value) {
        value = Clamp$8(value, 0, 1);
        this.dirty = this.dirty || this._thickness != value;
        this._thickness = value;
      }
    }, {
      key: "setThickness",
      value: function setThickness(thickness) {
        this.thickness = thickness;
        return this;
      }
    }, {
      key: "centerColor",
      get: function get() {
        return this._centerColor;
      },
      set: function set(value) {
        this.dirty = this.dirty || this._centerColor != value;
        this._centerColor = value;
      }
    }, {
      key: "setCenterColor",
      value: function setCenterColor(color) {
        this.centerColor = color;
        return this;
      }
    }, {
      key: "updateShapes",
      value: function updateShapes() {
        var x = this.radius;
        var lineWidth = this.thickness * this.radius;
        var barRadius = this.radius - lineWidth / 2;
        var centerRadius = this.radius - lineWidth; // Track shape

        var trackShape = this.getShape('track');

        if (this.trackColor != null && lineWidth > 0) {
          trackShape.setCenterPosition(x, x).setRadius(barRadius).lineStyle(lineWidth, this.trackColor);
        } else {
          trackShape.reset();
        } // Bar shape


        var barShape = this.getShape('bar');

        if (this.barColor != null && barRadius > 0) {
          var anticlockwise, startAngle, endAngle;

          if (this.value === 1) {
            anticlockwise = false;
            startAngle = 0;
            endAngle = 361; // overshoot 1
          } else {
            anticlockwise = this.anticlockwise;
            startAngle = RadToDeg$3(this.startAngle);
            var deltaAngle = 360 * (anticlockwise ? 1 - this.value : this.value);
            endAngle = deltaAngle + startAngle;
          }

          barShape.setCenterPosition(x, x).setRadius(barRadius).setAngle(startAngle, endAngle, anticlockwise).lineStyle(lineWidth, this.barColor);
        } else {
          barShape.reset();
        } // Center shape


        var centerShape = this.getShape('center');

        if (this.centerColor && centerRadius > 0) {
          centerShape.setCenterPosition(x, x).setRadius(centerRadius).fillStyle(this.centerColor);
        } else {
          centerShape.reset();
        }
      }
    }]);

    return CircularProgress;
  }(BaseShapes);

  Object.assign(CircularProgress.prototype, EaseValueMethods);

  ObjectFactory.register('circularProgress', function (x, y, radius, barColor, value, config) {
    var gameObject = new CircularProgress(this.scene, x, y, radius, barColor, value, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.CircularProgress', CircularProgress);

  var GetSizerConfig = function GetSizerConfig(gameObject) {
    if (!gameObject.hasOwnProperty('rexSizer')) {
      gameObject.rexSizer = {};
    }

    return gameObject.rexSizer;
  };

  var GetChildPrevState = function GetChildPrevState(child) {
    var childConfig = GetSizerConfig(child);

    if (!childConfig.hasOwnProperty('prevState')) {
      childConfig.prevState = {};
    }

    return childConfig.prevState;
  };

  var Rectangle$3 = Phaser.Geom.Rectangle;
  Phaser.Scale.Center;

  var GetViewport = function GetViewport(scene, out) {
    if (out === undefined) {
      out = new Rectangle$3();
    } else if (out === true) {
      out = globRect;
    }

    var scaleManager = scene.sys.scale;
    var baseSize = scaleManager.baseSize;
    var parentSize = scaleManager.parentSize;
    var canvasBounds = scaleManager.canvasBounds;
    var displayScale = scaleManager.displayScale;
    var x = canvasBounds.x >= 0 ? 0 : -(canvasBounds.x * displayScale.x);
    var y = canvasBounds.y >= 0 ? 0 : -(canvasBounds.y * displayScale.y);
    var width;

    if (parentSize.width >= canvasBounds.width) {
      width = baseSize.width;
    } else {
      width = baseSize.width - (canvasBounds.width - parentSize.width) * displayScale.x;
    }

    var height;

    if (parentSize.height >= canvasBounds.height) {
      height = baseSize.height;
    } else {
      height = baseSize.height - (canvasBounds.height - parentSize.height) * displayScale.y;
    }

    out.setTo(x, y, width, height);
    return out;
  };

  var globRect = new Rectangle$3();

  var PushIntoBounds = function PushIntoBounds(bounds) {
    if (bounds === undefined) {
      bounds = GetViewport(this.scene);
    }

    this.left = Math.max(this.left, bounds.left);
    this.right = Math.min(this.right, bounds.right);
    this.top = Math.max(this.top, bounds.top);
    this.bottom = Math.min(this.bottom, bounds.bottom);
    return this;
  };

  var ALIGN$1 = Phaser.Display.Align;
  var ALIGNMODE = {
    center: ALIGN$1.CENTER,
    left: ALIGN$1.LEFT_CENTER,
    right: ALIGN$1.RIGHT_CENTER,
    top: ALIGN$1.TOP_CENTER,
    bottom: ALIGN$1.BOTTOM_CENTER,
    'left-top': ALIGN$1.TOP_LEFT,
    'left-center': ALIGN$1.LEFT_CENTER,
    'left-bottom': ALIGN$1.BOTTOM_LEFT,
    'center-top': ALIGN$1.TOP_CENTER,
    'center-center': ALIGN$1.CENTER,
    'center-bottom': ALIGN$1.BOTTOM_CENTER,
    'right-top': ALIGN$1.TOP_RIGHT,
    'right-center': ALIGN$1.RIGHT_CENTER,
    'right-bottom': ALIGN$1.BOTTOM_RIGHT
  };

  var globZone = new Phaser.GameObjects.Zone({
    sys: {
      queueDepthSort: NOOP,
      events: {
        once: NOOP
      }
    }
  }, 0, 0, 1, 1);
  globZone.setOrigin(0);

  var ALIGN_CONST = {
    /**
    * A constant representing a top-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_LEFT
    * @since 3.0.0
    * @type {integer}
    */
    TOP_LEFT: 0,

    /**
    * A constant representing a top-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    TOP_CENTER: 1,

    /**
    * A constant representing a top-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.TOP_RIGHT
    * @since 3.0.0
    * @type {integer}
    */
    TOP_RIGHT: 2,

    /**
    * A constant representing a left-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_TOP
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_TOP: 3,

    /**
    * A constant representing a left-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_CENTER: 4,

    /**
    * A constant representing a left-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.LEFT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */
    LEFT_BOTTOM: 5,

    /**
    * A constant representing a center alignment or position.
    * @constant
    * @name Phaser.Display.Align.CENTER
    * @since 3.0.0
    * @type {integer}
    */
    CENTER: 6,

    /**
    * A constant representing a right-top alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_TOP
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_TOP: 7,

    /**
    * A constant representing a right-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_CENTER: 8,

    /**
    * A constant representing a right-bottom alignment or position.
    * @constant
    * @name Phaser.Display.Align.RIGHT_BOTTOM
    * @since 3.0.0
    * @type {integer}
    */
    RIGHT_BOTTOM: 9,

    /**
    * A constant representing a bottom-left alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_LEFT
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_LEFT: 10,

    /**
    * A constant representing a bottom-center alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_CENTER
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_CENTER: 11,

    /**
    * A constant representing a bottom-right alignment or position.
    * @constant
    * @name Phaser.Display.Align.BOTTOM_RIGHT
    * @since 3.0.0
    * @type {integer}
    */
    BOTTOM_RIGHT: 12
  };

  var GetDisplayWidth = function GetDisplayWidth(gameObject) {
    if (gameObject.displayWidth !== undefined) {
      return gameObject.displayWidth;
    } else {
      return gameObject.width;
    }
  };

  var GetDisplayHeight = function GetDisplayHeight(gameObject) {
    if (gameObject.displayHeight !== undefined) {
      return gameObject.displayHeight;
    } else {
      return gameObject.height;
    }
  };

  var GetBottom = function GetBottom(gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y + height - height * gameObject.originY;
  };

  var GetCenterX = function GetCenterX(gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x - width * gameObject.originX + width * 0.5;
  };

  var SetBottom = function SetBottom(gameObject, value) {
    var height = GetDisplayHeight(gameObject);
    gameObject.y = value - height + height * gameObject.originY;
    return gameObject;
  };

  var SetCenterX = function SetCenterX(gameObject, x) {
    var width = GetDisplayWidth(gameObject);
    var offsetX = width * gameObject.originX;
    gameObject.x = x + offsetX - width * 0.5;
    return gameObject;
  };

  var BottomCenter = function BottomCenter(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);
    return gameObject;
  };

  var GetLeft = function GetLeft(gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x - width * gameObject.originX;
  };

  var SetLeft = function SetLeft(gameObject, value) {
    var width = GetDisplayWidth(gameObject);
    gameObject.x = value + width * gameObject.originX;
    return gameObject;
  };

  var BottomLeft = function BottomLeft(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);
    return gameObject;
  };

  var GetRight = function GetRight(gameObject) {
    var width = GetDisplayWidth(gameObject);
    return gameObject.x + width - width * gameObject.originX;
  };

  var SetRight = function SetRight(gameObject, value) {
    var width = GetDisplayWidth(gameObject);
    gameObject.x = value - width + width * gameObject.originX;
    return gameObject;
  };

  var BottomRight = function BottomRight(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetBottom(gameObject, GetBottom(alignIn) + offsetY);
    return gameObject;
  };

  var SetCenterY = function SetCenterY(gameObject, y) {
    var height = GetDisplayHeight(gameObject);
    var offsetY = height * gameObject.originY;
    gameObject.y = y + offsetY - height * 0.5;
    return gameObject;
  };

  var CenterOn = function CenterOn(gameObject, x, y) {
    SetCenterX(gameObject, x);
    return SetCenterY(gameObject, y);
  };

  var GetCenterY = function GetCenterY(gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y - height * gameObject.originY + height * 0.5;
  };

  var Center = function Center(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    CenterOn(gameObject, GetCenterX(alignIn) + offsetX, GetCenterY(alignIn) + offsetY);
    return gameObject;
  };

  var LeftCenter = function LeftCenter(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
    return gameObject;
  };

  var RightCenter = function RightCenter(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetCenterY(gameObject, GetCenterY(alignIn) + offsetY);
    return gameObject;
  };

  var GetTop = function GetTop(gameObject) {
    var height = GetDisplayHeight(gameObject);
    return gameObject.y - height * gameObject.originY;
  };

  var SetTop = function SetTop(gameObject, value) {
    var height = GetDisplayHeight(gameObject);
    gameObject.y = value + height * gameObject.originY;
    return gameObject;
  };

  var TopCenter = function TopCenter(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    SetCenterX(gameObject, GetCenterX(alignIn) + offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);
    return gameObject;
  };

  var TopLeft = function TopLeft(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    SetLeft(gameObject, GetLeft(alignIn) - offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);
    return gameObject;
  };

  var TopRight = function TopRight(gameObject, alignIn, offsetX, offsetY) {
    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    SetRight(gameObject, GetRight(alignIn) + offsetX);
    SetTop(gameObject, GetTop(alignIn) - offsetY);
    return gameObject;
  };

  var AlignInMap = [];
  AlignInMap[ALIGN_CONST.BOTTOM_CENTER] = BottomCenter;
  AlignInMap[ALIGN_CONST.BOTTOM_LEFT] = BottomLeft;
  AlignInMap[ALIGN_CONST.BOTTOM_RIGHT] = BottomRight;
  AlignInMap[ALIGN_CONST.CENTER] = Center;
  AlignInMap[ALIGN_CONST.LEFT_CENTER] = LeftCenter;
  AlignInMap[ALIGN_CONST.RIGHT_CENTER] = RightCenter;
  AlignInMap[ALIGN_CONST.TOP_CENTER] = TopCenter;
  AlignInMap[ALIGN_CONST.TOP_LEFT] = TopLeft;
  AlignInMap[ALIGN_CONST.TOP_RIGHT] = TopRight;

  var QuickSet = function QuickSet(child, alignIn, position, offsetX, offsetY) {
    return AlignInMap[position](child, alignIn, offsetX, offsetY);
  };

  var AlignIn = function AlignIn(child, x, y, width, height, align) {
    globZone.setPosition(x, y).setSize(width, height);
    QuickSet(child, globZone, align);
  };

  var Rectangle$2 = Phaser.Geom.Rectangle;
  var Vector2 = Phaser.Math.Vector2;
  var RotateAround$2 = Phaser.Math.RotateAround;

  var GetBounds = function GetBounds(gameObject, output) {
    if (output === undefined) {
      output = new Rectangle$2();
    } else if (output === true) {
      if (GlobRect$2 === undefined) {
        GlobRect$2 = new Rectangle$2();
      }

      output = GlobRect$2;
    }

    if (gameObject.getBounds) {
      return gameObject.getBounds(output);
    } //  We can use the output object to temporarily store the x/y coords in:


    var TLx, TLy, TRx, TRy, BLx, BLy, BRx, BRy; // Instead of doing a check if parent container is
    // defined per corner we only do it once.

    if (gameObject.parentContainer) {
      var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();
      GetTopLeft(gameObject, output);
      parentMatrix.transformPoint(output.x, output.y, output);
      TLx = output.x;
      TLy = output.y;
      GetTopRight(gameObject, output);
      parentMatrix.transformPoint(output.x, output.y, output);
      TRx = output.x;
      TRy = output.y;
      GetBottomLeft(gameObject, output);
      parentMatrix.transformPoint(output.x, output.y, output);
      BLx = output.x;
      BLy = output.y;
      GetBottomRight(gameObject, output);
      parentMatrix.transformPoint(output.x, output.y, output);
      BRx = output.x;
      BRy = output.y;
    } else {
      GetTopLeft(gameObject, output);
      TLx = output.x;
      TLy = output.y;
      GetTopRight(gameObject, output);
      TRx = output.x;
      TRy = output.y;
      GetBottomLeft(gameObject, output);
      BLx = output.x;
      BLy = output.y;
      GetBottomRight(gameObject, output);
      BRx = output.x;
      BRy = output.y;
    }

    output.x = Math.min(TLx, TRx, BLx, BRx);
    output.y = Math.min(TLy, TRy, BLy, BRy);
    output.width = Math.max(TLx, TRx, BLx, BRx) - output.x;
    output.height = Math.max(TLy, TRy, BLy, BRy) - output.y;
    return output;
  };

  var GlobRect$2 = undefined;

  var GetTopLeft = function GetTopLeft(gameObject, output, includeParent) {
    if (output === undefined) {
      output = new Vector2();
    } else if (output === true) {
      if (GlobVector === undefined) {
        GlobVector = new Vector2();
      }

      output = GlobVector;
    }

    if (gameObject.getTopLeft) {
      return gameObject.getTopLeft(output);
    }

    output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX;
    output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY;
    return PrepareBoundsOutput(gameObject, output, includeParent);
  };

  var GetTopRight = function GetTopRight(gameObject, output, includeParent) {
    if (output === undefined) {
      output = new Vector2();
    } else if (output === true) {
      if (GlobVector === undefined) {
        GlobVector = new Vector2();
      }

      output = GlobVector;
    }

    if (gameObject.getTopRight) {
      return gameObject.getTopRight(output);
    }

    output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX + GetDisplayWidth(gameObject);
    output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY;
    return PrepareBoundsOutput(gameObject, output, includeParent);
  };

  var GetBottomLeft = function GetBottomLeft(gameObject, output, includeParent) {
    if (output === undefined) {
      output = new Vector2();
    } else if (output === true) {
      if (GlobVector === undefined) {
        GlobVector = new Vector2();
      }

      output = GlobVector;
    }

    if (gameObject.getBottomLeft) {
      return gameObject.getBottomLeft(output);
    }

    output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX;
    output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY + GetDisplayHeight(gameObject);
    return PrepareBoundsOutput(gameObject, output, includeParent);
  };

  var GetBottomRight = function GetBottomRight(gameObject, output, includeParent) {
    if (output === undefined) {
      output = new Vector2();
    } else if (output === true) {
      if (GlobVector === undefined) {
        GlobVector = new Vector2();
      }

      output = GlobVector;
    }

    if (gameObject.getBottomRight) {
      return gameObject.getBottomRight(output);
    }

    output.x = gameObject.x - GetDisplayWidth(gameObject) * gameObject.originX + GetDisplayWidth(gameObject);
    output.y = gameObject.y - GetDisplayHeight(gameObject) * gameObject.originY + GetDisplayHeight(gameObject);
    return PrepareBoundsOutput(gameObject, output, includeParent);
  };

  var GlobVector = undefined;

  var PrepareBoundsOutput = function PrepareBoundsOutput(gameObject, output, includeParent) {
    if (includeParent === undefined) {
      includeParent = false;
    }

    if (gameObject.rotation !== 0) {
      RotateAround$2(output, gameObject.x, gameObject.y, gameObject.rotation);
    }

    if (includeParent && gameObject.parentContainer) {
      var parentMatrix = gameObject.parentContainer.getBoundsTransformMatrix();
      parentMatrix.transformPoint(output.x, output.y, output);
    }

    return output;
  };

  var GetValue$1s = Phaser.Utils.Objects.GetValue;
  var Group$1 = Phaser.GameObjects.Group;

  var DrawBounds = function DrawBounds(graphics, config) {
    var scene = graphics.scene;
    var color;
    var createTextCallback, createTextCallbackScope, textAlign;

    if (typeof config === 'number') {
      color = config;
    } else {
      color = GetValue$1s(config, 'color', 0xffffff);
      var nameTextConfig = GetValue$1s(config, 'name', false);

      if (nameTextConfig) {
        createTextCallback = GetValue$1s(nameTextConfig, 'createTextCallback', DefaultCreateTextCallback);
        createTextCallbackScope = GetValue$1s(nameTextConfig, 'createTextCallbackScope', undefined);
        textAlign = GetValue$1s(nameTextConfig, 'align', 'left-top');

        if (typeof textAlign === 'string') {
          textAlign = ALIGNMODE[textAlign];
        }
      }
    }

    if (createTextCallback && !graphics.children) {
      graphics.children = new Group$1(scene);
      graphics.once('destroy', function (graphics, fromScene) {
        graphics.children.destroy(!fromScene);
        graphics.children = undefined;
      });
      var graphicsClear = graphics.clear.bind(graphics);

      graphics.clear = function () {
        graphicsClear();
        graphics.children.clear(false, true);
      };
    }

    var children = this.getAllShownChildren([this]),
        child;
    var nameText;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child.getBounds || child.width !== undefined && child.height !== undefined) {
        GlobRect$1 = GetBounds(child, GlobRect$1);
      } else {
        continue;
      }

      if (color != null) {
        graphics.lineStyle(1, color).strokeRectShape(GlobRect$1);
      }

      if (child.name && createTextCallback) {
        if (createTextCallbackScope) {
          nameText = createTextCallback.call(createTextCallbackScope, scene);
        } else {
          nameText = createTextCallback(scene);
        }

        if (nameText) {
          nameText.setText(child.name);
          graphics.children.add(nameText);
          AlignIn(nameText, GlobRect$1.x, GlobRect$1.y, GlobRect$1.width, GlobRect$1.height, textAlign);
        }
      }
    }

    return this;
  };

  var DefaultCreateTextCallback = function DefaultCreateTextCallback(scene, child, childBoundsRect) {
    return scene.add.text(0, 0, '');
  };

  var GlobRect$1 = undefined;

  var GetValue$1r = Phaser.Utils.Objects.GetValue;

  var GetBoundsConfig = function GetBoundsConfig(config, out) {
    if (out === undefined) {
      out = {};
    }

    if (typeof config === 'number') {
      out.left = config;
      out.right = config;
      out.top = config;
      out.bottom = config;
    } else {
      out.left = GetValue$1r(config, 'left', 0);
      out.right = GetValue$1r(config, 'right', 0);
      out.top = GetValue$1r(config, 'top', 0);
      out.bottom = GetValue$1r(config, 'bottom', 0);
    }

    return out;
  };

  var ContainerAdd$1 = ContainerLite.prototype.add;

  var AddChild = function AddChild(gameObject) {
    ContainerAdd$1.call(this, gameObject);

    if (this.sizerEventsEnable) {
      gameObject.emit('sizer.add', gameObject, this);
      this.emit('add', gameObject, this);
    }

    return this;
  };

  var AddChildMethods$8 = {
    addBackground: function addBackground(gameObject, paddingConfig, childKey) {
      if (this.backgroundChildren === undefined) {
        this.backgroundChildren = [];
      }

      if (typeof paddingConfig === 'string') {
        childKey = paddingConfig;
        paddingConfig = undefined;
      }

      if (paddingConfig === undefined) {
        paddingConfig = 0;
      }

      AddChild.call(this, gameObject);
      this.backgroundChildren.push(gameObject);
      var config = this.getSizerConfig(gameObject);
      config.padding = GetBoundsConfig(paddingConfig);

      if (childKey !== undefined) {
        this.addChildrenMap(childKey, gameObject);
      }

      return this;
    },
    isBackground: function isBackground(gameObject) {
      if (this.backgroundChildren === undefined) {
        return false;
      }

      return this.backgroundChildren.indexOf(gameObject) !== -1;
    }
  };

  var RemoveChildMethods$7 = {
    removeFromParentSizer: function removeFromParentSizer() {
      var parent = this.getParentSizer();

      if (parent) {
        parent.remove(this);
      }

      return this;
    }
  };

  var AddChildrenMap = function AddChildrenMap(key, gameObject) {
    if (this.childrenMap === undefined) {
      this.childrenMap = {};
    }

    this.childrenMap[key] = gameObject;
    return this;
  };

  var GetElement = function GetElement(mapNameList, recursive) {
    if (typeof mapNameList === 'string') {
      mapNameList = mapNameList.split('.');
    }

    if (mapNameList.length === 0) {
      return undefined;
    }

    var name = mapNameList.shift(),
        element = null;

    if (name.charAt(0) === '#') {
      // Get element by name
      name = name.substring(1);
      element = this.getByName(name, recursive);
    } else if (name.indexOf('[') === -1) {
      // Get element by key
      if (this.childrenMap) {
        element = this.childrenMap[name];
      }
    } else {
      // Get element by key[]
      var innerMatch = name.match(RE_OBJ);

      if (innerMatch != null) {
        if (this.childrenMap) {
          var elements = this.childrenMap[innerMatch[1]];

          if (elements) {
            element = elements[innerMatch[2]];
          }
        }
      }
    }

    if (mapNameList.length === 0) {
      return element;
    } else if (element && element.childrenMap) {
      return element.getElement(mapNameList);
    } else {
      return null;
    }
  };

  var RE_OBJ = /(\S+)\[(\d+)\]/i;

  var PaddingMethods = {
    getInnerPadding: function getInnerPadding(key) {
      return GetPadding$1(this.space, key);
    },
    setInnerPadding: function setInnerPadding(key, value) {
      SetPadding$1(this.space, key, value);
      return this;
    },
    getOuterPadding: function getOuterPadding(key) {
      return GetPadding$1(this.getSizerConfig(this).padding, key);
    },
    setOuterPadding: function setOuterPadding(key, value) {
      SetPadding$1(this.getSizerConfig(this).padding, key, value);
      return this;
    },
    getChildOuterPadding: function getChildOuterPadding(child, key) {
      if (typeof child === 'string') {
        child = this.getElement(child);
      }

      return GetPadding$1(this.getSizerConfig(child).padding, key);
    },
    setChildOuterPadding: function setChildOuterPadding(child, key, value) {
      if (typeof child === 'string') {
        child = this.getElement(child);
      }

      SetPadding$1(this.getSizerConfig(child).padding, key, value);
      return this;
    }
  };

  var ResolveWidth$2 = function ResolveWidth(width) {
    if (width === undefined) {
      width = Math.max(this.childrenWidth, this.minWidth);
    }

    return width;
  };

  var ResolveChildrenWidth$1 = function ResolveChildrenWidth(parentWidth) {
    // Resolve width of sizer children
    var child, childWidth;

    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];

      if (child && child.isRexSizer && !child.ignoreLayout) {
        childWidth = this.getExpandedChildWidth(child, parentWidth);
        childWidth = child.resolveWidth(childWidth);
        child.resolveChildrenWidth(childWidth);
      }
    }
  };

  var ResolveHeight$2 = function ResolveHeight(height) {
    var minHeight = Math.max(this.childrenHeight, this.minHeight);

    if (height === undefined) {
      height = minHeight;
    }

    return height;
  };

  var GetChildWidth$1 = function GetChildWidth(child) {
    var childWidth;

    if (child.isRexSizer) {
      // Sizer game object
      childWidth = Math.max(child.minWidth, child.childrenWidth);
    } else {
      // Normal game object
      if (child.minWidth !== undefined) {
        // Force minWidth
        childWidth = child.minWidth;
      } else {
        childWidth = GetDisplayWidth(child);
      }
    }

    return childWidth;
  };

  var GetChildHeight = function GetChildHeight(child) {
    var childHeight;

    if (child.isRexSizer) {
      // Sizer game object
      childHeight = Math.max(child.minHeight, child.childrenHeight);
    } else {
      // Normal game object
      if (child.minHeight !== undefined) {
        // Force minHeight
        childHeight = child.minHeight;
      } else {
        childHeight = GetDisplayHeight(child);
      }
    }

    return childHeight;
  };

  // Override
  var GetExpandedChildWidth$3 = function GetExpandedChildWidth(child, parentWidth) {
    return parentWidth;
  };

  // Override
  var GetExpandedChildHeight$3 = function GetExpandedChildHeight(child, parentHeight) {
    return parentHeight;
  };

  // Override
  var GetChildrenWidth$5 = function GetChildrenWidth() {
    return 0;
  };

  // Override
  var GetChildrenHeight$5 = function GetChildrenHeight() {
    return 0;
  };

  var GetAllChildrenSizers = function GetAllChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }

    var startIdx = out.length;
    var children = this.getChildrenSizers(out);
    var endIdx = out.length;

    for (var i = startIdx; i < endIdx; i++) {
      children[i].getAllChildrenSizers(out);
    }

    return out;
  };

  // Default method
  var GetChildrenSizers$5 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }

    return out;
  };

  var GetShownChildrenMethods = {
    getShownChildren: function getShownChildren(out) {
      if (out === undefined) {
        out = [];
      }

      var children = this.children,
          child;

      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];

        if (child.rexSizer && child.rexSizer.hidden) {
          // Don't add hidden child
          continue;
        }

        out.push(child);
      }

      return out;
    },
    getAllShownChildren: function getAllShownChildren(out) {
      if (out === undefined) {
        out = [];
      }

      var children = this.children,
          child;

      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];

        if (child.rexSizer && child.rexSizer.hidden) {
          // Don't add hidden child
          continue;
        }

        out.push(child);

        if (child.hasOwnProperty('isRexContainerLite')) {
          var _out;

          (_out = out).push.apply(_out, _toConsumableArray(child.getAllShownChildren()));
        }
      }

      return out;
    }
  };

  var PreLayout$4 = function PreLayout() {
    this._childrenWidth = undefined;
    this._childrenHeight = undefined;
    var children = this.getChildrenSizers(),
        child;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child.ignoreLayout) {
        continue;
      }

      child.preLayout();
    }
  };

  var Layout = function Layout() {
    this.runLayout();
    return this;
  };

  // Override
  var RunLayout = function RunLayout(parent, newWidth, newHeight) {
    // Skip hidden or !dirty sizer
    if (this.ignoreLayout) {
      return this;
    }

    var isTopmostParent = !parent; // Preprocessor, top parent only

    if (isTopmostParent) {
      this.preLayout();
    } // Calculate parent width


    newWidth = this.resolveWidth(newWidth); // Calculate all children width, run width wrap

    if (isTopmostParent) {
      this.resolveChildrenWidth(newWidth);
      this.runWidthWrap(newWidth);
    } // Calculate parent height


    newHeight = this.resolveHeight(newHeight); // Resize parent

    this.resize(newWidth, newHeight);

    if (this.sizerEventsEnable) {
      if (this.layoutedChildren === undefined) {
        this.layoutedChildren = [];
      }
    } // Layout children    


    this.layoutChildren(); // Layout background children

    this.layoutBackgrounds();

    if (this.sizerEventsEnable) {
      this.emit('postlayout', this.layoutedChildren, this);
      this.layoutedChildren.length = 0;
    }

    return this.postLayout();
  };

  // Override
  var LayoutChildren$6 = function LayoutChildren() {};

  var PostLayout = function PostLayout(parent, newWidth, newHeight) {
    if (this._anchor) {
      this._anchor.updatePosition();
    }

    return this;
  };

  // Default method
  var RunWidthWrap$2 = function RunWidthWrap(parentWidth) {
    var child, childWidth;

    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];

      if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
        continue;
      }

      childWidth = this.getExpandedChildWidth(child, parentWidth);

      if (child.isRexSizer) {
        childWidth = child.resolveWidth(childWidth);
      }

      child.runWidthWrap(childWidth);
    }

    return this;
  };

  var Anchor = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Anchor, _ComponentBase);

    var _super = _createSuper(Anchor);

    function Anchor(gameObject, config) {
      var _this;

      _classCallCheck(this, Anchor);

      _this = _super.call(this, gameObject, {
        eventEmitter: false
      }); // No event emitter
      // this.parent = gameObject;

      _this.viewport = undefined;

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(Anchor, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        if (o === undefined) {
          o = {};
        } // Position


        var alignX, configX;

        if (o.x !== undefined) {
          alignX = null;
          configX = o.x;
        } else if (o.left !== undefined) {
          alignX = 0;
          configX = o.left;
        } else if (o.right !== undefined) {
          alignX = 1;
          configX = o.right;
        } else if (o.centerX !== undefined) {
          alignX = 0.5;
          configX = o.centerX;
        }

        var alignY, configY;

        if (o.y !== undefined) {
          alignY = null;
          configY = o.y;
        } else if (o.top !== undefined) {
          alignY = 0;
          configY = o.top;
        } else if (o.bottom !== undefined) {
          alignY = 1;
          configY = o.bottom;
        } else if (o.centerY !== undefined) {
          alignY = 0.5;
          configY = o.centerY;
        }

        var percentageX, offsetX;

        if (configX !== undefined) {
          configX = configX.replace('left', '0%').replace('right', '100%').replace('center', '50%').split('%');
          percentageX = parseFloat(configX[0]) / 100;
          offsetX = configX[1] === '' ? 0 : parseFloat(configX[1]);
        }

        var percentageY, offsetY;

        if (configY !== undefined) {
          configY = configY.replace('top', '0%').replace('bottom', '100%').replace('center', '50%').split('%');
          percentageY = parseFloat(configY[0]) / 100;
          offsetY = configY[1] === '' ? 0 : parseFloat(configY[1]);
        } // Size


        var configWidth = o.width;
        var percentageWidth, paddingWidth;

        if (configWidth !== undefined) {
          configWidth = configWidth.split('%');
          percentageWidth = parseFloat(configWidth[0]) / 100;
          paddingWidth = configWidth[1] === '' ? 0 : parseFloat(configWidth[1]);
        }

        var configHeight = o.height;
        var percentageHeight, paddingHeight;

        if (configHeight !== undefined) {
          configHeight = configHeight.split('%');
          percentageHeight = parseFloat(configHeight[0]) / 100;
          paddingHeight = configHeight[1] === '' ? 0 : parseFloat(configHeight[1]);
        } // Position


        this.setAlign(alignX, alignY);
        this.setPercentage(percentageX, percentageY);
        this.setOffset(offsetX, offsetY); // Size

        this.setSizePercentage(percentageWidth, percentageHeight);
        this.setSizePadding(paddingWidth, paddingHeight);
        var onResizeCallback = o.onResizeCallback;
        var onResizeCallbackScope = o.onResizeCallbackScope;

        if (onResizeCallback !== undefined) {
          this.setResizeCallback(onResizeCallback, onResizeCallbackScope);
        }

        var onUpdateViewportCallback = o.onUpdateViewportCallback;
        var onUpdateViewportCallbackScope = o.onUpdateViewportCallbackScope;

        if (onUpdateViewportCallback !== undefined) {
          this.setUpdateViewportCallback(onUpdateViewportCallback, onUpdateViewportCallbackScope);
        }

        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        this.scene.sys.scale.on('resize', this.anchor, this);
        this.anchor();
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        this.scene.sys.scale.off('resize', this.anchor, this);
        this.viewport = undefined;
        this.onUpdateViewportCallback = undefined;
        this.onUpdateViewportCallbackScope = undefined;
        this.onResizeCallback = undefined;
        this.onResizeCallbackScope = undefined;

        _get(_getPrototypeOf(Anchor.prototype), "shutdown", this).call(this, fromScene);
      } // Position

    }, {
      key: "setAlign",
      value: function setAlign(x, y) {
        this.alignX = x;
        this.alignY = y;
        return this;
      }
    }, {
      key: "setPercentage",
      value: function setPercentage(x, y) {
        this.percentageX = x;
        this.percentageY = y;
        return this;
      }
    }, {
      key: "setOffset",
      value: function setOffset(x, y) {
        this.offsetX = x;
        this.offsetY = y;
        return this;
      } // Size

    }, {
      key: "setSizePercentage",
      value: function setSizePercentage(width, height) {
        this.percentageWidth = width;
        this.percentageHeight = height;
        return this;
      }
    }, {
      key: "setSizePadding",
      value: function setSizePadding(width, height) {
        this.paddingWidth = width;
        this.paddingHeight = height;
        return this;
      }
    }, {
      key: "setResizeCallback",
      value: function setResizeCallback(callback, scope) {
        this.onResizeCallback = callback;
        this.onResizeCallbackScope = scope;
        return this;
      }
    }, {
      key: "setUpdateViewportCallback",
      value: function setUpdateViewportCallback(callback, scope) {
        this.onUpdateViewportCallback = callback;
        this.onUpdateViewportCallbackScope = scope;
        return this;
      }
    }, {
      key: "anchor",
      value: function anchor() {
        this.updateViewport();
        this.updateSize();
        this.updatePosition();
        return this;
      }
    }, {
      key: "updateSize",
      value: function updateSize() {
        var callback = this.onResizeCallback,
            scope = this.onResizeCallbackScope;
        var newWidth = this.anchorWidth,
            newHeight = this.anchorHeight;

        if (newWidth === undefined && newHeight === undefined || !callback) {
          return;
        }

        var gameObject = this.parent;

        if (newWidth === undefined) {
          newWidth = gameObject.width;
        }

        if (newHeight === undefined) {
          newHeight = gameObject.height;
        }

        if (scope) {
          callback.call(scope, newWidth, newHeight, gameObject, this);
        } else {
          callback(newWidth, newHeight, gameObject, this);
        }
      }
    }, {
      key: "updatePosition",
      value: function updatePosition() {
        var gameObject = this.parent;

        if (this.alignX === null) {
          gameObject.x = this.anchorX;
        } else if (this.alignX !== undefined) {
          gameObject.x = this.anchorX + gameObject.displayWidth * (gameObject.originX - this.alignX);
        }

        if (this.alignY === null) {
          gameObject.y = this.anchorY;
        } else if (this.alignY !== undefined) {
          gameObject.y = this.anchorY + gameObject.displayHeight * (gameObject.originY - this.alignY);
        }

        return this;
      }
    }, {
      key: "anchorX",
      get: function get() {
        return this.viewport.x + this.viewport.width * this.percentageX + this.offsetX;
      }
    }, {
      key: "anchorY",
      get: function get() {
        return this.viewport.y + this.viewport.height * this.percentageY + this.offsetY;
      }
    }, {
      key: "anchorWidth",
      get: function get() {
        if (this.percentageWidth === undefined) {
          return undefined;
        }

        return this.viewport.width * this.percentageWidth + this.paddingWidth;
      }
    }, {
      key: "anchorHeight",
      get: function get() {
        if (this.percentageHeight === undefined) {
          return undefined;
        }

        return this.viewport.height * this.percentageHeight + this.paddingHeight;
      }
    }, {
      key: "updateViewport",
      value: function updateViewport() {
        this.viewport = GetViewport(this.scene, this.viewport ? this.viewport : true);
        var callback = this.onUpdateViewportCallback,
            scope = this.onUpdateViewportCallbackScope;

        if (callback) {
          if (scope) {
            callback.call(scope, this.viewport, this.parent, this);
          } else {
            callback(this.viewport, this.parent, this);
          }
        }
      }
    }]);

    return Anchor;
  }(ComponentBase);

  var SetAnchor = function SetAnchor(config) {
    if (config === undefined) {
      config = {};
    } // Assign default onResizeCallback if not given    


    var hasMinWidth = config.hasOwnProperty('width');
    var hasMinHeight = config.hasOwnProperty('height');
    var hasOnResizeCallback = config.hasOwnProperty('onResizeCallback');

    if ((hasMinWidth || hasMinHeight) && !hasOnResizeCallback) {
      config.onResizeCallback = function (width, height, sizer) {
        if (hasMinWidth) {
          sizer.setMinWidth(width);
        }

        if (hasMinHeight) {
          sizer.setMinHeight(height);
        }

        sizer.layout();
      };
    }

    if (this._anchor === undefined) {
      this._anchor = new Anchor(this, config);
    } else {
      this._anchor.resetFromJSON(config);
    }

    return this;
  };

  var GetValue$1q = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue$3 = Phaser.Utils.Objects.GetAdvancedValue;
  var Linear$7 = Phaser.Math.Linear;

  var Scale = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(Scale, _EaseValueTaskBase);

    var _super = _createSuper(Scale);

    function Scale(gameObject, config) {
      var _this;

      _classCallCheck(this, Scale);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;
      // this.timer

      _this.scaleStart = {};
      _this.scaleEnd = {};

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(Scale, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Scale.prototype), "resetFromJSON", this).call(this, o);

        this.setMode(GetValue$1q(o, 'mode', 0));
        this.setScaleRange(GetAdvancedValue$3(o, 'start', undefined), GetAdvancedValue$3(o, 'end', 0));
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = MODE$3[m];
        }

        this.mode = m;
        return this;
      }
    }, {
      key: "setScaleRange",
      value: function setScaleRange(start, end) {
        if (typeof start === 'number') {
          this.startX = start;
          this.startY = start;
        } else {
          this.startX = GetAdvancedValue$3(start, 'x', this.parent.scaleX);
          this.startY = GetAdvancedValue$3(start, 'y', this.parent.scaleY);
        }

        if (typeof end === 'number') {
          this.endX = end;
          this.endY = end;
        } else {
          this.endX = GetAdvancedValue$3(end, 'x', undefined);
          this.endY = GetAdvancedValue$3(end, 'y', undefined);
        }

        this.hasScaleX = this.startX !== undefined && this.endX !== undefined;
        this.hasScaleY = this.startY !== undefined && this.endY !== undefined;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        if (this.timer.isRunning) {
          return this;
        }

        var gameObject = this.parent;

        if (this.hasScaleX) {
          gameObject.scaleX = this.startX;
        }

        if (this.hasScaleY) {
          gameObject.scaleY = this.startY;
        }

        this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(this.mode === 2 ? -1 : 0);

        _get(_getPrototypeOf(Scale.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(gameObject, timer) {
        var t = timer.t;

        if (timer.isOddIteration) {
          // Yoyo
          t = 1 - t;
        }

        t = this.easeFn(t);

        if (this.hasScaleX) {
          gameObject.scaleX = Linear$7(this.startX, this.endX, t);
        }

        if (this.hasScaleY) {
          gameObject.scaleY = Linear$7(this.startY, this.endY, t);
        }
      }
    }, {
      key: "complete",
      value: function complete() {
        _get(_getPrototypeOf(Scale.prototype), "complete", this).call(this);

        if (this.mode === 1) {
          this.parent.destroy(); // Will also destroy this behavior
        }

        return this;
      }
    }]);

    return Scale;
  }(EaseValueTaskBase);

  var MODE$3 = {
    stop: 0,
    destroy: 1,
    yoyo: 2
  };

  var PopUp = function PopUp(gameObject, duration, orientation, ease, scale) {
    // Ease scale from 0 to current scale
    var start, end;

    switch (orientation) {
      case 0:
      case 'x':
        start = {
          x: 0
        };
        end = {
          x: gameObject.scaleX
        };
        break;

      case 1:
      case 'y':
        start = {
          y: 0
        };
        end = {
          y: gameObject.scaleY
        };
        break;

      default:
        start = 0;
        end = gameObject.scale;
        break;
    }

    var config = {
      mode: 0,
      start: start,
      end: end,
      duration: duration,
      ease: ease === undefined ? 'Cubic' : ease
    };

    if (scale === undefined) {
      scale = new Scale(gameObject, config);
    } else {
      scale.resetFromJSON(config);
    }

    scale.restart();
    return scale;
  };

  var ScaleDownDestroy = function ScaleDownDestroy(gameObject, duration, orientation, ease, destroyMode, scale) {
    // Ease from current scale to 0
    if (destroyMode instanceof Scale) {
      scale = destroyMode;
      destroyMode = undefined;
    }

    if (destroyMode === undefined) {
      destroyMode = true;
    }

    var config = {};
    config.mode = destroyMode ? 1 : 0;

    switch (orientation) {
      case 0:
      case 'x':
        config.end = {
          x: 0
        };
        break;

      case 1:
      case 'y':
        config.end = {
          y: 0
        };
        break;

      default:
        config.end = 0;
        break;
    }

    config.duration = duration;
    config.ease = ease === undefined ? 'Linear' : ease;

    if (scale === undefined) {
      scale = new Scale(gameObject, config);
    } else {
      scale.resetFromJSON(config);
    }

    scale.restart();
    return scale;
  };

  var IsPlainObject$o = Phaser.Utils.Objects.IsPlainObject;

  var OnInitScale = function OnInitScale(gameObject, scale) {
    // Route 'complete' of scale to gameObject
    scale.completeEventName = undefined;
    scale.on('complete', function () {
      if (scale.completeEventName) {
        gameObject.emit(scale.completeEventName, gameObject);
        scale.completeEventName = undefined;
      }
    }); // Update local state

    scale.on('update', function () {
      var parent = gameObject.getParentSizer();

      if (parent) {
        parent.resetChildPositionState(gameObject);
      }
    });
  };

  var ScaleMethods = {
    popUp: function popUp(duration, orientation, ease) {
      if (IsPlainObject$o(duration)) {
        var config = duration;
        duration = config.duration;
        orientation = config.orientation;
        ease = config.ease;
      }

      var isInit = this._scale === undefined;
      this._scale = PopUp(this, duration, orientation, ease, this._scale);

      if (isInit) {
        OnInitScale(this, this._scale);
      }

      this._scale.completeEventName = 'popup.complete';
      return this;
    },
    popUpPromise: function popUpPromise(duration, orientation, ease) {
      this.popUp(duration, orientation, ease);
      return WaitComplete(this._scale);
    },
    scaleDownDestroy: function scaleDownDestroy(duration, orientation, ease, destroyMode) {
      if (IsPlainObject$o(duration)) {
        var config = duration;
        duration = config.duration;
        orientation = config.orientation;
        ease = config.ease;
        destroyMode = config.destroy;
      }

      var isInit = this._scale === undefined;
      this._scale = ScaleDownDestroy(this, duration, orientation, ease, destroyMode, this._scale);

      if (isInit) {
        OnInitScale(this, this._scale);
      }

      this._scale.completeEventName = 'scaledown.complete';
      return this;
    },
    scaleDownDestroyPromise: function scaleDownDestroyPromise(duration, orientation, ease, destroyMode) {
      this.scaleDownDestroy(duration, orientation, ease, destroyMode);
      return WaitComplete(this._scale);
    },
    scaleDown: function scaleDown(duration, orientation, ease) {
      this.scaleDownDestroy(duration, orientation, ease, false);
      return this;
    },
    scaleDownPromise: function scaleDownPromise(duration, orientation, ease) {
      this.scaleDown(duration, orientation, ease);
      return WaitComplete(this._scale);
    }
  };

  var GetValue$1p = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue$2 = Phaser.Utils.Objects.GetAdvancedValue;
  var Linear$6 = Phaser.Math.Linear;

  var Fade$1 = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(Fade, _EaseValueTaskBase);

    var _super = _createSuper(Fade);

    function Fade(gameObject, config) {
      var _this;

      _classCallCheck(this, Fade);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;
      // this.timer

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(Fade, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Fade.prototype), "resetFromJSON", this).call(this, o);

        this.setMode(GetValue$1p(o, 'mode', 0));
        this.setAlphaRange(GetAdvancedValue$2(o, 'start', this.parent.alpha), GetAdvancedValue$2(o, 'end', 0));
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = MODE$2[m];
        }

        this.mode = m;
        return this;
      }
    }, {
      key: "setAlphaRange",
      value: function setAlphaRange(start, end) {
        this.alphaStart = start;
        this.alphaEnd = end;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        if (this.timer.isRunning) {
          return this;
        }

        var gameObject = this.parent;
        gameObject.setAlpha(this.alphaStart);
        this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(this.mode === 2 ? -1 : 0);

        _get(_getPrototypeOf(Fade.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(gameObject, timer) {
        var t = timer.t;

        if (timer.isOddIteration) {
          // Yoyo
          t = 1 - t;
        }

        gameObject.alpha = Linear$6(this.alphaStart, this.alphaEnd, t);
      }
    }, {
      key: "complete",
      value: function complete() {
        _get(_getPrototypeOf(Fade.prototype), "complete", this).call(this);

        if (this.mode === 1) {
          this.parent.destroy(); // Will also destroy this behavior
        }

        return this;
      }
    }]);

    return Fade;
  }(EaseValueTaskBase);

  var MODE$2 = {
    stop: 0,
    destroy: 1,
    yoyo: 2
  };

  var IsPlainObject$n = Phaser.Utils.Objects.IsPlainObject;

  var FadeIn = function FadeIn(gameObject, duration, alpha, fade) {
    var startAlpha, endAlpha;

    if (IsPlainObject$n(alpha)) {
      startAlpha = alpha.start;
      endAlpha = alpha.end;
    } else {
      endAlpha = alpha;
    }

    if (startAlpha === undefined) {
      startAlpha = 0;
    }

    if (endAlpha === undefined) {
      endAlpha = 1;
    }

    var config = {
      mode: 0,
      start: startAlpha,
      end: endAlpha,
      duration: duration
    };

    if (fade === undefined) {
      fade = new Fade$1(gameObject, config);
    } else {
      fade.resetFromJSON(config);
    }

    fade.restart();
    return fade;
  };

  var FadeOutDestroy = function FadeOutDestroy(gameObject, duration, destroyMode, fade) {
    if (destroyMode instanceof Fade$1) {
      fade = destroyMode;
      destroyMode = undefined;
    }

    if (destroyMode === undefined) {
      destroyMode = true;
    }

    var config = {
      mode: destroyMode ? 1 : 0,
      end: 0,
      duration: duration
    };

    if (fade === undefined) {
      fade = new Fade$1(gameObject, config);
    } else {
      fade.resetFromJSON(config);
    }

    fade.restart();
    return fade;
  };

  var IsPlainObject$m = Phaser.Utils.Objects.IsPlainObject;

  var OnInitFade = function OnInitFade(gameObject, fade) {
    // Route 'complete' of fade to gameObject
    fade.completeEventName = undefined;
    fade.on('complete', function () {
      if (fade.completeEventName) {
        gameObject.emit(fade.completeEventName, gameObject);
        fade.completeEventName = undefined;
      }
    }); // Update local state

    fade.on('update', function () {
      var parent = gameObject.getParentSizer();

      if (parent) {
        parent.resetChildAlphaState(gameObject);
      }
    });
  };

  var FadeMethods = {
    fadeIn: function fadeIn(duration, alpha) {
      if (IsPlainObject$m(duration)) {
        var config = duration;
        duration = config.duration;
        alpha = config.alpha;
      }

      var isInit = this._fade === undefined;
      this._fade = FadeIn(this, duration, alpha, this._fade);

      if (isInit) {
        OnInitFade(this, this._fade);
      }

      this._fade.completeEventName = 'fadein.complete';
      return this;
    },
    fadeInPromise: function fadeInPromise(duration, alpha) {
      this.fadeIn(duration, alpha);
      return WaitComplete(this._fade);
    },
    fadeOutDestroy: function fadeOutDestroy(duration, destroyMode) {
      if (IsPlainObject$m(duration)) {
        var config = duration;
        duration = config.duration;
        destroyMode = config.destroy;
      }

      var isInit = this._fade === undefined;
      this._fade = FadeOutDestroy(this, duration, destroyMode, this._fade);

      if (isInit) {
        OnInitFade(this, this._fade);
      }

      this._fade.completeEventName = 'fadeout.complete';
      return this;
    },
    fadeOutDestroyPromise: function fadeOutDestroyPromise(duration, destroyMode) {
      this.fadeOutDestroy(duration, destroyMode);
      return WaitComplete(this._fade);
    },
    fadeOut: function fadeOut(duration) {
      this.fadeOutDestroy(duration, false);
      return this;
    },
    fadeOutPromise: function fadeOutPromise(duration) {
      this.fadeOut(duration);
      return WaitComplete(this._fade);
    }
  };

  var GetValue$1o = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue$1 = Phaser.Utils.Objects.GetAdvancedValue;
  var Linear$5 = Phaser.Math.Linear;

  var EaseMove = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(EaseMove, _EaseValueTaskBase);

    var _super = _createSuper(EaseMove);

    function EaseMove(gameObject, config) {
      var _this;

      _classCallCheck(this, EaseMove);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;
      // this.timer

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(EaseMove, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(EaseMove.prototype), "resetFromJSON", this).call(this, o);

        this.setMode(GetValue$1o(o, 'mode', 0));

        if (o && (o.hasOwnProperty('x') || o.hasOwnProperty('y'))) {
          var endX = GetAdvancedValue$1(o, 'x', undefined);
          var endY = GetAdvancedValue$1(o, 'y', undefined);
          this.setTargetPosition(endX, endY);
        } else {
          this.setTargetPosition(o);
        }

        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = MODE$1[m];
        }

        this.mode = m;
        return this;
      }
    }, {
      key: "setTargetPosition",
      value: function setTargetPosition(x, y) {
        if (typeof x === 'number' || typeof y === 'number') {
          // endX, endY
          // x,y : a number, or undefined
          this.startX = this.parent.x;
          this.startY = this.parent.y;
          this.endX = x;
          this.endY = y;
        } else {
          var config = x;
          this.startX = GetAdvancedValue$1(config, 'startX', undefined);
          this.startY = GetAdvancedValue$1(config, 'startY', undefined);
          this.endX = GetAdvancedValue$1(config, 'endX', undefined);
          this.endY = GetAdvancedValue$1(config, 'endY', undefined);
        }

        this.hasMoveX = this.startX !== undefined && this.endX !== undefined;
        this.hasMoveY = this.startY !== undefined && this.endY !== undefined;
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        if (this.timer.isRunning) {
          return this;
        }

        var gameObject = this.parent;

        if (this.hasMoveX) {
          gameObject.x = this.startX;
        }

        if (this.hasMoveY) {
          gameObject.y = this.startY;
        }

        this.timer.setDelay(this.delay).setDuration(this.duration).setRepeat(this.mode === 2 ? -1 : 0);

        _get(_getPrototypeOf(EaseMove.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(gameObject, timer) {
        var t = timer.t;

        if (timer.isOddIteration) {
          // Yoyo
          t = 1 - t;
        }

        t = this.easeFn(t);

        if (this.hasMoveX) {
          gameObject.x = Linear$5(this.startX, this.endX, t);
        }

        if (this.hasMoveY) {
          gameObject.y = Linear$5(this.startY, this.endY, t);
        }
      }
    }, {
      key: "complete",
      value: function complete() {
        _get(_getPrototypeOf(EaseMove.prototype), "complete", this).call(this);

        if (this.mode === 1) {
          this.parent.destroy(); // Will also destroy this behavior
        }

        return this;
      }
    }]);

    return EaseMove;
  }(EaseValueTaskBase);

  var MODE$1 = {
    stop: 0,
    destroy: 1,
    yoyo: 2
  };

  var ParseValue = function ParseValue(propertyValue, startValue) {
    // propertyValue : number or string
    if (typeof propertyValue === 'number') {
      return propertyValue;
    } else {
      var op = propertyValue[0];
      var num = parseFloat(propertyValue.substr(2));

      switch (op) {
        case '+':
          return startValue + num;

        case '-':
          return startValue - num;

        case '*':
          return startValue * num;

        case '/':
          return startValue / num;
      }
    }
  };

  var EaseMoveTo = function EaseMoveTo(gameObject, duration, endX, endY, ease, destroyMode, easeMove) {
    if (destroyMode instanceof EaseMove) {
      easeMove = destroyMode;
      destroyMode = undefined;
    }

    if (destroyMode === undefined) {
      destroyMode = false;
    }

    var config = {};
    config.mode = destroyMode ? 1 : 0;

    if (endX !== undefined) {
      config.startX = gameObject.x;
      config.endX = ParseValue(endX, gameObject.x);
    }

    if (endY !== undefined) {
      config.startY = gameObject.y;
      config.endY = ParseValue(endY, gameObject.y);
    }

    config.duration = duration;
    config.ease = ease === undefined ? 'Linear' : ease;

    if (easeMove === undefined) {
      easeMove = new EaseMove(gameObject, config);
    } else {
      easeMove.resetFromJSON(config);
    }

    easeMove.restart();
    return easeMove;
  };

  var EaseMoveFrom = function EaseMoveFrom(gameObject, duration, startX, startY, ease, destroyMode, easeMove) {
    if (destroyMode instanceof EaseMove) {
      easeMove = destroyMode;
      destroyMode = undefined;
    }

    if (destroyMode === undefined) {
      destroyMode = false;
    }

    var config = {};
    config.mode = destroyMode ? 1 : 0;

    if (startX !== undefined) {
      config.startX = ParseValue(startX, gameObject.x);
      config.endX = gameObject.x;
    }

    if (startY !== undefined) {
      config.startY = ParseValue(startY, gameObject.y);
      config.endY = gameObject.y;
    }

    config.duration = duration;
    config.ease = ease === undefined ? 'Linear' : ease;

    if (easeMove === undefined) {
      easeMove = new EaseMove(gameObject, config);
    } else {
      easeMove.resetFromJSON(config);
    }

    easeMove.restart();
    return easeMove;
  };

  var IsPlainObject$l = Phaser.Utils.Objects.IsPlainObject;
  var DistanceBetween$6 = Phaser.Math.Distance.Between;

  var OnInitEaseMove = function OnInitEaseMove(gameObject, easeMove) {
    // Route 'complete' of easeMove to gameObject
    easeMove.completeEventName = undefined;
    easeMove.on('complete', function () {
      if (easeMove.completeEventName) {
        gameObject.emit(easeMove.completeEventName, gameObject);
        easeMove.completeEventName = undefined;
      }
    }); // Update local state

    easeMove.on('update', function () {
      var parent = gameObject.getParentSizer();

      if (parent) {
        parent.resetChildPositionState(gameObject);
      }
    });
  };

  var EaseMoveMethods = {
    moveFrom: function moveFrom(duration, x, y, ease, destroyMode) {
      if (IsPlainObject$l(duration)) {
        var config = duration;
        x = config.x;
        y = config.y;

        if (config.hasOwnProperty('speed')) {
          duration = DistanceBetween$6(x, y, this.x, this.y) * 1000 / config.speed;
        } else {
          duration = config.duration;
        }

        ease = config.ease;
      }

      var isInit = this._easeMove === undefined;
      this._easeMove = EaseMoveFrom(this, duration, x, y, ease, destroyMode, this._easeMove);

      if (isInit) {
        OnInitEaseMove(this, this._easeMove);
      }

      this._easeMove.completeEventName = 'movefrom.complete';
      return this;
    },
    moveFromPromise: function moveFromPromise(duration, x, y, ease, destroyMode) {
      this.moveFrom(duration, x, y, ease, destroyMode);
      return WaitComplete(this._easeMove);
    },
    moveFromDestroy: function moveFromDestroy(duration, x, y, ease) {
      this.moveFrom(duration, x, y, ease, true);
      return this;
    },
    moveFromDestroyPromise: function moveFromDestroyPromise(duration, x, y, ease) {
      this.moveFromDestroy(duration, x, y, ease);
      return WaitComplete(this._easeMove);
    },
    moveTo: function moveTo(duration, x, y, ease, destroyMode) {
      if (IsPlainObject$l(duration)) {
        var config = duration;
        x = config.x;
        y = config.y;

        if (config.hasOwnProperty('speed')) {
          duration = DistanceBetween$6(x, y, this.x, this.y) * 1000 / config.speed;
        } else {
          duration = config.duration;
        }

        ease = config.ease;
      }

      var isInit = this._easeMove === undefined;
      this._easeMove = EaseMoveTo(this, duration, x, y, ease, destroyMode, this._easeMove);

      if (isInit) {
        OnInitEaseMove(this, this._easeMove);
      }

      this._easeMove.completeEventName = 'moveto.complete';
      return this;
    },
    moveToPromise: function moveToPromise(duration, x, y, ease, destroyMode) {
      this.moveTo(duration, x, y, ease, destroyMode);
      return WaitComplete(this._easeMove);
    },
    moveToDestroy: function moveToDestroy(duration, x, y, ease) {
      this.moveTo(duration, x, y, ease, true);
      return this;
    },
    moveToDestroyPromise: function moveToDestroyPromise(duration, x, y, ease) {
      this.moveToDestroy(duration, x, y, ease, true);
      return WaitComplete(this._easeMove);
    }
  };

  var GetValue$1n = Phaser.Utils.Objects.GetValue;

  var ShakePosition = /*#__PURE__*/function (_TickTask) {
    _inherits(ShakePosition, _TickTask);

    var _super = _createSuper(ShakePosition);

    function ShakePosition(gameObject, config) {
      var _this;

      _classCallCheck(this, ShakePosition);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;

      _this.timer = new Timer$1();

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(ShakePosition, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.timer.resetFromJSON(GetValue$1n(o, 'timer'));
        this.setEnable(GetValue$1n(o, 'enable', true));
        this.setMode(GetValue$1n(o, 'mode', 1));
        this.isRunning = GetValue$1n(o, 'isRunning', false);
        this.setMagnitudeMode(GetValue$1n(o, 'magnitudeMode', 1));
        this.setDuration(GetValue$1n(o, 'duration', 500));
        this.setMagnitude(GetValue$1n(o, 'magnitude', 10));
        this.ox = GetValue$1n(o, 'ox', undefined);
        this.oy = GetValue$1n(o, 'oy', undefined);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          timer: this.timer.toJSON(),
          enable: this.enable,
          mode: this.mode,
          isRunning: this.isRunning,
          magnitudeMode: magnitudeMode,
          duration: this.duration,
          magnitude: this.magnitude,
          ox: this.ox,
          oy: this.oy
        };
      } // override

    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        _get(_getPrototypeOf(ShakePosition.prototype), "shutdown", this).call(this, fromScene);

        this.timer.destroy();
        this.timer = undefined;
      }
    }, {
      key: "startTicking",
      value: function startTicking() {
        _get(_getPrototypeOf(ShakePosition.prototype), "startTicking", this).call(this);

        if (this.mode === 0) {
          // Effect mode
          this.scene.game.events.on('poststep', this.update, this);
          this.scene.game.events.on('prestep', this.backToOrigin, this);
        } else {
          // Behavior Mode
          this.scene.sys.events.on('preupdate', this.update, this);
        }
      }
    }, {
      key: "stopTicking",
      value: function stopTicking() {
        _get(_getPrototypeOf(ShakePosition.prototype), "stopTicking", this).call(this);

        if (this.scene) {
          // Scene might be destoryed
          if (this.mode === 0) {
            // Effect mode
            this.scene.game.events.off('poststep', this.update, this);
            this.scene.game.events.off('prestep', this.backToOrigin, this);
          } else {
            // Behavior Mode
            this.scene.sys.events.off('preupdate', this.update, this);
          }
        }
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e == undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(mode) {
        if (typeof mode === 'string') {
          mode = MODE[mode];
        }

        this.mode = mode;
        return this;
      }
    }, {
      key: "setMagnitudeMode",
      value: function setMagnitudeMode(magnitudeMode) {
        if (typeof magnitudeMode === 'string') {
          magnitudeMode = MANITUDEMODE[magnitudeMode];
        }

        this.magnitudeMode = magnitudeMode;
        return this;
      }
    }, {
      key: "setDuration",
      value: function setDuration(duration) {
        this.duration = duration;
        return this;
      }
    }, {
      key: "setMagnitude",
      value: function setMagnitude(magnitude) {
        this.magnitude = magnitude;
        return this;
      }
    }, {
      key: "start",
      value: function start(duration, magnitude) {
        if (typeof duration !== 'number') {
          var config = duration;
          magnitude = GetValue$1n(config, 'magnitude', undefined);
          duration = GetValue$1n(config, 'duration', undefined);
        }

        if (magnitude !== undefined) {
          this.setMagnitude(magnitude);
        }

        if (duration !== undefined) {
          this.setDuration(duration);
        }

        this.timer.setDuration(this.duration).start();

        _get(_getPrototypeOf(ShakePosition.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "shake",
      value: function shake(duration, magnitude) {
        this.start(duration, magnitude);
        return this;
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        if (!this.isRunning || !this.enable) {
          return this;
        }

        var gameObject = this.parent;

        if (!gameObject.active) {
          return this;
        }

        this.timer.update(time, delta);

        if (this.timer.isDone) {
          this.backToOrigin();
          this.complete();
        } else {
          if (this.ox === undefined) {
            this.ox = gameObject.x;
            this.oy = gameObject.y;
          }

          var magnitude = this.magnitude;

          if (this.magnitudeMode === 1) // decay
            {
              magnitude *= 1 - this.timer.t;
            }

          var a = Math.random() * Math.PI * 2;
          var offsetX = Math.cos(a) * magnitude;
          var offsetY = Math.sin(a) * magnitude;
          gameObject.setPosition(this.ox + offsetX, this.oy + offsetY);
        }

        return this;
      }
    }, {
      key: "backToOrigin",
      value: function backToOrigin() {
        if (!this.isRunning || !this.enable) {
          return this;
        }

        if (this.ox === undefined) {
          return this;
        }

        var gameObject = this.parent;

        if (this.ox === gameObject.x && this.oy === gameObject.y) {
          return this;
        }

        gameObject.setPosition(this.ox, this.oy);
        this.ox = undefined;
        this.oy = undefined;
        return this;
      }
    }]);

    return ShakePosition;
  }(TickTask);

  var MODE = {
    effect: 0,
    behavior: 1
  };
  var MANITUDEMODE = {
    constant: 0,
    decay: 1
  };

  var IsPlainObject$k = Phaser.Utils.Objects.IsPlainObject;

  var OnInitShake = function OnInitShake(gameObject, shake) {
    // Route 'complete' of shake to gameObject
    shake.on('complete', function () {
      gameObject.emit('shake.complete', gameObject);
    }); // Shake effect won't change position
  };

  var ShakeMethods = {
    shake: function shake(duration, magnitude, magnitudeMode) {
      if (IsPlainObject$k(duration)) {
        var config = duration;
        duration = config.duration;
        magnitude = config.magnitude;
        magnitudeMode = config.magnitudeMode;
      }

      if (this._shake === undefined) {
        this._shake = new ShakePosition(this, {
          mode: 0,
          magnitudeMode: 1
        });
        OnInitShake(this, this._shake);
      }

      if (duration !== undefined) {
        this._shake.setDuration(duration);
      }

      if (magnitude !== undefined) {
        this._shake.setMagnitude(magnitude);
      }

      if (magnitudeMode !== undefined) {
        this._shake.setMagnitudeMode(magnitudeMode);
      }

      this._shake.shake();

      return this;
    },
    shakePromise: function shakePromise(duration, alpha) {
      this.shake(duration, alpha);
      return WaitComplete(this._shake);
    }
  };

  var IsPlainObject$j = Phaser.Utils.Objects.IsPlainObject;

  var EaseData = /*#__PURE__*/function (_ComponentBase) {
    _inherits(EaseData, _ComponentBase);

    var _super = _createSuper(EaseData);

    function EaseData(parent, config) {
      var _this;

      _classCallCheck(this, EaseData);

      _this = _super.call(this, parent, config);

      _this.parent.setDataEnabled();

      _this.easeTasks = {};
      return _this;
    }

    _createClass(EaseData, [{
      key: "complete",
      value: function complete(key) {
        this.emit("complete-".concat(key), this.parent, this);
        this.emit('complete', key, this.parent, this);
      }
    }, {
      key: "getEaseTask",
      value: function getEaseTask(key) {
        var easeTask = this.easeTasks[key];

        if (easeTask === undefined) {
          easeTask = new EaseValueTask(this.parent);
          this.easeTasks[key] = easeTask;
          easeTask.setTarget(this.parent.data.values).on('complete', function () {
            this.complete(key);
          }, this);
        }

        return easeTask;
      }
    }, {
      key: "easeTo",
      value: function easeTo(key, value, duration, ease) {
        if (IsPlainObject$j(key)) {
          var config = key;
          key = config.key;
          value = config.value;
          duration = config.duration;
          ease = config.ease;
          var speed = config.speed;

          if (duration === undefined && speed !== undefined) {
            duration = Math.abs(value - this.parent.data.values[key]) / speed * 1000;
          }
        }

        if (duration === undefined) {
          duration = 1000;
        }

        if (ease === undefined) {
          ease = 'Linear';
        }

        var easeTask = this.getEaseTask(key);
        easeTask.restart({
          key: key,
          to: value,
          duration: duration,
          ease: ease
        });
        return this;
      }
    }, {
      key: "easeFrom",
      value: function easeFrom(key, value, duration, ease) {
        if (IsPlainObject$j(key)) {
          var config = key;
          key = config.key;
          value = config.value;
          duration = config.duration;
          ease = config.ease;
          var speed = config.speed;

          if (duration === undefined && speed !== undefined) {
            duration = Math.abs(value - this.parent.data.values[key]) / speed * 1000;
          }
        }

        if (duration === undefined) {
          duration = 1000;
        }

        if (ease === undefined) {
          ease = 'Linear';
        }

        var easeTask = this.getEaseTask(key);
        easeTask.restart({
          key: key,
          from: value,
          duration: duration,
          ease: ease
        });
        return this;
      }
    }, {
      key: "stopEase",
      value: function stopEase(key, toEnd) {
        if (toEnd === undefined) {
          toEnd = true;
        }

        var easeTask = this.easeTasks[key];

        if (easeTask) {
          easeTask.stop(toEnd);
        }

        return this;
      }
    }, {
      key: "stopAll",
      value: function stopAll(toEnd) {
        if (toEnd === undefined) {
          toEnd = true;
        }

        for (var key in this.easeTasks) {
          this.stopEase(key, toEnd);
        }

        return this;
      }
    }]);

    return EaseData;
  }(ComponentBase);

  var OnInitEaseData = function OnInitEaseData(gameObject, easeData) {
    // Route 'complete' of easeData to gameObject
    easeData.on('complete', function (key) {
      gameObject.emit("easedata.".concat(key, ".complete"), gameObject);
      gameObject.emit('easedata.complete', key, gameObject);
    });
  };

  var EaseDataMethods = {
    easeDataTo: function easeDataTo(key, value, duration, ease) {
      if (!this._easeData) {
        this._easeData = new EaseData(this);
        OnInitEaseData(this, this._easeData);
      }

      this._easeData.easeTo(key, value, duration, ease);

      return this;
    },
    easeDataToPromise: function easeDataToPromise(key, value, duration, ease) {
      this.easeDataTo(key, value, duration, ease);
      return WaitEvent(this._easeData, "complete-".concat(key));
    },
    stopEaseData: function stopEaseData(key, toEnd) {
      if (!this._easeData) {
        return this;
      }

      this._easeData.stopEase(key, toEnd);

      return this;
    },
    stopAllEaseData: function stopAllEaseData(toEnd) {
      if (!this._easeData) {
        return this;
      }

      this._easeData.stopAll(toEnd);

      return this;
    }
  };

  var Show = function Show(gameObject) {
    _hide(gameObject, false);
  };

  var Hide = function Hide(gameObject) {
    _hide(gameObject, true);
  };

  var IsShown = function IsShown(gameObject) {
    if (!gameObject) {
      return false;
    }

    var config = GetSizerConfig(gameObject);
    return !config.hidden;
  };

  var _hide = function _hide(gameObject, hidden) {
    if (!gameObject) {
      return;
    }

    var config = GetSizerConfig(gameObject);
    config.hidden = hidden;
    var parent = gameObject.rexContainer.parent;

    if (parent) {
      parent.setChildVisible(gameObject, !hidden);
    } else {
      this.setVisible(!hidden);
    }
  };

  var HideMethods = {
    show: function show(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }

      Show(gameObject);
      return this;
    },
    hide: function hide(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }

      Hide(gameObject);
      return this;
    },
    isShow: function isShow(gameObject) {
      if (gameObject === undefined) {
        gameObject = this;
      }

      return IsShown(gameObject);
    }
  };

  var IsPointInBounds = function IsPointInBounds(gameObject, x, y, preTest, postTest) {
    // Can't get bounds
    if (!gameObject || !gameObject.getBounds) {
      return false;
    }

    if (preTest && !preTest(gameObject, x, y)) {
      return false;
    }

    var boundsRect = GetBounds(gameObject, true);

    if (!boundsRect.contains(x, y)) {
      return false;
    }

    if (postTest && !postTest(gameObject, x, y)) {
      return false;
    }

    return true;
  };

  var IsPointerInBounds = function IsPointerInBounds(gameObject, pointer, preTest, postTest) {
    if (pointer) {
      return IsPointInBounds(gameObject, pointer.x, pointer.y, preTest, postTest);
    } else {
      var inputManager = gameObject.scene.input.manager;
      var pointersTotal = inputManager.pointersTotal;
      var pointers = inputManager.pointers;

      for (var i = 0; i < pointersTotal; i++) {
        pointer = pointers[i];

        if (IsPointInBounds(gameObject, pointer.x, pointer.y, preTest, postTest)) {
          return true;
        }
      }

      return false;
    }
  };

  var IsInTouching = function IsInTouching(pointer, gameObject) {
    if (gameObject === undefined) {
      gameObject = this;
    }

    return IsPointerInBounds(gameObject, pointer);
  };

  var IsFunction = function IsFunction(obj) {
    return obj && typeof obj === 'function';
  };

  var IsArray = function IsArray(obj) {
    return Object.prototype.toString.call(obj) === '[object Array]';
  };

  var ContainsPoint = function ContainsPoint(gameObject, x, y, preTest, postTest) {
    return IsPointInBounds(gameObject, x, y, GetPreTestCallback(preTest), GetPostTestCallback(postTest));
  };

  var IsNotHiddenSizer = function IsNotHiddenSizer(gameObject) {
    var isHiddenSizer = gameObject.rexSizer && gameObject.rexSizer.hidden;
    return !isHiddenSizer;
  };

  var GetPreTestCallback = function GetPreTestCallback(preTest) {
    if (!preTest) {
      return IsNotHiddenSizer;
    }

    return function (gameObject, x, y) {
      if (!IsNotHiddenSizer(gameObject)) {
        return false;
      }

      preTest(gameObject, x, y);
      return true;
    };
  };

  var GetPostTestCallback = function GetPostTestCallback(postTest) {
    return postTest;
  };

  var PointToChild$1 = function PointToChild(x, y, preTest, postTest, children) {
    if (!IsFunction(preTest)) {
      children = preTest;
      preTest = undefined;
      postTest = undefined;
    }

    if (children === undefined) {
      if (this.sizerChildren) {
        children = this.sizerChildren;
      } else {
        children = this.children;
      }
    }

    if (IsArray(children)) {
      var child;

      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];

        if (ContainsPoint(child, x, y, preTest, postTest)) {
          return child;
        }
      }
    } else {
      var child;

      for (var key in children) {
        child = children[key];

        if (ContainsPoint(child, x, y, preTest, postTest)) {
          return child;
        }
      }
    }

    return null;
  };

  var GetParentSizerMethods = {
    getParentSizer: function getParentSizer(gameObject, name) {
      return this.getParent(gameObject, name);
    },
    getTopmostSizer: function getTopmostSizer(gameObject) {
      return this.getTopmostParent(gameObject);
    }
  };

  var ResizeGameObject = function ResizeGameObject(gameObject, newWidth, newHeight) {
    if (!gameObject || newWidth === undefined && newHeight === undefined) {
      return;
    }

    if (gameObject.resize) {
      // Has `resize` method
      if (newWidth === undefined) {
        newWidth = gameObject.width;
      }

      if (newHeight === undefined) {
        newHeight = gameObject.height;
      }

      gameObject.resize(newWidth, newHeight);
    } else {
      // Set display width/height
      if (newWidth !== undefined) {
        gameObject.displayWidth = newWidth;
      }

      if (newHeight !== undefined) {
        gameObject.displayHeight = newHeight;
      }
    }
  };

  var CopyState = function CopyState(gamObject, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = GlobState;
    }

    out.x = gamObject.x;
    out.y = gamObject.y;
    out.scaleX = gamObject.scaleX;
    out.scaleY = gamObject.scaleY;
    out.width = gamObject.width;
    out.height = gamObject.height;
    out.displayWidth = gamObject.displayWidth;
    out.displayHeight = gamObject.displayHeight;
    return out;
  };

  var GlobState = {};

  var PreLayoutChild = function PreLayoutChild(child) {
    if (this.sizerEventsEnable) {
      CopyState(child, this.getChildPrevState(child));
      this.layoutedChildren.push(child);
    }
  };

  var LayoutChild = function LayoutChild(child, x, y, width, height, align, offsetX, offsetY) {
    AlignIn(child, x, y, width, height, align);

    if (offsetX !== undefined) {
      child.x += offsetX;
    }

    if (offsetY !== undefined) {
      child.y += offsetY;
    }

    this.resetChildPositionState(child);

    if (this.sizerEventsEnable) {
      child.emit('sizer.postlayout', child, this);
    }
  };

  var ALIGN_CENTER$4 = Phaser.Display.Align.CENTER;

  var LayoutBackgrounds = function LayoutBackgrounds() {
    if (this.backgroundChildren === undefined) {
      return;
    }

    var backgrounds = this.backgroundChildren;
    var startX = this.left,
        startY = this.top;
    var parentWidth = this.width,
        parentHeight = this.height;
    var child, childConfig, padding, x, y, width, height;

    for (var i = 0, cnt = backgrounds.length; i < cnt; i++) {
      child = backgrounds[i];
      childConfig = child.rexSizer;

      if (childConfig.hidden) {
        continue;
      }

      padding = childConfig.padding;
      PreLayoutChild.call(this, child);
      x = startX + padding.left;
      y = startY + padding.top;
      width = parentWidth - padding.left - padding.right;
      height = parentHeight - padding.top - padding.bottom;
      ResizeGameObject(child, width, height);
      LayoutChild.call(this, child, x, y, width, height, ALIGN_CENTER$4);
    }
  };

  var SetDraggable = function SetDraggable(senser, draggable) {
    var senserType = _typeof(senser);

    if (senserType === 'string') {
      senser = this.getElement(senser);
    } else if (senser === undefined || senserType != 'object') {
      draggable = senser;
      senser = this;
    }

    if (draggable === undefined) {
      draggable = true;
    }

    if (senser.input && senser.input.hasOwnProperty('draggable')) {
      // Draggable is already registered
      senser.input.draggable = draggable;
    } else if (draggable) {
      // Register draggable
      senser.setInteractive();
      senser.scene.input.setDraggable(senser);
      senser.on('drag', function (pointer, dragX, dragY) {
        var topmostParent = this.getTopmostSizer();
        topmostParent.x += dragX - senser.x;
        topmostParent.y += dragY - senser.y;
        topmostParent.emit('sizer.drag', pointer, dragX, dragY);
      }, this).on('dragstart', function (pointer, dragX, dragY) {
        var topmostParent = this.getTopmostSizer();
        topmostParent.emit('sizer.dragstart', pointer, dragX, dragY);
      }, this).on('dragend', function (pointer, dragX, dragY, dropped) {
        var topmostParent = this.getTopmostSizer();
        topmostParent.emit('sizer.dragend', pointer, dragX, dragY, dropped);
      }, this);
    } else ;

    return this;
  };

  var GetValue$1m = Phaser.Utils.Objects.GetValue;

  var Button = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Button, _ComponentBase);

    var _super = _createSuper(Button);

    function Button(gameObject, config) {
      var _this;

      _classCallCheck(this, Button);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;

      _this._enable = undefined;
      gameObject.setInteractive(GetValue$1m(config, "inputConfig", undefined));

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(Button, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.pointer = undefined;
        this.lastClickTime = undefined;
        this.setEnable(GetValue$1m(o, "enable", true));
        this.setMode(GetValue$1m(o, "mode", 1));
        this.setClickInterval(GetValue$1m(o, "clickInterval", 100));
        this.setDragThreshold(GetValue$1m(o, 'threshold', undefined));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        var gameObject = this.parent;
        gameObject.on('pointerdown', this.onPress, this);
        gameObject.on('pointerup', this.onRelease, this);
        gameObject.on('pointerout', this.onPointOut, this);
        gameObject.on('pointermove', this.onMove, this);
        gameObject.on('pointerover', this.onOver, this);
        gameObject.on('pointeroutr', this.onOut, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        } // GameObject events will be removed when this gameObject destroyed 
        // this.parent.on('pointerdown', this.onPress, this);
        // this.parent.on('pointerup', this.onRelease, this);
        // this.parent.on('pointerout', this.onPointOut, this);
        // this.parent.on('pointermove', this.onMove, this);


        this.pointer = null;

        _get(_getPrototypeOf(Button.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }

        if (!e) {
          this.cancel();
        }

        this._enable = e;
        var eventName = e ? 'enable' : 'disable';
        this.emit(eventName, this, this.parent);
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = CLICKMODE$1[m];
        }

        this.mode = m;
        return this;
      }
    }, {
      key: "setClickInterval",
      value: function setClickInterval(interval) {
        this.clickInterval = interval; // ms

        return this;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      } // internal

    }, {
      key: "onPress",
      value: function onPress(pointer, localX, localY, event) {
        if (this.pointer !== undefined) {
          return;
        }

        this.pointer = pointer;

        if (this.mode === 0) {
          this.click(pointer.downTime, pointer, event);
        }
      }
    }, {
      key: "onRelease",
      value: function onRelease(pointer, localX, localY, event) {
        if (this.pointer !== pointer) {
          return;
        }

        if (this.mode === 1) {
          this.click(pointer.upTime, pointer, event);
        }

        this.pointer = undefined;
      }
    }, {
      key: "onPointOut",
      value: function onPointOut(pointer, event) {
        if (this.pointer !== pointer) {
          return;
        }

        this.cancel();
      }
    }, {
      key: "onMove",
      value: function onMove(pointer, localX, localY, event) {
        if (this.pointer !== pointer) {
          return;
        }

        if (this.dragThreshold === undefined) {
          return;
        }

        if (pointer.getDistance() >= this.dragThreshold) {
          this.cancel();
        }
      }
    }, {
      key: "click",
      value: function click(nowTime, pointer, event) {
        if (!this.enable) {
          return this;
        }

        if (nowTime === undefined) {
          // fires 'click' event manually
          this.emit('click', this, this.parent, pointer, event);
          return this;
        }

        this.pointer = undefined;
        var lastClickTime = this.lastClickTime;

        if (lastClickTime !== undefined && nowTime - lastClickTime <= this.clickInterval) {
          return this;
        }

        this.lastClickTime = nowTime;
        this.emit('click', this, this.parent, pointer, event);
        return this;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        this.pointer = undefined;
        return this;
      }
    }, {
      key: "onOver",
      value: function onOver(pointer, localX, localY, event) {
        if (!this.enable) {
          return this;
        }

        this.emit('over', this, this.parent, pointer, event);
        return this;
      }
    }, {
      key: "onOut",
      value: function onOut(pointer, event) {
        if (!this.enable) {
          return this;
        }

        this.emit('out', this, this.parent, pointer, event);
        return this;
      }
    }]);

    return Button;
  }(ComponentBase);

  var CLICKMODE$1 = {
    press: 0,
    pointerdown: 0,
    release: 1,
    pointerup: 1
  };

  var ClickMethods = {
    onClick: function onClick(callback, scope, config) {
      if (!callback) {
        return this;
      }

      if (this._click === undefined) {
        this._click = new Button(this, config);
      }

      this._click.on('click', callback, scope);

      return this;
    },
    offClick: function offClick(callback, scope) {
      if (this._click === undefined) {
        return this;
      }

      this._click.off('click', callback, scope);

      return this;
    },
    enableClick: function enableClick(enabled) {
      if (this._click === undefined) {
        return this;
      }

      this._click.setEnable(enabled);

      return this;
    },
    disableClick: function disableClick() {
      if (this._click === undefined) {
        return this;
      }

      this._click.setEnable(false);

      return this;
    }
  };

  var GetValue$1l = Phaser.Utils.Objects.GetValue;

  var ClickOutside = /*#__PURE__*/function (_ComponentBase) {
    _inherits(ClickOutside, _ComponentBase);

    var _super = _createSuper(ClickOutside);

    function ClickOutside(gameObject, config) {
      var _this;

      _classCallCheck(this, ClickOutside);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;

      _this._enable = undefined;
      var inputConfig = GetValue$1l(config, "inputConfig", undefined);

      if (inputConfig) {
        gameObject.setInteractive(inputConfig);
      }

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(ClickOutside, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setEnable(GetValue$1l(o, "enable", true));
        this.setMode(GetValue$1l(o, "mode", 1));
        this.setClickInterval(GetValue$1l(o, "clickInterval", 100));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        var scene = this.parent.scene;
        scene.input.on('pointerdown', this.onPress, this);
        scene.input.on('pointerup', this.onRelease, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        var scene = this.parent.scene;
        scene.input.off('pointerdown', this.onPress, this);
        scene.input.off('pointerup', this.onRelease, this);

        _get(_getPrototypeOf(ClickOutside.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }

        this._enable = e;
        var eventName = e ? 'enable' : 'disable';
        this.emit(eventName, this, this.parent);
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "setMode",
      value: function setMode(m) {
        if (typeof m === 'string') {
          m = CLICKMODE[m];
        }

        this.mode = m;
        return this;
      }
    }, {
      key: "setClickInterval",
      value: function setClickInterval(interval) {
        this.clickInterval = interval; // ms

        return this;
      }
    }, {
      key: "isPointerInside",
      value: function isPointerInside(pointer) {
        var gameObject = this.parent;
        var isInsideCallback = gameObject.input ? IsPointerInHitArea : IsPointerInBounds;
        return isInsideCallback(gameObject, pointer);
      } // internal

    }, {
      key: "onPress",
      value: function onPress(pointer) {
        if (this.mode === 0) {
          // Do nothing if game object is not visible
          if (!this.parent.willRender(pointer.camera)) {
            return;
          }

          if (!this.isPointerInside(pointer)) {
            this.click(pointer.downTime, pointer);
          }
        }
      }
    }, {
      key: "onRelease",
      value: function onRelease(pointer) {
        if (this.mode === 1) {
          // Do nothing if game object is not visible
          if (!this.parent.willRender(pointer.camera)) {
            return;
          }

          if (!this.isPointerInside(pointer)) {
            this.click(pointer.upTime, pointer);
          }
        }
      }
    }, {
      key: "click",
      value: function click(nowTime, pointer) {
        if (!this.enable) {
          return this;
        }

        if (nowTime === undefined) {
          // fires 'clickoutside' event manually
          this.emit('clickoutside', this, this.parent, pointer);
          return this;
        }

        var lastClickTime = this.lastClickTime;

        if (lastClickTime !== undefined && nowTime - lastClickTime <= this.clickInterval) {
          return this;
        }

        this.lastClickTime = nowTime;
        this.emit('clickoutside', this, this.parent, pointer);
        return this;
      }
    }]);

    return ClickOutside;
  }(ComponentBase);

  var CLICKMODE = {
    press: 0,
    pointerdown: 0,
    release: 1,
    pointerup: 1
  };

  var ClickOutsideMethods = {
    onClickOutside: function onClickOutside(callback, scope, config) {
      if (!callback) {
        return this;
      }

      if (this._clickOutside === undefined) {
        this._clickOutside = new ClickOutside(this, config);
      }

      this._clickOutside.on('clickoutside', callback, scope);

      return this;
    },
    offClickOutside: function offClickOutside(callback, scope) {
      if (this._clickOutside === undefined) {
        return this;
      }

      this._clickOutside.off('clickoutside', callback, scope);

      return this;
    },
    enableClickOutside: function enableClickOutside(enabled) {
      if (this._clickOutside === undefined) {
        return this;
      }

      this._clickOutside.setEnable(enabled);

      return this;
    },
    disableClickOutside: function disableClickOutside() {
      if (this._clickOutside === undefined) {
        return this;
      }

      this._clickOutside.setEnable(false);

      return this;
    }
  };

  var FSM = /*#__PURE__*/function () {
    /*
    var config = {
        start: 'A',   // default: undefined
        states: {
            A: {
                next: 'B',  // function() { return 'B'; }
                enter: function() {},
                exit: function() {}
            },
            // ...
        },        
        extend: {
            i: 0,
            name: 'abc'
            // ...
        },
        init: function() {},
        enable: true,
        eventEmitter: true,
    };
    */
    function FSM(config) {
      _classCallCheck(this, FSM);

      // Attach get-next-state function
      var states = GetValue$2E(config, 'states', undefined);

      if (states) {
        this.addStates(states);
      } // Attach extend members


      var extend = GetValue$2E(config, 'extend', undefined);

      if (extend) {
        for (var name in extend) {
          if (!this.hasOwnProperty(name) || this[name] === undefined) {
            this[name] = extend[name];
          }
        }
      } // Event emitter


      var eventEmitter = GetValue$2E(config, 'eventEmitter', undefined);
      var EventEmitterClass = GetValue$2E(config, 'EventEmitterClass', undefined);
      this.setEventEmitter(eventEmitter, EventEmitterClass);
      this._stateLock = false;
      this.resetFromJSON(config);
    }

    _createClass(FSM, [{
      key: "shutdown",
      value: function shutdown() {
        this.destroyEventEmitter();
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.shutdown();
      }
    }, {
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setEnable(GetValue$2E(o, 'enable', true));
        this.start(GetValue$2E(o, 'start', undefined));
        var init = GetValue$2E(o, 'init', undefined);

        if (init) {
          init.call(this);
        }

        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          curState: this.state,
          prevState: this.prevState,
          enable: this.enable,
          start: this._start
        };
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "state",
      get: function get() {
        return this._state;
      },
      set: function set(newState) {
        if (!this.enable || this._stateLock) {
          return;
        }

        if (this._state === newState) {
          return;
        }

        this._prevState = this._state;
        this._state = newState;
        this._stateLock = true; // lock state

        this.emit('statechange', this);

        if (this._prevState != null) {
          var exitEventName = 'exit_' + this._prevState;
          var exitCallback = this[exitEventName];

          if (exitCallback) {
            exitCallback.call(this);
          }

          this.emit(exitEventName, this);
        }

        this._stateLock = false;

        if (this._state != null) {
          var enterEventName = 'enter_' + this._state;
          var enterCallback = this[enterEventName];

          if (enterCallback) {
            enterCallback.call(this);
          }

          this.emit(enterEventName, this);
        }
      }
    }, {
      key: "prevState",
      get: function get() {
        return this._prevState;
      }
    }, {
      key: "start",
      value: function start(state) {
        this._start = state;
        this._prevState = undefined;
        this._state = state; // Won't fire statechange events

        return this;
      }
    }, {
      key: "goto",
      value: function goto(nextState) {
        if (nextState != null) {
          this.state = nextState;
        }

        return this;
      }
    }, {
      key: "next",
      value: function next() {
        var nextState;
        var getNextState = this['next_' + this.state];

        if (getNextState) {
          if (typeof getNextState === 'string') {
            nextState = getNextState;
          } else {
            nextState = getNextState.call(this);
          }
        }

        this["goto"](nextState);
        return this;
      }
    }, {
      key: "addState",
      value: function addState(name, state) {
        if (typeof name !== 'string') {
          state = name;
          name = state.name;
        }

        var getNextStateCallback = state.next;

        if (getNextStateCallback) {
          this['next_' + name] = getNextStateCallback;
        }

        var exitCallback = state.exit;

        if (exitCallback) {
          this['exit_' + name] = exitCallback;
        }

        var enterCallback = state.enter;

        if (enterCallback) {
          this['enter_' + name] = enterCallback;
        }

        return this;
      }
    }, {
      key: "addStates",
      value: function addStates(states) {
        if (Array.isArray(states)) {
          for (var i = 0, cnt = states.length; i < cnt; i++) {
            this.addState(states[i]);
          }
        } else {
          for (var name in states) {
            this.addState(name, states[name]);
          }
        }

        return this;
      }
    }, {
      key: "runMethod",
      value: function runMethod(methodName, a1, a2, a3, a4, a5) {
        var fn = this[methodName + '_' + this.state];

        if (!fn) {
          return undefined;
        } // Copy from eventemitter3


        var len = arguments.length;

        switch (len) {
          case 1:
            return fn.call(this);

          case 2:
            return fn.call(this, a1);

          case 3:
            return fn.call(this, a1, a2);

          case 4:
            return fn.call(this, a1, a2, a3);

          case 5:
            return fn.call(this, a1, a2, a3, a4);

          case 6:
            return fn.call(this, a1, a2, a3, a4, a5);
        }

        var args = new Array(len - 1);

        for (var i = 1; i < len; i++) {
          args[i - 1] = arguments[i];
        }

        return fn.apply(this, args);
      }
    }, {
      key: "update",
      value: function update(time, delta) {
        this.runMethod('update', time, delta);
      }
    }, {
      key: "preupdate",
      value: function preupdate(time, delta) {
        this.runMethod('preupdate', time, delta);
      }
    }, {
      key: "postupdate",
      value: function postupdate(time, delta) {
        this.runMethod('postupdate', time, delta);
      }
    }]);

    return FSM;
  }();

  Object.assign(FSM.prototype, EventEmitterMethods);

  var Cooldown = /*#__PURE__*/function (_FSM) {
    _inherits(Cooldown, _FSM);

    var _super = _createSuper(Cooldown);

    function Cooldown() {
      var _this;

      _classCallCheck(this, Cooldown);

      _this = _super.call(this, {
        eventEmitter: false
      });

      _this["goto"]('IDLE');

      return _this;
    }

    _createClass(Cooldown, [{
      key: "setCooldownTime",
      value: function setCooldownTime(time) {
        this.cooldownTime = time;
        this.cooldownMode = time !== undefined;
        return this;
      }
    }, {
      key: "request",
      value: function request() {
        return this.runMethod('request');
      } // IDLE state

    }, {
      key: "update_IDLE",
      value: function update_IDLE() {
        this.compensationTime = 0;
      }
    }, {
      key: "request_IDLE",
      value: function request_IDLE() {
        this.next();
        return true;
      }
    }, {
      key: "next_IDLE",
      value: function next_IDLE() {
        if (this.cooldownMode) {
          return 'COOLDOWN';
        }
      } // COOLDOWN state

    }, {
      key: "enter_COOLDOWN",
      value: function enter_COOLDOWN() {
        this.remainderTime = this.cooldownTime + this.compensationTime;
      }
    }, {
      key: "update_COOLDOWN",
      value: function update_COOLDOWN(time, delta) {
        this.remainderTime -= delta;

        if (this.remainderTime < 0) {
          this.compensationTime = this.cooldownTime > delta ? -this.remainderTime : 0;
          this["goto"]('IDLE');
        }
      }
    }, {
      key: "request_COOLDOWN",
      value: function request_COOLDOWN() {
        return false;
      }
    }]);

    return Cooldown;
  }(FSM);

  var GetValue$1k = Phaser.Utils.Objects.GetValue;

  var InTouching = /*#__PURE__*/function (_ComponentBase) {
    _inherits(InTouching, _ComponentBase);

    var _super = _createSuper(InTouching);

    function InTouching(gameObject, config) {
      var _this;

      _classCallCheck(this, InTouching);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;

      _this._enable = undefined;
      _this.cooldown = new Cooldown();

      _this.parent.setInteractive(GetValue$1k(config, 'inputConfig', undefined));

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(InTouching, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.pointer = undefined;
        this.isInTouched = false;
        this.setEnable(GetValue$1k(o, 'enable', true));
        this.setCooldown(GetValue$1k(o, 'cooldown', undefined));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        var gameObject = this.parent;
        gameObject.on('pointerdown', this.onPointIn, this);
        gameObject.on('pointerover', this.onPointIn, this);
        gameObject.on('pointerup', this.onPointOut, this);
        gameObject.on('pointerout', this.onPointOut, this);
        this.scene.sys.events.on('preupdate', this.preupdate, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        } // GameObject events will be removed when this gameObject destroyed 
        // this.parent.off('pointerdown', this.onPointIn, this);
        // this.parent.off('pointerover', this.onPointIn, this);
        // this.parent.off('pointerup', this.onPointOut, this);
        // this.parent.off('pointerout', this.onPointOut, this);


        this.scene.sys.events.off('preupdate', this.preupdate, this);
        this.pointer = undefined;

        _get(_getPrototypeOf(InTouching.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }

        if (!e) {
          this.isInTouched = false;
          this.pointer = undefined;
        }

        this._enable = e;
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "cooldownTime",
      get: function get() {
        return this.cooldown.cooldownTime;
      },
      set: function set(time) {
        this.cooldown.setCooldownTime(time);
      }
    }, {
      key: "setCooldown",
      value: function setCooldown(time) {
        this.cooldownTime = time;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      } // internal

    }, {
      key: "onPointIn",
      value: function onPointIn(pointer, localX, localY) {
        if (!this.enable || !pointer.isDown || this.pointer !== undefined) {
          return;
        }

        this.pointer = pointer;
        this.isInTouched = true;
      }
    }, {
      key: "onPointOut",
      value: function onPointOut(pointer) {
        if (!this.enable || this.pointer !== pointer) {
          return;
        }

        this.pointer = undefined;
        this.isInTouched = false;
      }
    }, {
      key: "preupdate",
      value: function preupdate(time, delta) {
        this.cooldown.update(time, delta);

        if (this.isInTouched && this.cooldown.request()) {
          this.emit('intouch', this, this.parent, this.pointer);
        }
      }
    }]);

    return InTouching;
  }(ComponentBase);

  var TouchingMethods = {
    onTouching: function onTouching(callback, scope, config) {
      if (!callback) {
        return this;
      }

      if (this._inTouching === undefined) {
        this._inTouching = new InTouching(this, config);
      }

      this._inTouching.on('intouch', callback, scope);

      return this;
    },
    offTouching: function offTouching(callback, scope) {
      if (this._click === undefined) {
        return this;
      }

      this._inTouching.off('intouch', callback, scope);

      return this;
    }
  };

  var PointToChild = function PointToChild(parents, x, y) {
    var parent;

    for (var i = 0, cnt = parents.length; i < cnt; i++) {
      parent = parents[i];

      if (!ContainsPoint(parent, x, y)) {
        continue;
      }

      return parent.pointToChild(x, y);
    }

    return null;
  };

  var EmitChildEvent = function EmitChildEvent(eventEmitter, eventName, parents, x, y, pointer, event) {
    var child;

    if (y === undefined) {
      child = x;
    } else {
      child = PointToChild(parents, x, y);
    }

    if (!child) {
      return;
    }

    eventEmitter.emit(eventName, child, pointer, event);
  };

  var GetValue$1j = Phaser.Utils.Objects.GetValue;

  var ClickChild = function ClickChild(config) {
    var clickConfig = GetValue$1j(config, 'click', undefined);

    if (clickConfig === false) {
      return;
    }

    if (clickConfig === undefined) {
      clickConfig = {};
    }

    if (!clickConfig.hasOwnProperty('threshold')) {
      clickConfig.threshold = 10;
    }

    var childrenInteractive = this._childrenInteractive;
    this._click = new Button(this, clickConfig);

    this._click.on('click', function (button, gameObject, pointer, event) {
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "click"), childrenInteractive.targetSizers, pointer.worldX, pointer.worldY, pointer, event);
    }, this);
  };

  var GetValue$1i = Phaser.Utils.Objects.GetValue;

  var OverChild = function OverChild(config) {
    var overConfig = GetValue$1i(config, 'over', undefined);

    if (overConfig === false) {
      return;
    }

    this.on('pointermove', OnMove$1, this).on('pointerover', OnMove$1, this).on('pointerout', OnOut$1, this); // pointer-up is included too
  };

  var OnMove$1 = function OnMove(pointer, localX, localY, event) {
    var childrenInteractive = this._childrenInteractive;
    var child = PointToChild(childrenInteractive.targetSizers, pointer.worldX, pointer.worldY);
    var preChild = childrenInteractive.lastOverChild;

    if (child && preChild && child === preChild) {
      return;
    }

    childrenInteractive.lastOverChild = child;
    EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "out"), childrenInteractive.targetSizers, preChild, undefined, pointer, event);
    EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "over"), childrenInteractive.targetSizers, child, undefined, pointer, event);
  };

  var OnOut$1 = function OnOut(pointer, event) {
    var childrenInteractive = this._childrenInteractive;
    var child = childrenInteractive.lastOverChild;
    childrenInteractive.lastOverChild = null;
    EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "out"), childrenInteractive.targetSizers, child, undefined, pointer, event);
  };

  var GetValue$1h = Phaser.Utils.Objects.GetValue;

  var OnePointerTracer = /*#__PURE__*/function (_TickTask) {
    _inherits(OnePointerTracer, _TickTask);

    var _super = _createSuper(OnePointerTracer);

    function OnePointerTracer(gameObject, config) {
      var _this;

      _classCallCheck(this, OnePointerTracer);

      var scene = GetSceneObject(gameObject);

      if (scene === gameObject) {
        gameObject = undefined;
      }

      _this = _super.call(this, scene, config);
      _this.gameObject = gameObject;

      if (gameObject) {
        gameObject.setInteractive(GetValue$1h(config, "inputConfig", undefined));
      }

      _this._enable = undefined;

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(OnePointerTracer, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setEnable(GetValue$1h(o, 'enable', true));
        this.setDetectBounds();

        if (this.gameObject === undefined) {
          this.setDetectBounds(GetValue$1h(o, 'bounds', undefined));
        } else {
          this.setDetectBounds();
        }

        this.tracerState = TOUCH0$2; // this.recongizedState = new stateClass(this);

        this.pointer = undefined;
        this.lastPointer = undefined; // Last catched pointer

        this.movedState = false;
        this.isTouchingAnyObject = false;
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        _get(_getPrototypeOf(OnePointerTracer.prototype), "boot", this).call(this);

        if (this.gameObject) {
          this.gameObject.on('pointerdown', this.onPointerDown, this);
        } else {
          this.scene.input.on('pointerdown', this.onPointerDown, this);
        }

        this.scene.input.on('pointerup', this.onPointerUp, this);
        this.scene.input.on('gameout', this.dragCancel, this);
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.sys.events.once('shutdown', this.destroy, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        if (!this.scene) {
          return;
        }

        if (this.gameObject) ; else {
          this.scene.input.off('pointerdown', this.onPointerDown, this);
        }

        this.scene.input.off('pointerup', this.onPointerUp, this);
        this.scene.input.off('gameout', this.dragCancel, this);
        this.scene.input.off('pointermove', this.onPointerMove, this);
        this.scene.sys.events.off('shutdown', this.destroy, this);
        this.gameObject = undefined;
        this.bounds = undefined;
        this.pointer = undefined;
        this.lastPointer = undefined; // Last catched pointer

        this.movedState = false;

        _get(_getPrototypeOf(OnePointerTracer.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }

        if (!e) {
          this.dragCancel();
        }

        this._enable = e;
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "setDetectBounds",
      value: function setDetectBounds(bounds) {
        this.bounds = bounds;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "onPointerDown",
      value: function onPointerDown(pointer, gameObjects) {
        if (!this.enable) {
          return;
        }

        if (this.pointer !== undefined) {
          return;
        }

        var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;

        if (!isInsideBounds) {
          return;
        }

        if (this.pointer === pointer) {
          return;
        }

        this.pointer = pointer;
        this.lastPointer = pointer;
        this.movedState = false;
        this.tracerState = TOUCH1$2;

        if (this.gameObject === undefined) {
          this.isTouchingAnyObject = gameObjects.length > 0;
        }

        this.onDragStart();
      }
    }, {
      key: "onPointerUp",
      value: function onPointerUp(pointer) {
        if (!this.enable) {
          return;
        }

        var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;

        if (!isInsideBounds) {
          return;
        }

        if (this.pointer !== pointer) {
          return;
        }

        this.pointer = undefined;
        this.movedState = false;
        this.tracerState = TOUCH0$2;
        this.onDragEnd();
      }
    }, {
      key: "onPointerMove",
      value: function onPointerMove(pointer) {
        if (!this.enable) {
          return;
        }

        if (pointer.isDown) {
          var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
          var isCatchedPointer = this.pointer === pointer;

          if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) {
            // Pointer moves out of bounds
            this.onPointerUp(pointer);
          } else {
            // Pointer drags in bounds
            if (!this.movedState) {
              this.movedState = pointer.x !== pointer.downX || pointer.y !== pointer.downY;
            }

            if (this.movedState) {
              this.onDrag();
            }
          }
        }
      }
    }, {
      key: "dragCancel",
      value: function dragCancel() {
        if (this.tracerState === TOUCH1$2) {
          this.onDragEnd();
        }

        this.pointer = undefined;
        this.tracerState = TOUCH0$2;
        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        this.emit('dragstart', this);
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        this.emit('dragend', this);
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        this.emit('drag', this);
      } // onLastPointerMove() { }

    }, {
      key: "preUpdate",
      value: function preUpdate(time, delta) {}
    }, {
      key: "postUpdate",
      value: function postUpdate(time, delta) {}
    }, {
      key: "startTicking",
      value: function startTicking() {
        _get(_getPrototypeOf(OnePointerTracer.prototype), "startTicking", this).call(this);

        this.scene.sys.events.on('preupdate', this.preUpdate, this);
        this.scene.sys.events.on('postupdate', this.postUpdate, this);
      }
    }, {
      key: "stopTicking",
      value: function stopTicking() {
        _get(_getPrototypeOf(OnePointerTracer.prototype), "stopTicking", this).call(this);

        if (this.scene) {
          // Scene might be destoryed
          this.scene.sys.events.off('preupdate', this.preUpdate, this);
          this.scene.sys.events.off('postupdate', this.postUpdate, this);
        }
      }
    }, {
      key: "setRecongizedStateObject",
      value: function setRecongizedStateObject(stateObject) {
        this.recongizedState = stateObject;
        return this;
      }
    }, {
      key: "state",
      get: function get() {
        return this.recongizedState.state;
      },
      set: function set(newState) {
        this.recongizedState.state = newState;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        this.state = IDLE$7;
        return this;
      }
    }]);

    return OnePointerTracer;
  }(TickTask);

  var TOUCH0$2 = 0;
  var TOUCH1$2 = 1;
  var IDLE$7 = 'IDLE';

  var GetValue$1g = Phaser.Utils.Objects.GetValue;
  var DistanceBetween$5 = Phaser.Math.Distance.Between;

  var Tap = /*#__PURE__*/function (_OnePointerTracer) {
    _inherits(Tap, _OnePointerTracer);

    var _super = _createSuper(Tap);

    function Tap(gameObject, config) {
      var _this;

      _classCallCheck(this, Tap);

      _this = _super.call(this, gameObject, config);

      var self = _assertThisInitialized(_this);

      var stateConfig = {
        states: {
          IDLE: {
            enter: function enter() {
              self.stop();
              self.tapsCount = 0;
              self.x = 0;
              self.y = 0;
              self.worldX = 0;
              self.worldY = 0;
            },
            exit: function exit() {
              var pointer = self.lastPointer;
              self.x = pointer.x;
              self.y = pointer.y;
              self.worldX = pointer.worldX;
              self.worldY = pointer.worldY;
            }
          },
          BEGIN: {
            enter: function enter() {
              self.start();
              self.tapsCount = 0;
              self.emit('tappingstart', self, self.gameObject, self.lastPointer);
            }
          },
          RECOGNIZED: {
            enter: function enter() {
              self.start();
              self.emit('tap', self, self.gameObject, self.lastPointer);
              self.emit("".concat(self.tapsCount, "tap"), self, self.gameObject, self.lastPointer);
            }
          }
        },
        init: function init() {
          this.state = IDLE$6;
        },
        eventEmitter: false
      };

      _this.setRecongizedStateObject(new FSM(stateConfig));

      return _this;
    }

    _createClass(Tap, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Tap.prototype), "resetFromJSON", this).call(this, o);

        this.setHoldTime(GetValue$1g(o, 'time', 250)); // min-hold-time of Press is 251

        this.setTapInterval(GetValue$1g(o, 'tapInterval', 200));
        this.setDragThreshold(GetValue$1g(o, 'threshold', 9));
        this.setTapOffset(GetValue$1g(o, 'tapOffset', 10));
        var taps = GetValue$1g(o, 'taps', undefined);

        if (taps !== undefined) {
          this.setTaps(taps);
        } else {
          this.setMaxTaps(GetValue$1g(o, 'maxTaps', undefined));
          this.setMinTaps(GetValue$1g(o, 'minTaps', undefined));
        }

        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        switch (this.state) {
          case IDLE$6:
            this.state = BEGIN$5;
            break;

          case BEGIN$5:
            var pointer = this.lastPointer;
            var tapsOffset = DistanceBetween$5(pointer.upX, pointer.upY, pointer.x, pointer.y);

            if (tapsOffset > this.tapOffset) {
              // Can't recognize next level, restart here
              this.state = RECOGNIZED$5;
              this.state = BEGIN$5;
            }

            break;

          case RECOGNIZED$5:
            this.state = BEGIN$5;
            break;
        }
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        if (this.state === BEGIN$5) {
          this.tapsCount++; // Try recognize next level

          this.emit('tapping', this, this.gameObject, this.lastPointer);

          if (this.maxTaps !== undefined && this.tapsCount === this.maxTaps) {
            // Reach to maxTaps, stop here                
            this.state = RECOGNIZED$5;
          }
        }
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        if (this.state === IDLE$6) {
          return;
        }

        if (this.pointer.getDistance() > this.dragThreshold) {
          // Cancel
          this.state = IDLE$6;
        }
      }
    }, {
      key: "preUpdate",
      value: function preUpdate(time, delta) {
        if (!this.isRunning || !this.enable) {
          return;
        }

        if (this.state === BEGIN$5) {
          var pointer = this.lastPointer;

          if (pointer.isDown) {
            var holdTime = time - pointer.downTime;

            if (holdTime > this.holdTime) {
              this.state = IDLE$6;
            }
          } else {
            // isUp
            var releasedTime = time - pointer.upTime;

            if (releasedTime > this.tapInterval) {
              if (this.minTaps === undefined || this.tapsCount >= this.minTaps) {
                this.state = RECOGNIZED$5;
              } else {
                this.state = IDLE$6;
              }
            }
          }
        }
      }
    }, {
      key: "postUpdate",
      value: function postUpdate(time, delta) {
        if (!this.isRunning || !this.enable) {
          return;
        } // Clear RECOGNIZED after update()


        if (this.state === RECOGNIZED$5) {
          this.state = IDLE$6;
        }
      }
    }, {
      key: "isTapped",
      get: function get() {
        return this.state === RECOGNIZED$5;
      }
    }, {
      key: "setHoldTime",
      value: function setHoldTime(time) {
        this.holdTime = time; // ms

        return this;
      }
    }, {
      key: "setTapInterval",
      value: function setTapInterval(time) {
        this.tapInterval = time; // ms

        return this;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }, {
      key: "setTapOffset",
      value: function setTapOffset(distance) {
        this.tapOffset = distance;
        return this;
      }
    }, {
      key: "setMaxTaps",
      value: function setMaxTaps(taps) {
        this.maxTaps = taps;
        return this;
      }
    }, {
      key: "setMinTaps",
      value: function setMinTaps(taps) {
        this.minTaps = taps;
        return this;
      }
    }, {
      key: "setTaps",
      value: function setTaps(minTaps, maxTaps) {
        if (maxTaps === undefined) {
          maxTaps = minTaps;
        }

        this.setMinTaps(minTaps).setMaxTaps(maxTaps);
        return this;
      }
    }]);

    return Tap;
  }(OnePointerTracer);

  var IDLE$6 = 'IDLE';
  var BEGIN$5 = 'BEGIN';
  var RECOGNIZED$5 = 'RECOGNIZED';

  var GetValue$1f = Phaser.Utils.Objects.GetValue;

  var Press = /*#__PURE__*/function (_OnePointerTracer) {
    _inherits(Press, _OnePointerTracer);

    var _super = _createSuper(Press);

    function Press(gameObject, config) {
      var _this;

      _classCallCheck(this, Press);

      _this = _super.call(this, gameObject, config);

      var self = _assertThisInitialized(_this);

      var stateConfig = {
        states: {
          IDLE: {
            enter: function enter() {
              self.x = 0;
              self.y = 0;
              self.worldX = 0;
              self.worldY = 0;
            },
            exit: function exit() {
              var pointer = self.lastPointer;
              self.x = pointer.x;
              self.y = pointer.y;
              self.worldX = pointer.worldX;
              self.worldY = pointer.worldY;
            }
          },
          BEGIN: {
            enter: function enter() {
              self.start();
            },
            exit: function exit() {
              self.stop();
            }
          },
          RECOGNIZED: {
            enter: function enter() {
              self.emit('pressstart', self, self.gameObject, self.lastPointer);
            },
            exit: function exit() {
              self.emit('pressend', self, self.gameObject, self.lastPointer);
            }
          }
        },
        init: function init() {
          this.state = IDLE$5;
        },
        eventEmitter: false
      };

      _this.setRecongizedStateObject(new FSM(stateConfig));

      return _this;
    }

    _createClass(Press, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Press.prototype), "resetFromJSON", this).call(this, o);

        this.setDragThreshold(GetValue$1f(o, 'threshold', 9));
        this.setHoldTime(GetValue$1f(o, 'time', 251));
        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        this.state = BEGIN$4;

        if (this.holdTime === 0) {
          this.state = RECOGNIZED$4;
        }
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        this.state = IDLE$5;
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        if (this.state === IDLE$5) {
          return;
        }

        if (this.pointer.getDistance() > this.dragThreshold) {
          this.state = IDLE$5;
        }
      }
    }, {
      key: "preUpdate",
      value: function preUpdate(time, delta) {
        if (!this.isRunning || !this.enable) {
          return;
        }

        if (this.state === BEGIN$4) {
          var holdTime = time - this.pointer.downTime;

          if (holdTime >= this.holdTime) {
            this.state = RECOGNIZED$4;
          }
        }
      }
    }, {
      key: "isPressed",
      get: function get() {
        return this.state === RECOGNIZED$4;
      }
    }, {
      key: "setHoldTime",
      value: function setHoldTime(time) {
        this.holdTime = time; // ms

        return this;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }]);

    return Press;
  }(OnePointerTracer);

  var IDLE$5 = 'IDLE';
  var BEGIN$4 = 'BEGIN';
  var RECOGNIZED$4 = 'RECOGNIZED';

  var GetValue$1e = Phaser.Utils.Objects.GetValue;

  var Pan = /*#__PURE__*/function (_OnePointerTracer) {
    _inherits(Pan, _OnePointerTracer);

    var _super = _createSuper(Pan);

    function Pan(gameObject, config) {
      var _this;

      _classCallCheck(this, Pan);

      _this = _super.call(this, gameObject, config);

      var self = _assertThisInitialized(_this);

      var stateConfig = {
        states: {
          IDLE: {},
          BEGIN: {
            enter: function enter() {
              var pointer = self.pointer;
              self.startX = pointer.x;
              self.startY = pointer.y;
              self.startWorldX = pointer.worldX;
              self.startWorldY = pointer.worldY;
            }
          },
          RECOGNIZED: {
            enter: function enter() {
              self.emit('panstart', self, self.gameObject, self.lastPointer);
            },
            exit: function exit() {
              var pointer = self.lastPointer;
              self.endX = pointer.x;
              self.endY = pointer.y;
              self.endWorldX = pointer.worldX;
              self.endWorldY = pointer.worldY;
              self.emit('panend', self, self.gameObject, self.lastPointer);
            }
          }
        },
        init: function init() {
          this.state = IDLE$4;
        },
        eventEmitter: false
      };

      _this.setRecongizedStateObject(new FSM(stateConfig));

      return _this;
    }

    _createClass(Pan, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Pan.prototype), "resetFromJSON", this).call(this, o);

        this.setDragThreshold(GetValue$1e(o, 'threshold', 10));
        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        this.state = BEGIN$3;

        if (this.dragThreshold === 0) {
          this.state = RECOGNIZED$3;
        }
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        this.state = IDLE$4;
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        switch (this.state) {
          case BEGIN$3:
            if (this.pointer.getDistance() >= this.dragThreshold) {
              this.state = RECOGNIZED$3;
            }

            break;

          case RECOGNIZED$3:
            var p1 = this.pointer.position;
            var p0 = this.pointer.prevPosition;
            this.dx = p1.x - p0.x;
            this.dy = p1.y - p0.y;
            var pointer = this.pointer;
            this.x = pointer.x;
            this.y = pointer.y;
            this.worldX = pointer.worldX;
            this.worldY = pointer.worldY;
            this.emit('pan', this, this.gameObject, this.lastPointer);
            break;
        }
      }
    }, {
      key: "isPanned",
      get: function get() {
        return this.state === RECOGNIZED$3;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }]);

    return Pan;
  }(OnePointerTracer);

  var IDLE$4 = 'IDLE';
  var BEGIN$3 = 'BEGIN';
  var RECOGNIZED$3 = 'RECOGNIZED';

  var DistanceBetween$4 = Phaser.Math.Distance.Between;
  var AngleBetween$1 = Phaser.Math.Angle.Between;
  var VelocityMethods = {
    getDt: function getDt() {
      var game = this.scene.sys.game;
      var dt = game.loop.delta;
      return dt;
    },
    getVelocity: function getVelocity() {
      var p1 = this.pointer.position;
      var p0 = this.pointer.prevPosition;
      var d = DistanceBetween$4(p0.x, p0.y, p1.x, p1.y);
      var velocity = d / (this.getDt() * 0.001);
      return velocity;
    },
    getVelocityX: function getVelocityX() {
      var p1 = this.pointer.position;
      var p0 = this.pointer.prevPosition;
      var d = Math.abs(p1.x - p0.x);
      var velocity = d / (this.getDt() * 0.001);
      return velocity;
    },
    getVelocityY: function getVelocityY() {
      var p1 = this.pointer.position;
      var p0 = this.pointer.prevPosition;
      var d = Math.abs(p1.y - p0.y);
      var velocity = d / (this.getDt() * 0.001);
      return velocity;
    },
    getVelocityAngle: function getVelocityAngle() {
      var p1 = this.pointer.position;
      var p0 = this.pointer.prevPosition;
      var angle = AngleBetween$1(p0.x, p0.y, p1.x, p1.y);
      return angle;
    }
  };

  var DIRMODE = {
    'up&down': 0,
    'left&right': 1,
    '4dir': 2,
    '8dir': 3
  };

  var AngleToDirections = function AngleToDirections(angle, dirMode, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = globOut;
    }

    out.left = false;
    out.right = false;
    out.up = false;
    out.down = false;
    angle = (angle + 360) % 360;

    switch (dirMode) {
      case 0:
        // up & down
        if (angle < 180) {
          out.down = true;
        } else {
          out.up = true;
        }

        break;

      case 1:
        // left & right
        if (angle > 90 && angle <= 270) {
          out.left = true;
        } else {
          out.right = true;
        }

        break;

      case 2:
        // 4 dir
        if (angle > 45 && angle <= 135) {
          out.down = true;
        } else if (angle > 135 && angle <= 225) {
          out.left = true;
        } else if (angle > 225 && angle <= 315) {
          out.up = true;
        } else {
          out.right = true;
        }

        break;

      case 3:
        // 8 dir
        if (angle > 22.5 && angle <= 67.5) {
          out.down = true;
          out.right = true;
        } else if (angle > 67.5 && angle <= 112.5) {
          out.down = true;
        } else if (angle > 112.5 && angle <= 157.5) {
          out.down = true;
          out.left = true;
        } else if (angle > 157.5 && angle <= 202.5) {
          out.left = true;
        } else if (angle > 202.5 && angle <= 247.5) {
          out.left = true;
          out.up = true;
        } else if (angle > 247.5 && angle <= 292.5) {
          out.up = true;
        } else if (angle > 292.5 && angle <= 337.5) {
          out.up = true;
          out.right = true;
        } else {
          out.right = true;
        }

        break;
    }

    return out;
  };

  var globOut = {};

  var GetValue$1d = Phaser.Utils.Objects.GetValue;
  var RadToDeg$2 = Phaser.Math.RadToDeg;

  var Swipe = /*#__PURE__*/function (_OnePointerTracer) {
    _inherits(Swipe, _OnePointerTracer);

    var _super = _createSuper(Swipe);

    function Swipe(gameObject, config) {
      var _this;

      _classCallCheck(this, Swipe);

      _this = _super.call(this, gameObject, config);

      var self = _assertThisInitialized(_this);

      var stateConfig = {
        states: {
          IDLE: {
            enter: function enter() {
              self.x = 0;
              self.y = 0;
              self.worldX = 0;
              self.worldY = 0;
            },
            exit: function exit() {
              var pointer = self.lastPointer;
              self.x = pointer.x;
              self.y = pointer.y;
              self.worldX = pointer.worldX;
              self.worldY = pointer.worldY;
            }
          },
          BEGIN: {
            enter: function enter() {
              self.validDrag = false;
            }
          },
          RECOGNIZED: {
            enter: function enter() {
              self.start();
              self.updateDirectionStates();
              self.emit('swipe', self, self.gameObject, self.lastPointer);
            },
            exit: function exit() {
              self.stop();
              self.clearDirectionStates();
            }
          }
        },
        init: function init() {
          this.state = IDLE$3;
        },
        eventEmitter: false
      };

      _this.setRecongizedStateObject(new FSM(stateConfig));

      _this.clearDirectionStates();

      return _this;
    }

    _createClass(Swipe, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Swipe.prototype), "resetFromJSON", this).call(this, o);

        this.setDragThreshold(GetValue$1d(o, 'threshold', 10));
        this.setVelocityThreshold(GetValue$1d(o, 'velocityThreshold', 1000));
        this.setDirectionMode(GetValue$1d(o, 'dir', '8dir'));
        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart() {
        this.state = BEGIN$2;
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        this.state = IDLE$3;
      }
    }, {
      key: "onDrag",
      value: function onDrag() {
        if (this.state === BEGIN$2) {
          if (!this.validDrag) {
            this.validDrag = this.dragThreshold === 0 || this.pointer.getDistance() >= this.dragThreshold;
          }

          if (this.validDrag && this.dragVelocity > this.velocityThreshold) {
            this.state = RECOGNIZED$2;
          }
        }
      }
    }, {
      key: "postUpdate",
      value: function postUpdate(time, delta) {
        if (!this.isRunning || !this.enable) {
          return;
        } // Clear RECOGNIZED after update()


        if (this.state === RECOGNIZED$2) {
          this.state = IDLE$3;
        }
      }
    }, {
      key: "isSwiped",
      get: function get() {
        return this.state === RECOGNIZED$2;
      }
    }, {
      key: "dragVelocity",
      get: function get() {
        var velocity;

        switch (this.dirMode) {
          case 0:
            velocity = this.getVelocityY();
            break;
          // up & down

          case 1:
            velocity = this.getVelocityX();
            break;
          // left & right

          default:
            velocity = this.getVelocity();
            break;
          // 4 dir, 8 dir
        }

        return velocity;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }, {
      key: "setVelocityThreshold",
      value: function setVelocityThreshold(velocity) {
        this.velocityThreshold = velocity;
        return this;
      }
    }, {
      key: "setDirectionMode",
      value: function setDirectionMode(m) {
        if (typeof m === 'string') {
          m = DIRMODE[m];
        }

        this.dirMode = m;
        return this;
      }
    }, {
      key: "updateDirectionStates",
      value: function updateDirectionStates() {
        var angle = RadToDeg$2(this.getVelocityAngle());
        AngleToDirections(angle, this.dirMode, this);
        return this;
      }
    }, {
      key: "clearDirectionStates",
      value: function clearDirectionStates() {
        this.left = false;
        this.right = false;
        this.up = false;
        this.down = false;
        return this;
      }
    }]);

    return Swipe;
  }(OnePointerTracer);

  Object.assign(Swipe.prototype, VelocityMethods);
  var IDLE$3 = 'IDLE';
  var BEGIN$2 = 'BEGIN';
  var RECOGNIZED$2 = 'RECOGNIZED';

  var GetValue$1c = Phaser.Utils.Objects.GetValue;
  var SpliceOne$1 = Phaser.Utils.Array.SpliceOne;
  var DistanceBetween$3 = Phaser.Math.Distance.Between;
  var AngleBetween = Phaser.Math.Angle.Between;

  var TwoPointersTracer = /*#__PURE__*/function () {
    function TwoPointersTracer(scene, config) {
      _classCallCheck(this, TwoPointersTracer);

      var amount = scene.input.manager.pointersTotal - 1;

      if (amount < 2) {
        scene.input.addPointer(2 - amount);
      }

      this.scene = scene; // Event emitter

      this.setEventEmitter(GetValue$1c(config, 'eventEmitter', undefined));
      this._enable = undefined;
      this.pointers = [];
      this.movedState = {};
      this.resetFromJSON(config);
      this.boot();
    }

    _createClass(TwoPointersTracer, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setEnable(GetValue$1c(o, "enable", true));
        this.bounds = GetValue$1c(o, 'bounds', undefined);
        this.tracerState = TOUCH0$1;
        this.pointers.length = 0;
        Clear(this.movedState);
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        this.scene.input.on('pointerdown', this.onPointerDown, this);
        this.scene.input.on('pointerup', this.onPointerUp, this);
        this.scene.input.on('gameout', this.dragCancel, this);
        this.scene.input.on('pointermove', this.onPointerMove, this);
        this.scene.sys.events.once('shutdown', this.destroy, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown() {
        if (!this.scene) {
          return;
        }

        this.destroyEventEmitter();
        this.pointers.length = 0;
        Clear(this.movedState);
        this.scene.input.off('pointerdown', this.onPointerDown, this);
        this.scene.input.off('pointerup', this.onPointerUp, this);
        this.scene.input.off('gameout', this.dragCancel, this);
        this.scene.input.off('pointermove', this.onPointerMove, this);
        this.scene.sys.events.off('shutdown', this.destroy, this);
        this.scene = undefined;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.shutdown();
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }

        if (!e) {
          this.dragCancel();
        }

        this._enable = e;
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "onPointerDown",
      value: function onPointerDown(pointer) {
        if (!this.enable) {
          return;
        }

        if (this.pointers.length === 2) {
          return;
        }

        var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;

        if (!isInsideBounds) {
          return;
        }

        var index = this.pointers.indexOf(pointer);

        if (index !== -1) {
          // Already in catched pointers
          return;
        }

        this.movedState[pointer.id] = false;
        this.pointers.push(pointer);

        switch (this.tracerState) {
          case TOUCH0$1:
            this.tracerState = TOUCH1$1;
            this.onDrag1Start();
            break;

          case TOUCH1$1:
            this.tracerState = TOUCH2;
            this.onDrag2Start();
            break;
        }
      }
    }, {
      key: "onPointerUp",
      value: function onPointerUp(pointer) {
        if (!this.enable) {
          return;
        }

        var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;

        if (!isInsideBounds) {
          return;
        }

        var index = this.pointers.indexOf(pointer);

        if (index === -1) {
          // Not in catched pointers
          return;
        } else {
          delete this.movedState[pointer.id];
          SpliceOne$1(this.pointers, index);
        }

        switch (this.tracerState) {
          case TOUCH1$1:
            this.tracerState = TOUCH0$1;
            this.onDrag1End();
            break;

          case TOUCH2:
            this.tracerState = TOUCH1$1;
            this.onDrag2End();
            this.onDrag1Start();
            break;
        }
      }
    }, {
      key: "onPointerMove",
      value: function onPointerMove(pointer) {
        if (!this.enable) {
          return;
        }

        if (pointer.isDown) {
          var isInsideBounds = this.bounds ? this.bounds.contains(pointer.x, pointer.y) : true;
          var isCatchedPointer = this.pointers.indexOf(pointer) !== -1;

          if (!isCatchedPointer && isInsideBounds) ; else if (isCatchedPointer && !isInsideBounds) {
            // Pointer moves out of bounds, lose pointer
            this.onPointerUp(pointer);
          } else {
            // Pointer drags in bounds
            if (!this.movedState[pointer.id]) {
              this.movedState[pointer.id] = pointer.x !== pointer.downX || pointer.y !== pointer.downY;
            }

            if (this.movedState[pointer.id]) {
              switch (this.tracerState) {
                case TOUCH1$1:
                  this.onDrag1();
                  break;

                case TOUCH2:
                  this.onDrag2();
                  break;
              }
            }
          }
        }
      }
    }, {
      key: "dragCancel",
      value: function dragCancel() {
        if (this.tracerState === TOUCH2) {
          this.onDrag2End();
        }

        this.pointers.length = 0;
        Clear(this.movedState);
        this.tracerState = TOUCH0$1;
        return this;
      }
    }, {
      key: "onDrag1Start",
      value: function onDrag1Start() {
        this.emit('drag1start', this);
      }
    }, {
      key: "onDrag1End",
      value: function onDrag1End() {
        this.emit('drag1end', this);
      }
    }, {
      key: "onDrag1",
      value: function onDrag1() {
        this.emit('drag1', this);
      }
    }, {
      key: "onDrag2Start",
      value: function onDrag2Start() {
        this.emit('drag2start', this);
      }
    }, {
      key: "onDrag2End",
      value: function onDrag2End() {
        this.emit('drag2end', this);
      }
    }, {
      key: "onDrag2",
      value: function onDrag2() {
        this.emit('drag2', this);
      }
    }, {
      key: "distanceBetween",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }

        var p0 = this.pointers[0],
            p1 = this.pointers[1];
        return DistanceBetween$3(p0.x, p0.y, p1.x, p1.y);
      }
    }, {
      key: "angleBetween",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }

        var p0 = this.pointers[0],
            p1 = this.pointers[1];
        return AngleBetween(p0.x, p0.y, p1.x, p1.y);
      }
    }, {
      key: "drag1Vector",
      get: function get() {
        var pointer = this.pointers[0];

        if (pointer && this.movedState[pointer.id]) {
          var p1 = pointer.position;
          var p0 = pointer.prevPosition;
          tmpDragVector.x = p1.x - p0.x;
          tmpDragVector.y = p1.y - p0.y;
        } else {
          tmpDragVector.x = 0;
          tmpDragVector.y = 0;
        }

        return tmpDragVector;
      }
    }, {
      key: "centerX",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }

        var p0 = this.pointers[0].position;
        var p1 = this.pointers[1].position;
        return (p0.x + p1.x) / 2;
      }
    }, {
      key: "centerY",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }

        var p0 = this.pointers[0].position;
        var p1 = this.pointers[1].position;
        return (p0.y + p1.y) / 2;
      }
    }, {
      key: "prevCenterX",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }

        var preP0 = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position;
        var preP1 = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position;
        return (preP0.x + preP1.x) / 2;
      }
    }, {
      key: "prevCenterY",
      get: function get() {
        if (this.tracerState !== TOUCH2) {
          return 0;
        }

        var preP0 = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position;
        var preP1 = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position;
        return (preP0.y + preP1.y) / 2;
      }
    }, {
      key: "movementCenterX",
      get: function get() {
        return this.centerX - this.prevCenterX;
      }
    }, {
      key: "movementCenterY",
      get: function get() {
        return this.centerY - this.prevCenterY;
      }
    }, {
      key: "setRecongizedStateObject",
      value: function setRecongizedStateObject(stateObject) {
        this.recongizedState = stateObject;
        return this;
      }
    }, {
      key: "state",
      get: function get() {
        return this.recongizedState.state;
      },
      set: function set(newState) {
        this.recongizedState.state = newState;
      }
    }, {
      key: "cancel",
      value: function cancel() {
        this.state = IDLE$2;
        return this;
      }
    }]);

    return TwoPointersTracer;
  }();

  Object.assign(TwoPointersTracer.prototype, EventEmitterMethods);
  var tmpDragVector = {};
  var TOUCH0$1 = 0;
  var TOUCH1$1 = 1;
  var TOUCH2 = 2;
  var IDLE$2 = 'IDLE';

  var GetValue$1b = Phaser.Utils.Objects.GetValue;

  var Pinch = /*#__PURE__*/function (_TwoPointersTracer) {
    _inherits(Pinch, _TwoPointersTracer);

    var _super = _createSuper(Pinch);

    function Pinch(scene, config) {
      var _this;

      _classCallCheck(this, Pinch);

      _this = _super.call(this, scene, config);

      var self = _assertThisInitialized(_this);

      var stateConfig = {
        states: {
          IDLE: {
            enter: function enter() {
              self.prevDistance = undefined;
              self.scaleFactor = 1;
            }
          },
          BEGIN: {},
          RECOGNIZED: {
            enter: function enter() {
              self.emit('pinchstart', self);
            },
            exit: function exit() {
              self.emit('pinchend', self);
            }
          }
        },
        init: function init() {
          this.state = IDLE$1;
        },
        eventEmitter: false
      };

      _this.setRecongizedStateObject(new FSM(stateConfig));

      return _this;
    }

    _createClass(Pinch, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Pinch.prototype), "resetFromJSON", this).call(this, o);

        this.setDragThreshold(GetValue$1b(o, 'threshold', 0));
        return this;
      }
    }, {
      key: "onDrag2Start",
      value: function onDrag2Start() {
        this.scaleFactor = 1;
        this.prevDistance = this.distanceBetween;
        this.state = BEGIN$1;

        if (this.dragThreshold === 0) {
          this.state = RECOGNIZED$1;
        }
      }
    }, {
      key: "onDrag2End",
      value: function onDrag2End() {
        this.state = IDLE$1;
      }
    }, {
      key: "onDrag2",
      value: function onDrag2() {
        switch (this.state) {
          case BEGIN$1:
            if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) {
              var curDistance = this.distanceBetween;
              this.scaleFactor = curDistance / this.prevDistance;
              this.prevDistance = curDistance;
              this.state = RECOGNIZED$1;
            }

            break;

          case RECOGNIZED$1:
            var curDistance = this.distanceBetween;
            this.scaleFactor = curDistance / this.prevDistance;
            this.emit('pinch', this);
            this.prevDistance = curDistance;
            break;
        }
      }
    }, {
      key: "isPinched",
      get: function get() {
        return this.state === RECOGNIZED$1;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }]);

    return Pinch;
  }(TwoPointersTracer);

  var IDLE$1 = 'IDLE';
  var BEGIN$1 = 'BEGIN';
  var RECOGNIZED$1 = 'RECOGNIZED';

  var RotateAround$1 = Phaser.Math.RotateAround;

  var RotateObjectAround = function RotateObjectAround(gameObject, x, y, angle) {
    RotateAround$1(gameObject, x, y, angle);
    gameObject.rotation += angle;
    return gameObject;
  };

  var ScreenXYToWorldXY = function ScreenXYToWorldXY(screenX, screenY, camera, out) {
    if (out === undefined) {
      out = {};
    } else if (out === true) {
      out = globalOut;
    }

    camera.getWorldPoint(screenX, screenY, out);
    return out;
  };

  var globalOut = {};

  var SpinObject = function SpinObject(gameObject, camera) {
    if (!this.isRotation) {
      return this;
    }

    if (camera === undefined) {
      camera = this.pointers[0].camera;
    }

    var movementX = this.movementCenterX,
        movementY = this.movementCenterY;
    var worldXY = ScreenXYToWorldXY(this.centerX, this.centerY, camera, true);
    var centerWorldX = worldXY.x;
    var centerWorldY = worldXY.y;
    var angle = this.rotation;

    if (Array.isArray(gameObject)) {
      var gameObjects = gameObject;

      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        gameObject = gameObjects[i];
        gameObject.x += movementX;
        gameObject.y += movementY;
        RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
      }
    } else {
      gameObject.x += movementX;
      gameObject.y += movementY;
      RotateObjectAround(gameObject, centerWorldX, centerWorldY, angle);
    }

    return this;
  };

  var GetValue$1a = Phaser.Utils.Objects.GetValue;
  var WrapDegrees = Phaser.Math.Angle.WrapDegrees; // Wrap degrees: -180 to 180 

  var ShortestBetween = Phaser.Math.Angle.ShortestBetween;
  var RadToDeg$1 = Phaser.Math.RadToDeg;
  var DegToRad$2 = Phaser.Math.DegToRad;

  var Rotate = /*#__PURE__*/function (_TwoPointersTracer) {
    _inherits(Rotate, _TwoPointersTracer);

    var _super = _createSuper(Rotate);

    function Rotate(scene, config) {
      var _this;

      _classCallCheck(this, Rotate);

      _this = _super.call(this, scene, config);

      var self = _assertThisInitialized(_this);

      var stateConfig = {
        states: {
          IDLE: {
            enter: function enter() {
              self.prevAngle = undefined;
              self.angle = 0;
            }
          },
          BEGIN: {},
          RECOGNIZED: {
            enter: function enter() {
              self.emit('rotatestart', self);
            },
            exit: function exit() {
              self.emit('rotateend', self);
            }
          }
        },
        init: function init() {
          this.state = IDLE;
        },
        eventEmitter: false
      };

      _this.setRecongizedStateObject(new FSM(stateConfig));

      return _this;
    }

    _createClass(Rotate, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Rotate.prototype), "resetFromJSON", this).call(this, o);

        this.setDragThreshold(GetValue$1a(o, 'threshold', 0));
        return this;
      }
    }, {
      key: "onDrag2Start",
      value: function onDrag2Start() {
        this.prevAngle = WrapDegrees(RadToDeg$1(this.angleBetween)); // Degrees

        this.state = BEGIN;

        if (this.dragThreshold === 0) {
          this.state = RECOGNIZED;
        }
      }
    }, {
      key: "onDrag2End",
      value: function onDrag2End() {
        this.state = IDLE;
      }
    }, {
      key: "onDrag2",
      value: function onDrag2() {
        switch (this.state) {
          case BEGIN:
            if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) {
              var curAngle = WrapDegrees(RadToDeg$1(this.angleBetween));
              this.angle = ShortestBetween(this.prevAngle, curAngle);
              this.prevAngle = curAngle;
              this.state = RECOGNIZED;
            }

            break;

          case RECOGNIZED:
            var curAngle = WrapDegrees(RadToDeg$1(this.angleBetween));
            this.angle = ShortestBetween(this.prevAngle, curAngle);
            this.prevAngle = curAngle;
            this.emit('rotate', this);
            break;
        }
      }
    }, {
      key: "isRotated",
      get: function get() {
        return this.state === RECOGNIZED;
      }
    }, {
      key: "rotation",
      get: function get() {
        return DegToRad$2(this.angle);
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }]);

    return Rotate;
  }(TwoPointersTracer);

  var methods$h = {
    spinObject: SpinObject
  };
  Object.assign(Rotate.prototype, methods$h);
  var IDLE = 'IDLE';
  var BEGIN = 'BEGIN';
  var RECOGNIZED = 'RECOGNIZED';

  var GetValue$19 = Phaser.Utils.Objects.GetValue;

  var TapChild = function TapChild(config) {
    var tapConfig = GetValue$19(config, 'tap', undefined);

    if (tapConfig === false) {
      return;
    }

    var childrenInteractive = this._childrenInteractive;
    this._tap = new Tap(this, tapConfig);

    this._tap.on('tap', function (tap, gameObject, lastPointer) {
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix).concat(tap.tapsCount, "tap"), childrenInteractive.targetSizers, tap.worldX, tap.worldY, lastPointer);
    }, this);
  };

  var GetValue$18 = Phaser.Utils.Objects.GetValue;

  var PressChild = function PressChild(config) {
    var pressConfig = GetValue$18(config, 'press', undefined);

    if (pressConfig === false) {
      return;
    }

    var childrenInteractive = this._childrenInteractive;
    this._press = new Press(this, pressConfig);

    this._press.on('pressstart', function (press, gameObject, lastPointer) {
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "pressstart"), childrenInteractive.targetSizers, press.worldX, press.worldY, lastPointer);
    }, this).on('pressend', function (press, gameObject, lastPointer) {
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "pressend"), childrenInteractive.targetSizers, press.worldX, press.worldY, lastPointer);
    }, this);
  };

  var GetValue$17 = Phaser.Utils.Objects.GetValue;

  var SwipeChild = function SwipeChild(config) {
    var swipeConfig = GetValue$17(config, 'swipe', undefined);

    if (swipeConfig === false) {
      return;
    }

    if (swipeConfig === undefined) {
      swipeConfig = {};
    }

    if (!swipeConfig.hasOwnProperty('dir')) {
      swipeConfig.dir = '4dir';
    }

    var childrenInteractive = this._childrenInteractive;
    this._swipe = new Swipe(this, swipeConfig);

    this._swipe.on('swipe', function (swipe, gameObject, lastPointer) {
      var dirName = swipe.left ? 'left' : swipe.right ? 'right' : swipe.up ? 'up' : 'down';
      EmitChildEvent(childrenInteractive.eventEmitter, "".concat(childrenInteractive.eventNamePrefix, "swipe").concat(dirName), childrenInteractive.targetSizers, swipe.worldX, swipe.worldY, lastPointer);
    }, this);
  };

  var GetValue$16 = Phaser.Utils.Objects.GetValue;

  var SetChildrenInteractive = function SetChildrenInteractive(gameObject, config) {
    gameObject.setInteractive();
    gameObject._childrenInteractive = {
      targetSizers: GetValue$16(config, 'targets', [gameObject]),
      eventEmitter: GetValue$16(config, 'eventEmitter', gameObject),
      eventNamePrefix: GetValue$16(config, 'inputEventPrefix', 'child.')
    };
    ClickChild.call(gameObject, config);
    OverChild.call(gameObject, config);
    TapChild.call(gameObject, config);
    PressChild.call(gameObject, config);
    SwipeChild.call(gameObject, config);
    return gameObject;
  };

  var SetChildrenInteractiveWrap = function SetChildrenInteractiveWrap(config) {
    SetChildrenInteractive(this, config);
    return this;
  };

  var BroadcastEvent = function BroadcastEvent() {
    var gameObjects = this.getAllChildren([this]);

    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      var gameObject = gameObjects[i];
      gameObject.emit.apply(gameObject, arguments);
    }

    return this;
  };

  var methods$g = {
    getSizerConfig: GetSizerConfig,
    getChildPrevState: GetChildPrevState,
    pushIntoBounds: PushIntoBounds,
    drawBounds: DrawBounds,
    resolveWidth: ResolveWidth$2,
    resolveChildrenWidth: ResolveChildrenWidth$1,
    resolveHeight: ResolveHeight$2,
    getChildWidth: GetChildWidth$1,
    getChildHeight: GetChildHeight,
    getExpandedChildWidth: GetExpandedChildWidth$3,
    getExpandedChildHeight: GetExpandedChildHeight$3,
    getChildrenWidth: GetChildrenWidth$5,
    getChildrenHeight: GetChildrenHeight$5,
    addChildrenMap: AddChildrenMap,
    addElement: AddChildrenMap,
    getElement: GetElement,
    getAllChildrenSizers: GetAllChildrenSizers,
    getChildrenSizers: GetChildrenSizers$5,
    preLayout: PreLayout$4,
    layout: Layout,
    runLayout: RunLayout,
    layoutChildren: LayoutChildren$6,
    runWidthWrap: RunWidthWrap$2,
    layoutBackgrounds: LayoutBackgrounds,
    postLayout: PostLayout,
    setAnchor: SetAnchor,
    isInTouching: IsInTouching,
    pointToChild: PointToChild$1,
    setDraggable: SetDraggable,
    setChildrenInteractive: SetChildrenInteractiveWrap,
    broadcastEvent: BroadcastEvent
  };
  Object.assign(methods$g, PaddingMethods, AddChildMethods$8, RemoveChildMethods$7, GetParentSizerMethods, ScaleMethods, FadeMethods, EaseMoveMethods, ShakeMethods, EaseDataMethods, ClickMethods, ClickOutsideMethods, TouchingMethods, HideMethods, GetShownChildrenMethods);

  var GetValue$15 = Phaser.Utils.Objects.GetValue;

  var Base = /*#__PURE__*/function (_Container) {
    _inherits(Base, _Container);

    var _super = _createSuper(Base);

    function Base(scene, x, y, minWidth, minHeight, config) {
      var _this;

      _classCallCheck(this, Base);

      _this = _super.call(this, scene, x, y, 2, 2);
      _this.isRexSizer = true;

      _this.setMinSize(minWidth, minHeight);

      _this.setName(GetValue$15(config, 'name', ''));

      _this.rexSizer = {};
      _this.space = {};
      _this.backgroundChildren = undefined;
      _this.sizerChildren = undefined; // [] or {}

      _this.layoutedChildren = undefined;
      var anchorConfig = GetValue$15(config, 'anchor', undefined);

      if (anchorConfig) {
        _this.setAnchor(anchorConfig);
      }

      _this.setInnerPadding(GetValue$15(config, 'space', 0));

      _this.setDraggable(GetValue$15(config, 'draggable', false));

      _this.setSizerEventsEnable(GetValue$15(config, 'sizerEvents', false));

      _this.setDirty(true);

      return _this;
    }

    _createClass(Base, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        if (fromScene) {
          // In this case, children will be cleared and destroy in scene level
          var sizers = this.getAllChildrenSizers([this]);

          for (var i = 0, cnt = sizers.length; i < cnt; i++) {
            sizers[i].sizerEventsEnable = false;
          }
        }

        _get(_getPrototypeOf(Base.prototype), "destroy", this).call(this, fromScene);

        Clear(this.backgroundChildren);
        Clear(this.sizerChildren);
        this.childrenMap = undefined;
        this.space = undefined;
        this.rexSizer = undefined;
        this.layoutedChildren = undefined;
      }
    }, {
      key: "setMinSize",
      value: function setMinSize(minWidth, minHeight) {
        this.setMinWidth(minWidth).setMinHeight(minHeight);
        return this;
      }
    }, {
      key: "setMinWidth",
      value: function setMinWidth(minWidth) {
        if (minWidth == null) {
          minWidth = 0;
        }

        this.minWidth = minWidth;
        return this;
      }
    }, {
      key: "setMinHeight",
      value: function setMinHeight(minHeight) {
        if (minHeight == null) {
          minHeight = 0;
        }

        this.minHeight = minHeight;
        return this;
      }
    }, {
      key: "setDirty",
      value: function setDirty(dirty) {
        if (dirty === undefined) {
          dirty = true;
        }

        this.dirty = dirty;
        return this;
      }
    }, {
      key: "setSizerEventsEnable",
      value: function setSizerEventsEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }

        this.sizerEventsEnable = enable;
        return this;
      }
    }, {
      key: "ignoreLayout",
      get: function get() {
        // Skip hidden or !dirty sizer
        return this.rexSizer.hidden || !this.dirty;
      }
    }, {
      key: "childrenWidth",
      get: function get() {
        if (this._childrenWidth === undefined) {
          this._childrenWidth = this.getChildrenWidth();
        }

        return this._childrenWidth;
      }
    }, {
      key: "childrenHeight",
      get: function get() {
        if (this._childrenHeight === undefined) {
          this._childrenHeight = this.getChildrenHeight();
        }

        return this._childrenHeight;
      }
    }, {
      key: "left",
      get: function get() {
        return this.x - GetDisplayWidth(this) * this.originX;
      },
      set: function set(value) {
        this.x += value - this.left;
      }
    }, {
      key: "alignLeft",
      value: function alignLeft(value) {
        this.left = value;
        return this;
      }
    }, {
      key: "right",
      get: function get() {
        return this.left + GetDisplayWidth(this);
      },
      set: function set(value) {
        this.x += value - this.right;
      }
    }, {
      key: "alignRight",
      value: function alignRight(value) {
        this.right = value;
        return this;
      }
    }, {
      key: "centerX",
      get: function get() {
        return this.left + GetDisplayWidth(this) / 2;
      },
      set: function set(value) {
        this.x += value - this.centerX;
      }
    }, {
      key: "alignCenterX",
      value: function alignCenterX(value) {
        this.centerX = value;
        return this;
      }
    }, {
      key: "top",
      get: function get() {
        return this.y - GetDisplayHeight(this) * this.originY;
      },
      set: function set(value) {
        this.y += value - this.top;
      }
    }, {
      key: "alignTop",
      value: function alignTop(value) {
        this.top = value;
        return this;
      }
    }, {
      key: "bottom",
      get: function get() {
        return this.top + GetDisplayHeight(this);
      },
      set: function set(value) {
        this.y += value - this.bottom;
      }
    }, {
      key: "alignBottom",
      value: function alignBottom(value) {
        this.bottom = value;
        return this;
      }
    }, {
      key: "centerY",
      get: function get() {
        return this.top + GetDisplayHeight(this) / 2;
      },
      set: function set(value) {
        this.y += value - this.centerY;
      }
    }, {
      key: "alignCenterY",
      value: function alignCenterY(value) {
        this.centerY = value;
        return this;
      }
    }, {
      key: "innerLeft",
      get: function get() {
        return this.left + this.space.left;
      }
    }, {
      key: "innerRight",
      get: function get() {
        return this.right - this.space.right;
      }
    }, {
      key: "innerTop",
      get: function get() {
        return this.top + this.space.top;
      }
    }, {
      key: "innerBottom",
      get: function get() {
        return this.bottom - this.space.bottom;
      }
    }, {
      key: "innerWidth",
      get: function get() {
        return this.width - this.space.left - this.space.right;
      }
    }, {
      key: "innerHeight",
      get: function get() {
        return this.height - this.space.top - this.space.bottom;
      }
    }, {
      key: "minInnerWidth",
      get: function get() {
        var result = this.minWidth - this.space.left - this.space.right;
        return Math.max(result, 0);
      }
    }, {
      key: "minInnerHeight",
      get: function get() {
        var result = this.minHeight - this.space.top - this.space.bottom;
        return Math.max(result, 0);
      }
    }]);

    return Base;
  }(ContainerLite);

  Object.assign(Base.prototype, methods$g);

  var GetChildrenWidth$4 = function GetChildrenWidth() {
    if (this.rexSizer.hidden) {
      return 0;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childWidth;

    for (var key in children) {
      child = children[key];
      padding = child.rexSizer.padding;
      childWidth = this.getChildWidth(child) + padding.left + padding.right;
      result = Math.max(childWidth, result);
    }

    return result + this.space.left + this.space.right;
  };

  var GetChildrenHeight$4 = function GetChildrenHeight() {
    if (this.rexSizer.hidden) {
      return 0;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childHeight;

    for (var key in children) {
      child = children[key];
      childHeight = child.isRexSizer ? Math.max(child.minHeight, child.childrenHeight) : child.minHeight !== undefined ? child.minHeight : GetDisplayHeight(child);
      padding = child.rexSizer.padding;
      childHeight += padding.top + padding.bottom;
      result = Math.max(childHeight, result);
    }

    return result + this.space.top + this.space.bottom;
  };

  var GetExpandedChildWidth$2 = function GetExpandedChildWidth(child, parentWidth) {
    if (parentWidth === undefined) {
      parentWidth = this.width;
    }

    var childWidth;
    var childConfig = child.rexSizer;

    if (childConfig.expandWidth) {
      var innerWidth = parentWidth - this.space.left - this.space.right;
      var padding = childConfig.padding;
      childWidth = innerWidth - padding.left - padding.right;
    }

    return childWidth;
  };

  var GetExpandedChildHeight$2 = function GetExpandedChildHeight(child, parentHeight) {
    if (parentHeight === undefined) {
      parentHeight = this.height;
    }

    var childHeight;
    var childConfig = child.rexSizer;

    if (childConfig.expandHeight) {
      var innerHeight = parentHeight - this.space.top - this.space.bottom;
      var padding = childConfig.padding;
      childHeight = innerHeight - padding.top - padding.bottom;
    }

    return childHeight;
  };

  var GetChildrenSizers$4 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }

    var children = this.sizerChildren,
        child;

    for (var key in children) {
      child = children[key];

      if (child.isRexSizer) {
        out.push(child);
      }
    }

    return out;
  };

  var CheckSize = function CheckSize(child, parent) {
    if (child.width < child.childrenWidth) {
      // Warning
      console.warn("Layout width error: Parent=".concat(parent.constructor.name, ", Child=").concat(child.constructor.name));
    }

    if (child.height < child.childrenHeight) {
      // Warning
      console.warn("Layout height error: Parent=".concat(parent.constructor.name, ", Child=").concat(child.constructor.name));
    }
  };

  var LayoutChildren$5 = function LayoutChildren() {
    var child, childConfig, padding;
    var startX = this.innerLeft,
        startY = this.innerTop;
    var innerWidth = this.innerWidth,
        innerHeight = this.innerHeight;
    var x, y, width, height; // Align zone

    var childWidth, childHeight; // Layout current page

    var children = this.sizerChildren;

    for (var key in children) {
      child = children[key];

      if (child.rexSizer.hidden) {
        continue;
      }

      childConfig = child.rexSizer;
      padding = childConfig.padding;
      PreLayoutChild.call(this, child); // Set size

      if (child.isRexSizer) {
        child.runLayout(this, this.getExpandedChildWidth(child), this.getExpandedChildHeight(child));
        CheckSize(child, this);
      } else {
        childWidth = undefined;
        childHeight = undefined;

        if (childConfig.expandWidth) {
          // Expand width
          childWidth = innerWidth - padding.left - padding.right;
        }

        if (childConfig.expandHeight) {
          // Expand height
          childHeight = innerHeight - padding.top - padding.bottom;
        }

        ResizeGameObject(child, childWidth, childHeight);
      } // Set position


      x = startX + padding.left;
      width = innerWidth - padding.left - padding.right;
      y = startY + padding.top;
      height = innerHeight - padding.top - padding.bottom;
      LayoutChild.call(this, child, x, y, width, height, childConfig.align, childConfig.alignOffsetX, childConfig.alignOffsetY);
    }
  };

  var IsPlainObject$i = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$14 = Phaser.Utils.Objects.GetValue;
  var ALIGN_CENTER$3 = Phaser.Display.Align.CENTER;
  var UUID = Phaser.Utils.String.UUID;

  var Add$7 = function Add(gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY) {
    AddChild.call(this, gameObject);

    if (IsPlainObject$i(childKey)) {
      var config = childKey;
      childKey = GetValue$14(config, 'key', undefined);
      align = GetValue$14(config, 'align', ALIGN_CENTER$3);
      offsetX = GetValue$14(config, 'offsetX', 0);
      offsetY = GetValue$14(config, 'offsetY', 0);
      padding = GetValue$14(config, 'padding', 0);
      expand = GetValue$14(config, 'expand', true);

      if (!gameObject.isRexSizer) {
        // Get minWidth,minHeight from config
        minWidth = GetValue$14(config, 'minWidth', gameObject._minWidth);
        minHeight = GetValue$14(config, 'minHeight', gameObject._minHeighted);
      }
    }

    var hasValidKey = childKey !== undefined;

    if (!hasValidKey) {
      childKey = UUID();
    }

    if (typeof align === 'string') {
      align = ALIGNMODE[align];
    }

    if (align === undefined) {
      align = ALIGN_CENTER$3;
    }

    if (offsetX === undefined) {
      offsetX = 0;
    }

    if (offsetY === undefined) {
      offsetY = 0;
    }

    if (padding === undefined) {
      padding = 0;
    }

    if (expand === undefined) {
      expand = true;
    }

    if (!gameObject.isRexSizer) {
      // Get minWidth,minHeight from game object
      if (minWidth === undefined) {
        minWidth = gameObject._minWidth;
      }

      if (minHeight === undefined) {
        minHeight = gameObject._minHeight;
      }
    }

    var config = this.getSizerConfig(gameObject);
    config.align = align;
    config.alignOffsetX = offsetX;
    config.alignOffsetY = offsetY;
    config.padding = GetBoundsConfig(padding);

    if (IsPlainObject$i(expand)) {
      config.expandWidth = GetValue$14(expand, 'width', false);
      config.expandHeight = GetValue$14(expand, 'height', false);
    } else {
      config.expandWidth = expand;
      config.expandHeight = expand;
    }

    if (!gameObject.isRexSizer) {
      // Expand normal game object
      if (config.expandWidth) {
        // minWidth is still undefined, uses current display width
        gameObject.minWidth = minWidth === undefined ? GetDisplayWidth(gameObject) : minWidth;
      }

      if (config.expandHeight) {
        // minHeight is still undefined, uses current display height
        gameObject.minHeight = minHeight === undefined ? GetDisplayHeight(gameObject) : minHeight;
      }
    }

    if (this.sizerChildren.hasOwnProperty(childKey)) {
      this.sizerChildren[childKey].destroy();
    }

    this.sizerChildren[childKey] = gameObject;

    if (hasValidKey) {
      this.addChildrenMap(childKey, gameObject);
    }

    return this;
  };

  var AddChildMethods$7 = {
    add: Add$7
  };

  var RemoveItem$6 = Phaser.Utils.Array.Remove;
  var ContainerRemove = ContainerLite.prototype.remove;

  var RemoveChild = function RemoveChild(gameObject, destroyChild) {
    if (this.isBackground(gameObject)) {
      RemoveItem$6(this.backgroundChildren, gameObject);
    }

    ContainerRemove.call(this, gameObject, destroyChild);

    if (!destroyChild && this.sizerEventsEnable) {
      gameObject.emit('sizer.remove', gameObject, this);
      this.emit('remove', gameObject, this);
    }

    return this;
  };

  var ContainerClear = ContainerLite.prototype.clear;

  var ClearChildren = function ClearChildren(destroyChild) {
    if (this.backgroundChildren) {
      this.backgroundChildren.length = 0;
    }

    var fireRemoveEvent = !destroyChild && this.sizerEventsEnable;
    var children;

    if (fireRemoveEvent) {
      children = this.getChildren([]);
    }

    ContainerClear.call(this, destroyChild);

    if (fireRemoveEvent) {
      var gameObject;

      for (var i = 0, cnt = children.length; i < cnt; i++) {
        gameObject = children[i];
        gameObject.emit('sizer.remove', gameObject, this);
        this.emit('remove', gameObject, this);
      }
    }

    return this;
  };

  var RemoveChildMethods$6 = {
    remove: function remove(gameObject, destroyChild) {
      var key;

      if (typeof gameObject === 'string') {
        key = gameObject;
        gameObject = this.sizerChildren[key];

        if (!gameObject) {
          return this;
        }
      } else if (this.getParentSizer(gameObject) !== this) {
        return this;
      } else {
        key = this.childToKey(gameObject);
      }

      if (key) {
        delete this.sizerChildren[key];

        if (this.childrenMap.hasOwnProperty(key)) {
          delete this.childrenMap[key];
        }
      }

      RemoveChild.call(this, gameObject, destroyChild);
      return this;
    },
    removeAll: function removeAll(destroyChild) {
      for (var key in this.sizerChildren) {
        this.remove(key, destroyChild);
      }

      return this;
    },
    clear: function clear(destroyChild) {
      for (var key in this.sizerChildren) {
        delete this.sizerChildren[key];

        if (this.childrenMap.hasOwnProperty(key)) {
          delete this.childrenMap[key];
        }
      }

      ClearChildren.call(this, destroyChild);
      return this;
    }
  };

  var methods$f = {
    getChildrenWidth: GetChildrenWidth$4,
    getChildrenHeight: GetChildrenHeight$4,
    getExpandedChildWidth: GetExpandedChildWidth$2,
    getExpandedChildHeight: GetExpandedChildHeight$2,
    getChildrenSizers: GetChildrenSizers$4,
    layoutChildren: LayoutChildren$5
  };
  Object.assign(methods$f, AddChildMethods$7, RemoveChildMethods$6);

  var IndexOf = function IndexOf(obj, child) {
    if (Array.isArray(obj)) {
      return obj.indexOf(child);
    } else {
      for (var key in obj) {
        if (obj[key] === child) {
          return key;
        }
      }

      return null;
    }
  };

  var IsPlainObject$h = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$13 = Phaser.Utils.Objects.GetValue;

  var OverlapSizer = /*#__PURE__*/function (_BaseSizer) {
    _inherits(OverlapSizer, _BaseSizer);

    var _super = _createSuper(OverlapSizer);

    function OverlapSizer(scene, x, y, minWidth, minHeight, config) {
      var _this;

      _classCallCheck(this, OverlapSizer);

      if (IsPlainObject$h(x)) {
        config = x;
        x = GetValue$13(config, 'x', 0);
        y = GetValue$13(config, 'y', 0);
        minWidth = GetValue$13(config, 'width', undefined);
        minHeight = GetValue$13(config, 'height', undefined);
      } else if (IsPlainObject$h(minWidth)) {
        config = minWidth;
        minWidth = GetValue$13(config, 'width', undefined);
        minHeight = GetValue$13(config, 'height', undefined);
      }

      _this = _super.call(this, scene, x, y, minWidth, minHeight, config);
      _this.type = 'rexOverlapSizer';
      _this.sizerChildren = {};

      _this.addChildrenMap('items', _this.sizerChildren);

      return _this;
    }

    _createClass(OverlapSizer, [{
      key: "childToKey",
      value: function childToKey(gameObject) {
        if (typeof gameObject === 'string') {
          var key = gameObject;

          if (this.sizerChildren.hasOwnPropery(key)) {
            return key;
          }
        } else {
          return IndexOf(this.sizerChildren, gameObject);
        }

        return null;
      }
    }]);

    return OverlapSizer;
  }(Base);

  Object.assign(OverlapSizer.prototype, methods$f);

  var GetDistance = Phaser.Math.Distance.Between;

  var IsLocalPointInKnob = function IsLocalPointInKnob(knob, localX, localY) {
    var centerX = knob.width / 2;
    return GetDistance(centerX, centerX, localX, localY) <= centerX;
  };

  var GetAngle$1 = Phaser.Math.Angle.Between;
  var NormalizeAngle = Phaser.Math.Angle.Normalize;

  var OnTouchPad = function OnTouchPad(pointer, localX, localY) {
    if (!this.enable) {
      return;
    }

    if (!pointer.isDown) {
      return;
    }

    var knob = this.sizerChildren.knob;

    if (!IsLocalPointInKnob(knob, localX, localY)) {
      return;
    }

    var centerX = knob.width / 2;
    var startAngle = knob.startAngle;
    var endAngle = GetAngle$1(centerX, centerX, localX, localY);
    var deltaAngle = knob.anticlockwise ? startAngle - endAngle : endAngle - startAngle;
    var value = NormalizeAngle(deltaAngle) / (2 * Math.PI);
    this.stopEaseValue();

    if (this.easeValueDuration === 0 || Math.abs(this.value - value) < 0.1) {
      this.value = value;
    } else {
      this.easeValueTo(value);
    }
  };

  var InstallEvents$1 = function InstallEvents() {
    var knob = this.sizerChildren.knob;
    knob.setInteractive().on('pointerdown', OnTouchPad, this).on('pointermove', OnTouchPad, this);
  };

  var GetAngle = Phaser.Math.Angle.Between;
  var WrapAngle = Phaser.Math.Angle.Wrap;

  var OnPointerDown = function OnPointerDown(pointer, localX, localY) {
    if (!this.enable || this.panPointer) {
      return;
    }

    var knob = this.sizerChildren.knob;

    if (!IsLocalPointInKnob(knob, localX, localY)) {
      return;
    }

    OnPanStart.call(this, pointer);
  };

  var OnPointerMove = function OnPointerMove(pointer, localX, localY) {
    if (!this.enable) {
      return;
    }

    if (!pointer.isDown) {
      return;
    }

    var knob = this.sizerChildren.knob;

    switch (this.panState) {
      case TOUCH0:
        if (IsLocalPointInKnob(knob, localX, localY)) {
          OnPanStart.call(this, pointer);
        }

        break;

      case TOUCH1:
        if (IsLocalPointInKnob(knob, localX, localY)) {
          OnPan.call(this);
        } else {
          OnPanEnd.call(this);
        }

        break;
    }
  };

  var OnPointerUp = function OnPointerUp(pointer, localX, localY) {
    if (!this.enable || this.panPointer !== pointer) {
      return;
    }

    OnPanEnd.call(this);
  };

  var OnPanStart = function OnPanStart(pointer) {
    this.panPointer = pointer;
    this.panState = TOUCH1;
  };

  var OnPanEnd = function OnPanEnd() {
    this.panPointer = undefined;
    this.panState = TOUCH0;
  };

  var OnPan = function OnPan() {
    var p0 = this.panPointer.prevPosition,
        p1 = this.panPointer.position;
    var knob = this.sizerChildren.knob;
    var startAngle = GetAngle(knob.x, knob.y, p0.x, p0.y),
        endAngle = GetAngle(knob.x, knob.y, p1.x, p1.y);
    var deltaAngle = knob.anticlockwise ? startAngle - endAngle : endAngle - startAngle;
    var deltaValue = WrapAngle(deltaAngle) / (Math.PI * 2);
    this.stopEaseValue();
    this.value += deltaValue;
  };

  var TOUCH0 = 0;
  var TOUCH1 = 1;

  var InstallEvents = function InstallEvents() {
    var knob = this.sizerChildren.knob;
    knob.setInteractive().on('pointerdown', OnPointerDown, this).on('pointermove', OnPointerMove, this).on('pointerup', OnPointerUp, this);
    this.panPointer = undefined;
    this.panState = TOUCH0;
  };

  var SetTextFormatCallback = function SetTextFormatCallback(callback, scope) {
    this.textFormatCallback = callback;
    this.textFormatCallbackScope = scope;
    return this;
  };

  var GetFormatText = function GetFormatText(value) {
    if (value === undefined) {
      value = this.value;
    }

    var text;

    if (this.textFormatCallbackScope) {
      text = this.textFormatCallback(value);
    } else {
      text = this.textFormatCallback.call(this.textFormatCallbackScope, value);
    }

    return text;
  };

  var UpdateText = function UpdateText() {
    var textObject = this.sizerChildren.text;

    if (textObject) {
      textObject.setText(GetFormatText.call(this));

      if (textObject.layout) {
        textObject.layout();
      }
    }

    return this;
  };

  var TextObjectMethods = {
    setTextFormatCallback: SetTextFormatCallback,
    getFormatText: GetFormatText,
    updateText: UpdateText
  };

  var GetValue$12 = Phaser.Utils.Objects.GetValue;
  var Linear$4 = Phaser.Math.Linear;
  var Percent$3 = Phaser.Math.Percent;
  var SnapTo$1 = Phaser.Math.Snap.To;

  var Knob = /*#__PURE__*/function (_OverlapSizer) {
    _inherits(Knob, _OverlapSizer);

    var _super = _createSuper(Knob);

    function Knob(scene, config) {
      var _this;

      _classCallCheck(this, Knob);

      if (config === undefined) {
        config = {};
      } // Create sizer


      _this = _super.call(this, scene, config);
      _this.type = 'rexKnob';
      _this.eventEmitter = GetValue$12(config, 'eventEmitter', _assertThisInitialized(_this)); // Add elements

      var background = GetValue$12(config, 'background', undefined);
      var textObject = GetValue$12(config, 'text', undefined);

      if (background) {
        _this.addBackground(background);
      } // Get text object


      if (textObject) {
        // Don't draw text on knob directly
        config.textColor = undefined;
        config.textStrokeColor = undefined;

        _this.setTextFormatCallback(GetValue$12(config, 'textFormatCallback', undefined), GetValue$12(config, 'textFormatCallbackScope', undefined));
      } // Create circular progress object


      var knob = new CircularProgress(scene, config);
      knob.setDepth(GetValue$12(config, 'knobDepth', 0));
      knob._value = -1; // To trigger text updating

      scene.add.existing(knob);

      _this.add(knob, 'knob');

      if (textObject) {
        _this.add(textObject, 'text', 'center', 0, false);

        scene.children.moveBelow(knob, textObject); // Move knob below textObject
      }

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('knob', knob);

      _this.addChildrenMap('text', textObject);

      var callback = GetValue$12(config, 'valuechangeCallback', null);

      if (callback !== null) {
        var scope = GetValue$12(config, 'valuechangeCallbackScope', undefined);

        _this.eventEmitter.on('valuechange', callback, scope);
      }

      _this.setEnable(GetValue$12(config, 'enable', undefined));

      _this.setEaseValuePropName('value').setEaseValueDuration(GetValue$12(config, 'easeValue.duration', 0)).setEaseValueFunction(GetValue$12(config, 'easeValue.ease', 'Linear'));

      _this.setGap(GetValue$12(config, 'gap', undefined));

      _this.setValue(GetValue$12(config, 'value', 0), GetValue$12(config, 'min', undefined), GetValue$12(config, 'max', undefined)); // Input


      var inputMode = GetValue$12(config, 'input', 0);

      if (typeof inputMode === 'string') {
        inputMode = INPUTMODE$1[inputMode];
      }

      switch (inputMode) {
        case 0:
          // 'pan'
          InstallEvents.call(_assertThisInitialized(_this));
          break;

        case 1:
          // 'click'
          InstallEvents$1.call(_assertThisInitialized(_this));
          break;
      }

      return _this;
    }

    _createClass(Knob, [{
      key: "setEnable",
      value: function setEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }

        this.enable = enable;
        return this;
      }
    }, {
      key: "setGap",
      value: function setGap(gap) {
        this.gap = gap;
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        return this.sizerChildren.knob.value;
      },
      set: function set(value) {
        if (this.gap !== undefined) {
          value = SnapTo$1(value, this.gap);
        }

        var oldValue = this.value;
        this.sizerChildren.knob.value = value;
        var newValue = this.value;

        if (oldValue !== newValue) {
          this.updateText();
          this.eventEmitter.emit('valuechange', newValue, oldValue, this.eventEmitter);
        }
      }
    }, {
      key: "setValue",
      value: function setValue(value, min, max) {
        if (value === undefined || value === null) {
          return this;
        }

        if (min !== undefined) {
          value = Percent$3(value, min, max);
        }

        this.value = value;
        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, min, max) {
        if (min !== undefined) {
          inc = Percent$3(inc, min, max);
        }

        this.value += inc;
        return this;
      }
    }, {
      key: "getValue",
      value: function getValue(min, max) {
        var value = this.value;

        if (min !== undefined) {
          value = Linear$4(min, max, value);
        }

        return value;
      }
    }]);

    return Knob;
  }(OverlapSizer);

  var INPUTMODE$1 = {
    pan: 0,
    drag: 0,
    click: 1,
    none: -1
  };
  Object.assign(Knob.prototype, TextObjectMethods, EaseValueMethods);

  ObjectFactory.register('knob', function (config) {
    var gameObject = new Knob(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Knob', Knob);

  var ShapeClasses = {
    arc: Arc,
    circle: Circle,
    curve: Curve,
    ellipse: Ellipse,
    line: Line,
    lines: Lines,
    rectangle: Rectangle$4,
    triangle: Triangle
  };
  var GetValue$11 = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$g = Phaser.Utils.Objects.IsPlainObject;

  var ClearAll = function ClearAll() {
    var shapes = this.getShapes();

    for (var i = 0, cnt = shapes.length; i < cnt; i++) {
      shapes[i].lineStyle().fillStyle();
    }
  };

  var ShapesUpdateMethods = {
    createShape: function createShape(shapeType, name) {
      var ShapeClass = ShapeClasses[shapeType];
      var shape = new ShapeClass();

      if (name) {
        shape.setName(name);
      }

      return shape;
    },
    buildShapes: function buildShapes(config) {
      var createCallback = GetValue$11(config, 'create', undefined);

      if (IsPlainObject$g(createCallback)) {
        var shapes = createCallback;

        for (var shapeType in shapes) {
          var name = shapes[shapeType];

          switch (_typeof(name)) {
            case 'number':
              for (var i = 0; i < name; i++) {
                this.addShape(this.createShape(shapeType));
              }

              break;

            case 'string':
              this.addShape(this.createShape(shapeType, name));
              break;

            default:
              //Array
              var names = name;

              for (var i = 0, cnt = names.length; i < cnt; i++) {
                this.addShape(this.createShape(shapeType, names[i]));
              }

              break;
          }
        }
      } else if (Array.isArray(createCallback)) {
        var shapes = createCallback;

        for (var i = 0, cnt = shapes.length; i < cnt; i++) {
          var shape = shapes[i];
          this.addShape(this.createShape(shape.type, shape.name));
        }
      } else if (typeof createCallback === 'function') {
        createCallback.call(this);
      }

      this.setUpdateShapesCallback(GetValue$11(config, 'update'));
    },
    setUpdateShapesCallback: function setUpdateShapesCallback(callback) {
      if (callback === undefined) {
        callback = ClearAll;
      }

      this.dirty = this.dirty || this.updateCallback !== callback;
      this.updateCallback = callback;
      return this;
    },
    updateShapes: function updateShapes() {
      this.updateCallback.call(this);
    }
  };

  var GetValue$10 = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$f = Phaser.Utils.Objects.IsPlainObject;

  var CustomShapes = /*#__PURE__*/function (_BaseShapes) {
    _inherits(CustomShapes, _BaseShapes);

    var _super = _createSuper(CustomShapes);

    function CustomShapes(scene, x, y, width, height, config) {
      var _this;

      _classCallCheck(this, CustomShapes);

      if (IsPlainObject$f(x)) {
        config = x;
        x = GetValue$10(config, 'x', 0);
        y = GetValue$10(config, 'y', 0);
        width = GetValue$10(config, 'width', 2);
        height = GetValue$10(config, 'height', 2);
      }

      _this = _super.call(this, scene, x, y, width, height);
      _this.type = GetValue$10(config, 'type', 'rexCustomShapes');

      _this.buildShapes(config);

      return _this;
    }

    return _createClass(CustomShapes);
  }(BaseShapes);

  Object.assign(CustomShapes.prototype, ShapesUpdateMethods);

  ObjectFactory.register('customShapes', function (x, y, width, height, config) {
    var gameObject = new CustomShapes(this.scene, x, y, width, height, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.CustomShapes', CustomShapes);

  var GetValue$$ = Phaser.Utils.Objects.GetValue;
  var IsPlainObject$e = Phaser.Utils.Objects.IsPlainObject;
  var Clamp$7 = Phaser.Math.Clamp;
  var Linear$3 = Phaser.Math.Linear;
  var Percent$2 = Phaser.Math.Percent;

  var CustomProgress = /*#__PURE__*/function (_CustomShapes) {
    _inherits(CustomProgress, _CustomShapes);

    var _super = _createSuper(CustomProgress);

    function CustomProgress(scene, x, y, width, height, config) {
      var _this;

      _classCallCheck(this, CustomProgress);

      if (IsPlainObject$e(x)) {
        config = x;
        x = GetValue$$(config, 'x', 0);
        y = GetValue$$(config, 'y', 0);
        width = GetValue$$(config, 'width', 2);
        height = GetValue$$(config, 'height', 2);
      }

      if (config === undefined) {
        config = {};
      }

      if (!config.type) {
        config.type = 'rexCustomProgress';
      }

      _this = _super.call(this, scene, x, y, width, height, config);
      _this.eventEmitter = GetValue$$(config, 'eventEmitter', _assertThisInitialized(_this));
      var callback = GetValue$$(config, 'valuechangeCallback', null);

      if (callback !== null) {
        var scope = GetValue$$(config, 'valuechangeCallbackScope', undefined);

        _this.eventEmitter.on('valuechange', callback, scope);
      }

      _this.setEaseValuePropName('value').setEaseValueDuration(GetValue$$(config, 'easeValue.duration', 0)).setEaseValueFunction(GetValue$$(config, 'easeValue.ease', 'Linear'));

      _this.setValue(GetValue$$(config, 'value', 0));

      return _this;
    }

    _createClass(CustomProgress, [{
      key: "centerX",
      get: function get() {
        return this.width / 2;
      }
    }, {
      key: "centerY",
      get: function get() {
        return this.height / 2;
      }
    }, {
      key: "radius",
      get: function get() {
        return Math.min(this.centerX, this.centerY);
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        value = Clamp$7(value, 0, 1);
        var oldValue = this._value;
        var valueChanged = oldValue != value;
        this.dirty = this.dirty || valueChanged;
        this._value = value;

        if (valueChanged) {
          this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
      }
    }, {
      key: "setValue",
      value: function setValue(value, min, max) {
        if (value === undefined || value === null) {
          return this;
        }

        if (min !== undefined) {
          value = Percent$2(value, min, max);
        }

        this.value = value;
        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, min, max) {
        if (min !== undefined) {
          inc = Percent$2(inc, min, max);
        }

        this.value += inc;
        return this;
      }
    }, {
      key: "getValue",
      value: function getValue(min, max) {
        var value = this.value;

        if (min !== undefined) {
          value = Linear$3(min, max, value);
        }

        return value;
      }
    }]);

    return CustomProgress;
  }(CustomShapes);

  Object.assign(CustomProgress.prototype, EaseValueMethods);

  ObjectFactory.register('customProgress', function (x, y, width, height, config) {
    var gameObject = new CustomProgress(this.scene, x, y, width, height, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.CustomProgress', CustomProgress);

  var SetTransitionCallbackMethods = {
    setTransitionStartCallback: function setTransitionStartCallback(callback, scope) {
      this.onStartCallback = callback;
      this.onStartCallbackScope = scope;
      return this;
    },
    setTransitionProgressCallback: function setTransitionProgressCallback(callback, scope) {
      this.onProgressCallback = callback;
      this.onProgressCallbackScope = scope;
      return this;
    },
    setTransitionCompleteCallback: function setTransitionCompleteCallback(callback, scope) {
      this.onCompleteCallback = callback;
      this.onCompleteCallbackScope = scope;
      return this;
    }
  };

  var IsPlainObject$d = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$_ = Phaser.Utils.Objects.GetValue;
  var DirMode = {
    out: 0,
    "in": 1
  };
  var TransitionMethods = {
    setTransitionDirection: function setTransitionDirection(dir) {
      if (typeof dir === 'string') {
        dir = DirMode[dir];
      }

      this.dir = dir;
      return this;
    },
    setDuration: function setDuration(duration) {
      this.duration = duration;
      return this;
    },
    setEaseFunction: function setEaseFunction(ease) {
      this.easeFunction = ease;
      return this;
    },
    setNextTexture: function setNextTexture(texture, frame) {
      this.nextImage.setTexture(texture, frame);
      return this;
    },
    transit: function transit(texture, frame) {
      if (this.isRunning) {
        this.ignoreCompleteEvent = true;
        this.stop();
        this.ignoreCompleteEvent = false;
      }

      if (IsPlainObject$d(texture)) {
        var config = texture;
        texture = GetValue$_(config, 'key', undefined);
        frame = GetValue$_(config, 'frame', undefined);
        this.setDuration(GetValue$_(config, 'duration', this.duration)).setEaseFunction(GetValue$_(config, 'ease', this.easeFunction)).setTransitionDirection(GetValue$_(config, 'dir', this.dir));
        var maskGameObject = GetValue$_(config, 'mask', undefined);

        if (maskGameObject) {
          this.setMaskGameObject(maskGameObject);
        }

        this.setMaskEnable(maskGameObject === true);
        var onStart = GetValue$_(config, 'onStart', undefined);
        var onProgress = GetValue$_(config, 'onProgress', undefined);
        var onComplete = GetValue$_(config, 'onComplete', undefined);

        if (onStart !== undefined || onProgress !== undefined || onComplete !== undefined) {
          this.setTransitionStartCallback(onStart, GetValue$_(config, 'onStartScope', undefined)).setTransitionProgressCallback(onProgress, GetValue$_(config, 'onProgressScope', undefined)).setTransitionCompleteCallback(onComplete, GetValue$_(config, 'onCompleteScope', undefined));
        }
      }

      this.setNextTexture(texture, frame);
      this.start();
      return this;
    },
    start: function start() {
      if (this.easeValueTask === undefined) {
        this.easeValueTask = new EaseValueTask(this, {
          eventEmitter: null
        });
      }

      this.easeValueTask.restart({
        key: 't',
        from: 0,
        to: 1,
        duration: this.duration,
        ease: this.easeFunction
      });
      return this;
    },
    pause: function pause() {
      if (this.easeValueTask) {
        this.easeValueTask.pause();
      }

      return this;
    },
    resume: function resume() {
      if (this.easeValueTask) {
        this.easeValueTask.resume();
      }

      return this;
    },
    stop: function stop() {
      if (this.easeValueTask) {
        this.easeValueTask.stop();
      }

      this.setT(1);
      return this;
    }
  };

  var DrawShape = function DrawShape(width, height, padding, originX, originY) {
    this.clear().fillStyle(0xffffff);

    switch (this.shape) {
      case 1:
        // circle
        var radius = Math.min(width, height) / 2;
        this.fillCircle(-width * (originX - 0.5), -height * (originY - 0.5), radius + padding);
        break;

      default:
        // 0|'rectangle'
        this.fillRect(-(width * originX) - padding, -(height * originY) - padding, width + 2 * padding, height + 2 * padding);
        break;
    }
  };

  var Graphics = Phaser.GameObjects.Graphics;

  var DefaultMaskGraphics = /*#__PURE__*/function (_Graphics) {
    _inherits(DefaultMaskGraphics, _Graphics);

    var _super = _createSuper(DefaultMaskGraphics);

    function DefaultMaskGraphics(parent, shape, padding) {
      var _this;

      _classCallCheck(this, DefaultMaskGraphics);

      if (shape === undefined) {
        shape = 0;
      }

      if (typeof shape === 'string') {
        shape = SHAPEMODE[shape];
      }

      if (padding === undefined) {
        padding = 0;
      }

      _this = _super.call(this, parent.scene);
      _this.parent = parent;
      _this.shape = shape;
      _this.padding = padding;

      _this.setPosition().resize().setVisible(false); // Don't add it to display list


      return _this;
    }

    _createClass(DefaultMaskGraphics, [{
      key: "destroy",
      value: function destroy() {
        this.parent = undefined;

        _get(_getPrototypeOf(DefaultMaskGraphics.prototype), "destroy", this).call(this);

        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(x, y) {
        var parent = this.parent;

        if (x === undefined) {
          x = parent.x;
        }

        if (y === undefined) {
          y = parent.y;
        }

        _get(_getPrototypeOf(DefaultMaskGraphics.prototype), "setPosition", this).call(this, x, y);

        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height, padding) {
        var parent = this.parent;

        if (width === undefined) {
          width = parent.width;
        }

        if (height === undefined) {
          height = parent.height;
        }

        if (padding === undefined) {
          padding = this.padding;
        }

        if (this.widthSave === width && this.heightSave === height && this.paddingSave === padding) {
          return this;
        }

        this.widthSave = width;
        this.heightSave = height;
        this.paddingSave = padding;
        this.originXSave = parent.originX;
        this.originYSave = parent.originY;
        DrawShape.call(this, width, height, padding, parent.originX, parent.originY);
        return this;
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(originX, originY) {
        if (originY === undefined) {
          originY = originX;
        }

        var parent = this.parent;

        if (originX === undefined) {
          originX = parent.originX;
        }

        if (originY === undefined) {
          originY = parent.originY;
        }

        if (this.originXSave === originX && this.originYSave === originY) {
          return this;
        }

        this.originXSave = originX;
        this.originYSave = originY;
        DrawShape.call(this, this.widthSave, this.heightSave, this.paddingSave, originX, originY);
        return this;
      }
    }]);

    return DefaultMaskGraphics;
  }(Graphics);

  var SHAPEMODE = {
    rectangle: 0,
    circle: 1
  };

  var MaskMethods = {
    setMaskGameObject: function setMaskGameObject(gameObject) {
      if (!gameObject) {
        this.removeMaskGameObject();
        return this;
      }

      if (this.maskGameObject) {
        if (gameObject === true && this.maskGameObject instanceof DefaultMaskGraphics) {
          return this;
        }

        if (this.maskGameObject === gameObject) {
          return this;
        } // Remove previous Mask Game Object


        this.removeMaskGameObject();
      } // Add new Mask Game Object


      if (gameObject === true) {
        gameObject = new DefaultMaskGraphics(this);
      }

      this.maskGameObject = gameObject;
      this.maskGameObject.resize(this.width, this.height).setOrigin(this.originX, this.originY).setPosition(0, 0).setScale(1).setVisible(false);
      this.addLocal(this.maskGameObject);
      this.childrenMask = this.maskGameObject.createGeometryMask();
      return this;
    },
    removeMaskGameObject: function removeMaskGameObject() {
      this.backImage.clearMask();
      this.frontImage.clearMask();
      this.childrenMask = undefined;
      this.remove(this.maskGameObject, true);
      this.maskGameObject = undefined;
      return this;
    },
    setImageMaskEnable: function setImageMaskEnable(gameObject, enable, invertAlpha) {
      if (enable === undefined) {
        enable = true;
      } // Use DefaultMaskGraphics if not given


      if (!this.childrenMask) {
        this.setMaskGameObject(true);
      }

      if (enable) {
        gameObject.setMask(this.childrenMask);

        if (invertAlpha) {
          this.childrenMask.setInvertAlpha();
        }
      } else {
        gameObject.clearMask();
      }

      return this;
    },
    setCurrentImageMaskEnable: function setCurrentImageMaskEnable(enable, invertAlpha) {
      this.setImageMaskEnable(this.currentImage, enable, invertAlpha);
      return this;
    },
    setNextImageMaskEnable: function setNextImageMaskEnable(enable, invertAlpha) {
      this.setImageMaskEnable(this.nextImage, enable, invertAlpha);
      return this;
    },
    setCellImagesMaskEnable: function setCellImagesMaskEnable(enable, invertAlpha) {
      var cellImages = this.getCellImages();

      for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
        this.setImageMaskEnable(cellImages[i], enable, invertAlpha);
      }

      return this;
    },
    setMaskEnable: function setMaskEnable(enable, invertAlpha) {
      this.setImageMaskEnable(this.backImage, enable, invertAlpha);
      this.setImageMaskEnable(this.frontImage, enable, invertAlpha);
      this.setCellImagesMaskEnable(enable, invertAlpha);
      return this;
    }
  };

  var GetFrameNameCallback = function GetFrameNameCallback(baseFrameName, delimiter) {
    if (delimiter === undefined) {
      delimiter = ',';
    }

    var callback;

    if (baseFrameName === '__BASE') {
      callback = function callback(colIndex, rowIndex) {
        return "".concat(colIndex).concat(delimiter).concat(rowIndex);
      };
    } else {
      callback = function callback(colIndex, rowIndex) {
        return "".concat(baseFrameName, "_").concat(colIndex).concat(delimiter).concat(rowIndex);
      };
    }

    return callback;
  };

  var GridCut = function GridCut(scene, key, frame, columns, rows, getFrameNameCallback) {
    if (frame == null) {
      frame = '__BASE';
    }

    if (!IsFunction(getFrameNameCallback)) {
      getFrameNameCallback = GetFrameNameCallback(frame, getFrameNameCallback);
    }

    var texture = scene.sys.textures.get(key);
    var baseFrame = texture.frames[frame];
    var cellWidth = baseFrame.width / columns,
        cellHeight = baseFrame.height / rows;
    var offsetX = 0,
        offsetY = 0;
    var frameName;

    for (var y = 0; y < rows; y++) {
      offsetX = 0;

      for (var x = 0; x < columns; x++) {
        frameName = getFrameNameCallback(x, y);
        texture.add(frameName, 0, offsetX + baseFrame.cutX, offsetY + baseFrame.cutY, cellWidth, cellHeight);
        offsetX += cellWidth;
      }

      offsetY += cellHeight;
    }

    return {
      getFrameNameCallback: getFrameNameCallback,
      cellWidth: cellWidth,
      cellHeight: cellHeight,
      columns: columns,
      rows: rows
    };
  };

  var GetValue$Z = Phaser.Utils.Objects.GetValue;
  var DefaultImageClass = Phaser.GameObjects.Image;
  var IsPlainObject$c = Phaser.Utils.Objects.IsPlainObject;
  var RotateAround = Phaser.Math.RotateAround;

  var GridCutImage = function GridCutImage(gameObject, columns, rows, config) {
    if (IsPlainObject$c(columns)) {
      config = columns;
      columns = GetValue$Z(config, 'columns', 1);
      rows = GetValue$Z(config, 'rows', 1);
    }

    var ImageClass = GetValue$Z(config, 'ImageClass', DefaultImageClass);
    var originX = GetValue$Z(config, 'originX', 0.5);
    var originY = GetValue$Z(config, 'originY', 0.5);
    var addToScene = GetValue$Z(config, 'add', true);
    var align = GetValue$Z(config, 'align', addToScene);
    var imageObjectPool = GetValue$Z(config, 'objectPool', undefined);
    var scene = gameObject.scene;
    var key = gameObject.texture.key;
    var frame = gameObject.frame.name;
    var result = GridCut(scene, key, frame, columns, rows);
    var getFrameNameCallback = result.getFrameNameCallback;
    var scaleX = gameObject.scaleX,
        scaleY = gameObject.scaleY;
    var rotation = gameObject.rotation;
    var topLeft = gameObject.getTopLeft(),
        startX = topLeft.x,
        startY = topLeft.y;
    var cellGameObjects = [];
    var cellWidth = result.cellWidth * scaleX,
        cellHeight = result.cellHeight * scaleY;

    for (var y = 0; y < rows; y++) {
      for (var x = 0; x < columns; x++) {
        var cellGameObject;
        var frameName = getFrameNameCallback(x, y);

        if (imageObjectPool && imageObjectPool.length > 0) {
          cellGameObject = imageObjectPool.pop().setTexture(key, frameName);
        } else {
          cellGameObject = new ImageClass(scene, 0, 0, key, frameName);
        }

        if (addToScene) {
          scene.add.existing(cellGameObject);
        }

        var cellTLX = startX + cellWidth * x;
        var cellTLY = startY + cellHeight * y;
        var cellX = cellTLX + originX * cellWidth;
        var cellY = cellTLY + originY * cellHeight;

        if (align) {
          cellGameObject.setOrigin(originX, originY).setPosition(cellX, cellY).setScale(scaleX, scaleY).setRotation(rotation);
          RotateAround(cellGameObject, startX, startY, rotation);
        }

        cellGameObjects.push(cellGameObject);
      }
    }

    return cellGameObjects;
  };

  var GridCutMethods = {
    gridCutImage: function gridCutImage(gameObject, columns, rows, config) {
      if (config === undefined) {
        config = {};
      }

      config.objectPool = this.imagesPool;
      var cellImages = GridCutImage(gameObject, columns, rows, config),
          cellImage;

      for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
        cellImage = cellImages[i];
        cellImage.setVisible(true);
        this.add(cellImage);
      }

      this.cellImages = cellImages;
      this.setChildLocalVisible(gameObject, false); // Set cut target to invisible

      return cellImages;
    },
    gridCutCurrentImage: function gridCutCurrentImage(columns, rows, config) {
      return this.gridCutImage(this.currentImage, columns, rows, config);
    },
    gridCutNextImage: function gridCutNextImage(columns, rows, config) {
      return this.gridCutImage(this.nextImage, columns, rows, config);
    },
    getCellImages: function getCellImages() {
      return this.cellImages;
    },
    freeCellImages: function freeCellImages() {
      var _this$imagesPool;

      if (this.cellImages.length === 0) {
        return this;
      }

      var texture = this.cellImages[0].texture;
      var cellImages = this.cellImages,
          cellImage,
          frameName;

      for (var i = 0, cnt = cellImages.length; i < cnt; i++) {
        cellImage = cellImages[i]; // Reset property of cell image

        this.setChildLocalAlpha(cellImage, 1).setChildLocalScale(cellImage, 1).setChildLocalVisible(cellImage, false);
        cellImage.clearMask(); // Remove frame object

        frameName = cellImage.frame.name;
        cellImage.setTexture();
        texture.remove(frameName);
      }

      (_this$imagesPool = this.imagesPool).push.apply(_this$imagesPool, _toConsumableArray(cellImages));

      cellImages.length = 0;
      return this;
    }
  };

  var methods$e = {};
  Object.assign(methods$e, SetTransitionCallbackMethods, TransitionMethods, MaskMethods, GridCutMethods);

  var OnStart = function OnStart(parent, currentImage, nextImage, t) {};

  var OnProgress = function OnProgress(parent, currentImage, nextImage, t) {
    parent.setChildLocalAlpha(currentImage, 1 - t).setChildLocalAlpha(nextImage, t);
  };

  var OnComplete = function OnComplete(parent, currentImage, nextImage, t) {
    parent.setChildLocalAlpha(currentImage, 1);
  };

  var IsPlainObject$b = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$Y = Phaser.Utils.Objects.GetValue;
  var Clamp$6 = Phaser.Math.Clamp;

  var TransitionImage = /*#__PURE__*/function (_Container) {
    _inherits(TransitionImage, _Container);

    var _super = _createSuper(TransitionImage);

    function TransitionImage(scene, x, y, texture, frame, config) {
      var _this;

      _classCallCheck(this, TransitionImage);

      if (IsPlainObject$b(x)) {
        config = x;
        x = GetValue$Y(config, 'x', 0);
        y = GetValue$Y(config, 'y', 0);
        texture = GetValue$Y(config, 'key', undefined);
        frame = GetValue$Y(config, 'frame', undefined);
      } else if (IsPlainObject$b(frame)) {
        config = frame;
        frame = undefined;
      }

      var backImage = GetValue$Y(config, 'back', undefined);
      var frontImage = GetValue$Y(config, 'front', undefined);

      if (!backImage) {
        backImage = scene.add.image(x, y, texture, frame);
      }

      if (!frontImage) {
        frontImage = scene.add.image(x, y, texture, frame);
      }

      var width = GetValue$Y(config, 'width', frontImage.width);
      var height = GetValue$Y(config, 'height', frontImage.height);
      _this = _super.call(this, scene, x, y, width, height);
      backImage.setVisible(false);

      _this.addMultiple([backImage, frontImage]);

      _this.type = 'rexTransitionImage';
      _this.backImage = backImage;
      _this.frontImage = frontImage;
      _this.maskGameObject = undefined;
      _this.cellImages = [];
      _this.imagesPool = []; // Transition parameters

      var onStart = GetValue$Y(config, 'onStart', undefined);
      var onProgress = GetValue$Y(config, 'onProgress', undefined);
      var onComplete = GetValue$Y(config, 'onComplete', undefined);
      var dir = GetValue$Y(config, 'dir', 0);

      if (onStart === undefined && onProgress === undefined && onComplete === undefined) {
        onStart = OnStart;
        onProgress = OnProgress;
        onComplete = OnComplete;
        dir = 0;
      }

      _this.setTransitionStartCallback(onStart, GetValue$Y(config, 'onStartScope', undefined)).setTransitionProgressCallback(onProgress, GetValue$Y(config, 'onProgressScope', undefined)).setTransitionCompleteCallback(onComplete, GetValue$Y(config, 'onCompleteScope', undefined)).setTransitionDirection(dir).setDuration(GetValue$Y(config, 'duration', 1000)).setEaseFunction(GetValue$Y(config, 'ease', 'Linear'));

      var maskGameObject = GetValue$Y(config, 'mask', undefined);

      if (maskGameObject) {
        _this.setMaskGameObject(maskGameObject);
      }

      _this.setMaskEnable(false);

      _this.ignoreCompleteEvent = false;
      return _this;
    }

    _createClass(TransitionImage, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        if (this.childrenMask) {
          this.childrenMask.destroy();
          this.childrenMask = undefined;
        }

        this.backImage = undefined;
        this.frontImage = undefined;
        this.maskGameObject = undefined;
        this.cellImages.length = 0;
        this.imagesPool.length = 0;

        _get(_getPrototypeOf(TransitionImage.prototype), "destroy", this).call(this, fromScene);

        this.onStartCallback = undefined;
        this.onStartCallbackScope = undefined;
        this.onProgressCallback = undefined;
        this.onProgressCallbackScope = undefined;
        this.onCompleteCallback = undefined;
        this.onCompleteCallbackScope = undefined;
        this.easeValueTask = undefined;
      }
    }, {
      key: "currentImage",
      get: function get() {
        return this.dir === 0 ? this.frontImage : this.backImage;
      }
    }, {
      key: "nextImage",
      get: function get() {
        return this.dir === 0 ? this.backImage : this.frontImage;
      }
    }, {
      key: "texture",
      get: function get() {
        return this.nextImage.texture;
      }
    }, {
      key: "frame",
      get: function get() {
        return this.nextImage.frame;
      }
    }, {
      key: "t",
      get: function get() {
        return this._t;
      },
      set: function set(value) {
        value = Clamp$6(value, 0, 1);

        if (this._t === value) {
          return;
        }

        this._t = value;
        var currentImage = this.currentImage;
        var nextImage = this.nextImage; // Start

        if (value === 0) {
          this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, true);
          RunCallback(this.onStartCallback, this.onStartCallbackScope, this, currentImage, nextImage, value);
        } // Progress


        RunCallback(this.onProgressCallback, this.onProgressCallbackScope, this, currentImage, nextImage, value); // Complete

        if (value === 1) {
          RunCallback(this.onCompleteCallback, this.onCompleteCallbackScope, this, currentImage, nextImage, value);
          var key = nextImage.texture.key,
              frame = nextImage.frame.name;
          this.frontImage.setTexture(key, frame);
          this.backImage.setTexture(key, frame);
          this.setChildVisible(this.frontImage, true).setChildVisible(this.backImage, false).setMaskEnable(false).freeCellImages();
        }

        if (value === 1 && !this.ignoreCompleteEvent) {
          this.emit('complete');
        }
      }
    }, {
      key: "setT",
      value: function setT(value) {
        this.t = value;
        return this;
      }
    }, {
      key: "isRunning",
      get: function get() {
        return this.easeValueTask ? this.easeValueTask.isRunning : false;
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(originX, originY) {
        _get(_getPrototypeOf(TransitionImage.prototype), "setOrigin", this).call(this, originX, originY);

        this.backImage.setOrigin(originX, originY);
        this.frontImage.setOrigin(originX, originY);

        if (this.maskGameObject) {
          this.maskGameObject.setOrigin(originX, originY);
        }

        return this;
      }
    }, {
      key: "setTexture",
      value: function setTexture(texture, frame) {
        // Without transition
        this.frontImage.setTexture(texture, frame);
        this.backImage.setTexture(texture, frame).setVisible(false);
        return this;
      }
    }]);

    return TransitionImage;
  }(ContainerLite);

  var RunCallback = function RunCallback(callback, scope, parent, currentImage, nextImage, t) {
    if (!callback) {
      return;
    }

    if (scope) {
      callback.call(scope, parent, currentImage, nextImage, t);
    } else {
      callback(parent, currentImage, nextImage, t);
    }
  }; // mixin


  Object.assign(TransitionImage.prototype, methods$e);

  ObjectFactory.register('transitionImage', function (x, y, texture, frame, config) {
    var gameObject = new TransitionImage(this.scene, x, y, texture, frame, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.TransitionImage', TransitionImage);

  var Rectangle$1 = Phaser.GameObjects.Rectangle;

  var FullWindowRectangle = /*#__PURE__*/function (_Rectangle) {
    _inherits(FullWindowRectangle, _Rectangle);

    var _super = _createSuper(FullWindowRectangle);

    function FullWindowRectangle(scene, color, alpha) {
      var _this;

      _classCallCheck(this, FullWindowRectangle);

      _this = _super.call(this, scene, 0, 0, 2, 2, color, 1);

      _this.setAlpha(alpha);

      _this.setScrollFactor(0);

      _this.boot();

      return _this;
    }

    _createClass(FullWindowRectangle, [{
      key: "boot",
      value: function boot() {
        var scene = this.scene;
        scene.sys.events.on('prerender', this.resize, this);
      }
    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        // preDestroy method does not have fromScene parameter
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        this.scene.sys.events.off('prerender', this.resize, this);

        _get(_getPrototypeOf(FullWindowRectangle.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "tint",
      get: function get() {
        return this.fillColor;
      },
      set: function set(value) {
        this.setFillStyle(value, this.fillAlpha);
      }
    }, {
      key: "resize",
      value: function resize() {
        var scene = this.scene;
        var gameSize = scene.sys.scale.gameSize;
        var camera = scene.sys.cameras.main;
        var gameWidth = gameSize.width,
            gameHeight = gameSize.height,
            scale = 1 / camera.zoom;
        var x = gameWidth / 2,
            y = gameHeight / 2,
            width = gameWidth * scale,
            height = gameHeight * scale;

        if (this.x !== x || this.y !== y) {
          this.setPosition(x, y);
        }

        if (this.width !== width || this.height !== height) {
          this.setSize(width, height).setOrigin(0.5);
        }
      }
    }]);

    return FullWindowRectangle;
  }(Rectangle$1);

  ObjectFactory.register('fullWindowRectangle', function (fillColor, fillAlpha) {
    var gameObject = new FullWindowRectangle(this.scene, fillColor, fillAlpha);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.FullWindowRectangle', FullWindowRectangle);

  var GetValue$X = Phaser.Utils.Objects.GetValue;

  var TouchEventStop = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TouchEventStop, _ComponentBase);

    var _super = _createSuper(TouchEventStop);

    function TouchEventStop(gameObject, config) {
      var _this;

      _classCallCheck(this, TouchEventStop);

      _this = _super.call(this, gameObject, {
        eventEmitter: false
      }); // No event emitter
      // this.parent = gameObject;

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(TouchEventStop, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setHitAreaMode(GetValue$X(o, 'hitAreaMode', 0));
        this.setEnable(GetValue$X(o, "enable", true));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        this.parent.on('pointerdown', function (pointer, localX, localY, event) {
          event.stopPropagation();
        }).on('pointerup', function (pointer, localX, localY, event) {
          event.stopPropagation();
        }).on('pointermove', function (pointer, localX, localY, event) {
          event.stopPropagation();
        }).on('pointerover', function (pointer, localX, localY, event) {
          event.stopPropagation();
        }).on('pointerout', function (pointer, event) {
          event.stopPropagation();
        });
      }
    }, {
      key: "setHitAreaMode",
      value: function setHitAreaMode(mode) {
        if (typeof mode === 'string') {
          mode = HitAreaMode[mode];
        }

        var gameObject = this.parent;

        if (gameObject.input) {
          gameObject.removeInteractive();
        }

        if (mode === 0) {
          gameObject.setInteractive();
        } else {
          gameObject.setInteractive({
            hitArea: {},
            hitAreaCallback: function hitAreaCallback() {
              return true;
            }
          });
        }

        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        if (e) {
          this.parent.setInteractive();
        } else {
          this.parent.disableInteractive();
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }]);

    return TouchEventStop;
  }(ComponentBase);

  var HitAreaMode = {
    "default": 0,
    fullWindow: 1
  };

  var GetValue$W = Phaser.Utils.Objects.GetValue;

  var Cover = /*#__PURE__*/function (_FullWindowRectangle) {
    _inherits(Cover, _FullWindowRectangle);

    var _super = _createSuper(Cover);

    function Cover(scene, config) {
      var _this;

      _classCallCheck(this, Cover);

      var fillColor = GetValue$W(config, 'color', 0x0);
      var fillAlpha = GetValue$W(config, 'alpha', 0.8);
      _this = _super.call(this, scene, fillColor, fillAlpha);
      _this.touchEventStop = new TouchEventStop(_assertThisInitialized(_this), {
        hitAreaMode: 1
      });
      return _this;
    }

    return _createClass(Cover);
  }(FullWindowRectangle);

  ObjectFactory.register('cover', function (config) {
    var gameObject = new Cover(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Cover', Cover);

  var SetChart = function SetChart(config) {
    if (!window.Chart) {
      var msg = "Can not find chartjs! Load chartjs in preload stage.\nscene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.min.js');";
      console.error(msg);
      return this;
    }

    if (this.chart) {
      this.chart.destroy();
    }

    this.chart = new Chart(this.context, FillConfig(this, config));
    return this;
  };

  var FillConfig = function FillConfig(canvas, config) {
    // Get options
    if (config === undefined) {
      config = {};
    }

    if (config.options === undefined) {
      config.options = {};
    }

    var options = config.options; // Fill options

    options.responsive = false;
    options.maintainAspectRatio = false;

    if (!options.hasOwnProperty('devicePixelRatio')) {
      options.devicePixelRatio = 1;
    } // Get animation config


    var noAnimation = false;

    if (options.animation === undefined) {
      options.animation = {};
    } else if (options.animation === false) {
      noAnimation = true;
      options.animation = {};
    }

    var animationConfig = options.animation; // Fill animation config

    if (noAnimation) {
      animationConfig.duration = 0;
    }

    var onProgress = animationConfig.onProgress;

    animationConfig.onProgress = function (animation) {
      if (onProgress) {
        onProgress(animation);
      }

      canvas.needRedraw();
    };

    var onComplete = animationConfig.onComplete;

    animationConfig.onComplete = function (animation) {
      if (onComplete) {
        onComplete(animation);
      }

      canvas.needRedraw();
    };

    return config;
  };

  var GetChartDataset = function GetChartDataset(datasetIndex) {
    if (this.chart === undefined) {
      return undefined;
    }

    if (typeof datasetIndex === 'string') {
      var datasets = this.chart.data.datasets,
          dataset;

      for (var i = 0, cnt = datasets.length; i < cnt; i++) {
        dataset = datasets[i];

        if (dataset.label === datasetIndex) {
          return dataset;
        }
      }
    } else {
      return this.chart.data.datasets[datasetIndex];
    }

    return undefined;
  };

  var GetChartData = function GetChartData(datasetIndex, dataIndex) {
    var dataset = this.getChartDataset(datasetIndex);

    if (dataset === undefined) {
      return undefined;
    }

    if (typeof dataIndex === 'string') {
      var labels = this.chart.data.labels;
      dataIndex = labels.indexOf(dataIndex);

      if (dataIndex === -1) {
        return undefined;
      }
    }

    return dataset.data[dataIndex];
  };

  var SetChartData = function SetChartData(datasetIndex, dataIndex, value) {
    if (this.chart === undefined) {
      return this;
    }

    var dataset = this.getChartDataset(datasetIndex);

    if (typeof dataIndex === 'string') {
      var labels = this.chart.data.labels;
      dataIndex = labels.indexOf(dataIndex);

      if (dataIndex === -1) {
        return this;
      }
    }

    dataset.data[dataIndex] = value;
    return this;
  };

  var UpdateChart = function UpdateChart() {
    if (this.chart === undefined) {
      return this;
    }

    this.chart.update();
  };

  // Load chart.js in preload stage -
  // scene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.min.js');

  var Chart$1 = /*#__PURE__*/function (_Canvas) {
    _inherits(Chart, _Canvas);

    var _super = _createSuper(Chart);

    function Chart(scene, x, y, width, height, config) {
      var _this;

      _classCallCheck(this, Chart);

      _this = _super.call(this, scene, x, y, width, height);
      _this.type = 'rexChart';
      _this.chart = undefined;

      if (config !== undefined) {
        _this.setChart(config);
      }

      return _this;
    }

    _createClass(Chart, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        if (this.chart) {
          this.chart.destroy();
          this.chart = undefined;
        }

        _get(_getPrototypeOf(Chart.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        if (width === this.width && height === this.height) {
          return this;
        }

        _get(_getPrototypeOf(Chart.prototype), "resize", this).call(this, width, height);

        if (this.chart) {
          var chart = this.chart;
          chart.height = this.canvas.height;
          chart.width = this.canvas.width;
          chart.aspectRatio = chart.height ? chart.width / chart.height : null;
          chart.update();
        }

        return this;
      }
    }]);

    return Chart;
  }(Canvas);

  var methods$d = {
    setChart: SetChart,
    getChartDataset: GetChartDataset,
    getChartData: GetChartData,
    setChartData: SetChartData,
    updateChart: UpdateChart
  };
  Object.assign(Chart$1.prototype, methods$d);

  ObjectFactory.register('chart', function (x, y, width, height, config) {
    var gameObject = new Chart$1(this.scene, x, y, width, height, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Chart', Chart$1);

  var GetChildrenWidth$3 = function GetChildrenWidth(minimumMode) {
    if (this.rexSizer.hidden) {
      return 0;
    }

    if (minimumMode === undefined) {
      minimumMode = true;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childWidth;

    if (this.orientation === 0) {
      // x
      // Get summation of minimum width
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];

        if (child.rexSizer.hidden) {
          continue;
        }

        if (child.rexSizer.proportion === 0 || minimumMode && child.rexSizer.proportion > 0) {
          childWidth = this.getChildWidth(child);
        } else {
          childWidth = 0;
        }

        padding = child.rexSizer.padding;
        childWidth += padding.left + padding.right;

        if (i > 0) {
          childWidth += this.space.item;
        }

        result += childWidth;
      }
    } else {
      // Get maximun width
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];

        if (!child.hasOwnProperty('rexSizer')) {
          continue;
        }

        if (child.rexSizer.hidden) {
          continue;
        }

        padding = child.rexSizer.padding;
        childWidth = this.getChildWidth(child) + padding.left + padding.right;
        result = Math.max(childWidth, result);
      }
    }

    return result + this.space.left + this.space.right;
  };

  var GetChildrenHeight$3 = function GetChildrenHeight(minimumMode) {
    if (this.rexSizer.hidden) {
      return 0;
    }

    if (minimumMode === undefined) {
      minimumMode = true;
    }

    var result = 0;
    var children = this.sizerChildren;
    var child, padding, childHeight;

    if (this.orientation === 0) {
      // x
      // Get maximun height
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];

        if (child.rexSizer.hidden) {
          continue;
        }

        padding = child.rexSizer.padding;
        childHeight = this.getChildHeight(child) + padding.top + padding.bottom;
        result = Math.max(childHeight, result);
      }
    } else {
      // Get summation of minimum height
      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = children[i];

        if (!child.hasOwnProperty('rexSizer')) {
          continue;
        }

        if (child.rexSizer.hidden) {
          continue;
        }

        padding = child.rexSizer.padding;

        if (child.rexSizer.proportion === 0 || minimumMode && child.rexSizer.proportion > 0) {
          childHeight = this.getChildHeight(child);
        } else {
          childHeight = 0;
        }

        childHeight += padding.top + padding.bottom;

        if (i > 0) {
          childHeight += this.space.item;
        }

        result += childHeight;
      }
    }

    return result + this.space.top + this.space.bottom;
  };

  var GetExpandedChildWidth$1 = function GetExpandedChildWidth(child, parentWidth) {
    if (parentWidth === undefined) {
      parentWidth = this.width;
    }

    var childWidth;
    var childConfig = child.rexSizer;
    var padding = childConfig.padding;

    if (this.orientation === 0) {
      // x
      if (childConfig.proportion > 0 && this.proportionLength > 0) {
        childWidth = childConfig.proportion * this.proportionLength;
      }
    } else {
      // y
      if (childConfig.expand) {
        var innerWidth = parentWidth - this.space.left - this.space.right;
        childWidth = innerWidth - padding.left - padding.right;
      }
    }

    return childWidth;
  };

  var GetExpandedChildHeight$1 = function GetExpandedChildHeight(child, parentHeight) {
    if (parentHeight === undefined) {
      parentHeight = this.height;
    }

    var childHeight;
    var childConfig = child.rexSizer;
    var padding = childConfig.padding;

    if (this.orientation === 0) {
      // x
      if (childConfig.expand) {
        var innerHeight = parentHeight - this.space.top - this.space.bottom;
        childHeight = innerHeight - padding.top - padding.bottom;
      }
    } else {
      // y
      if (childConfig.proportion > 0 && this.proportionLength > 0) {
        childHeight = childConfig.proportion * this.proportionLength;
      }
    }

    return childHeight;
  };

  var GetChildrenSizers$3 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }

    var children = this.sizerChildren,
        child;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child.isRexSizer) {
        out.push(child);
      }
    }

    return out;
  };

  var PreLayout$3 = function PreLayout() {
    this._childrenProportion = undefined;
    this.proportionLength = undefined;
    PreLayout$4.call(this);
    return this;
  };

  var LayoutChildren$4 = function LayoutChildren() {
    var children = this.sizerChildren;
    var child, childConfig, padding;
    var startX = this.innerLeft,
        startY = this.innerTop;
    var innerWidth = this.innerWidth;
    var innerHeight = this.innerHeight;
    var itemX = startX,
        itemY = startY;
    var x, y, width, height; // Align zone

    var childWidth, childHeight;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = !this.rtl ? children[i] : children[cnt - i - 1];

      if (child.rexSizer.hidden) {
        continue;
      }

      childConfig = child.rexSizer;
      padding = childConfig.padding;
      PreLayoutChild.call(this, child); // Set size

      if (child.isRexSpace) {
        childWidth = 0;
        childHeight = 0;
      } else {
        childWidth = this.getExpandedChildWidth(child);
        childHeight = this.getExpandedChildHeight(child);
      }

      if (child.isRexSizer) {
        child.runLayout(this, childWidth, childHeight);
        CheckSize(child, this);
      } else {
        ResizeGameObject(child, childWidth, childHeight);
      }

      if (childWidth === undefined) {
        childWidth = GetDisplayWidth(child);
      }

      if (childHeight === undefined) {
        childHeight = GetDisplayHeight(child);
      } // Set position


      if (this.orientation === 0) {
        // x
        x = itemX + padding.left;

        if (childConfig.proportion === 0 || this.proportionLength === 0) {
          width = childWidth;
        } else {
          width = childConfig.proportion * this.proportionLength;
        }

        y = itemY + padding.top;
        height = innerHeight - padding.top - padding.bottom;
      } else {
        // y
        x = itemX + padding.left;
        width = innerWidth - padding.left - padding.right;
        y = itemY + padding.top;

        if (childConfig.proportion === 0 || this.proportionLength === 0) {
          height = childHeight;
        } else {
          height = childConfig.proportion * this.proportionLength;
        }
      }

      LayoutChild.call(this, child, x, y, width, height, childConfig.align);

      if (this.orientation === 0) {
        // x
        itemX += width + padding.left + padding.right + this.space.item;
      } else {
        // y
        itemY += height + padding.top + padding.bottom + this.space.item;
      }
    }
  };

  var ResolveWidth$1 = function ResolveWidth(width) {
    var width = ResolveWidth$2.call(this, width); // Calculate proportionLength

    if (this.proportionLength === undefined && this.orientation === 0) {
      var remainder = width - this.childrenWidth;

      if (remainder > 0) {
        remainder = width - this.getChildrenWidth(false);
        this.proportionLength = remainder / this.childrenProportion;
      } else {
        this.proportionLength = 0;
      }
    }

    return width;
  };

  var ResolveHeight$1 = function ResolveHeight(parent, height) {
    var height = ResolveHeight$2.call(this, parent, height); // Get proportionLength

    if (this.proportionLength === undefined && this.orientation === 1) {
      var remainder = height - this.childrenHeight;

      if (remainder > 0) {
        remainder = height - this.getChildrenHeight(false);
        this.proportionLength = remainder / this.childrenProportion;
      } else {
        this.proportionLength = 0;
      }
    }

    return height;
  };

  var Zone = Phaser.GameObjects.Zone;

  var Space = /*#__PURE__*/function (_Zone) {
    _inherits(Space, _Zone);

    var _super = _createSuper(Space);

    function Space(scene) {
      var _this;

      _classCallCheck(this, Space);

      _this = _super.call(this, scene, 0, 0, 1, 1); // Don't add Zone into scene

      _this.isRexSpace = true;
      return _this;
    }

    return _createClass(Space);
  }(Zone);

  var GetNearestChildIndex$1 = function GetNearestChildIndex(x, y) {
    var children = this.sizerChildren;

    if (children.length === 0) {
      return -1;
    }

    var nearestIndex = -1,
        minDistance = Infinity;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i];
      var distance;

      if (this.orientation === 0) {
        // x
        distance = Math.abs(child.left - x);
      } else {
        distance = Math.abs(child.top - y);
      }

      if (minDistance > distance) {
        minDistance = distance;
        nearestIndex = i;
      }
    } // Check right bound of last child


    var child = children[children.length - 1];
    var distance;

    if (this.orientation === 0) {
      // x
      distance = Math.abs(child.right - x);
    } else {
      distance = Math.abs(child.bottom - y);
    }

    if (minDistance > distance) {
      minDistance = distance;
      nearestIndex = i + 1;
    }

    return nearestIndex;
  };

  var IsPlainObject$a = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$V = Phaser.Utils.Objects.GetValue;
  var ALIGN_CENTER$2 = Phaser.Display.Align.CENTER;
  var PROPORTIONMODE = {
    min: 0,
    full: -1
  };

  var Add$6 = function Add(gameObject, proportion, align, paddingConfig, expand, childKey, index, minSize) {
    AddChild.call(this, gameObject);

    var proportionType = _typeof(proportion);

    if (proportion === null) {
      return this;
    } else if (proportionType === 'number') ; else if (proportionType === 'string') {
      proportion = PROPORTIONMODE[proportion];
    } else if (IsPlainObject$a(proportion)) {
      var config = proportion;
      proportion = GetValue$V(config, 'proportion', 0);
      align = GetValue$V(config, 'align', ALIGN_CENTER$2);
      paddingConfig = GetValue$V(config, 'padding', 0);
      expand = GetValue$V(config, 'expand', false);
      childKey = GetValue$V(config, 'key', undefined);
      index = GetValue$V(config, 'index', undefined);

      if (!gameObject.isRexSizer) {
        // Get minSize from config
        if (this.orientation === 0) {
          // x
          minSize = GetValue$V(config, 'minWidth', undefined);
        } else {
          // y
          minSize = GetValue$V(config, 'minHeight', undefined);
        }
      }
    }

    if (typeof align === 'string') {
      align = ALIGNMODE[align];
    }

    if (proportion === undefined) {
      proportion = 0;
    }

    if (align === undefined) {
      align = ALIGN_CENTER$2;
    }

    if (paddingConfig === undefined) {
      paddingConfig = 0;
    }

    if (expand === undefined) {
      expand = false;
    }

    if (!gameObject.isRexSizer && minSize === undefined) {
      // Get minSize from game object
      if (this.orientation === 0) {
        // x
        minSize = gameObject._minWidth;
      } else {
        // y
        minSize = gameObject._minHeight;
      }
    }

    var config = this.getSizerConfig(gameObject);
    config.proportion = proportion;
    config.align = align;
    config.padding = GetBoundsConfig(paddingConfig);
    config.expand = expand;

    if (index === undefined || index >= this.sizerChildren.length) {
      this.sizerChildren.push(gameObject);
    } else {
      this.sizerChildren.splice(index, 0, gameObject);
    }

    if (!gameObject.isRexSizer && proportion > 0) {
      // Expand normal game object
      if (this.orientation === 0) {
        // x
        // minSize is still undefined, uses current display width
        gameObject.minWidth = minSize === undefined ? GetDisplayWidth(gameObject) : minSize;
      } else {
        // minSize is still undefined, uses current display height
        gameObject.minHeight = minSize === undefined ? GetDisplayHeight(gameObject) : minSize;
      }
    }

    if (childKey !== undefined) {
      this.addChildrenMap(childKey, gameObject);
    }

    return this;
  };

  var AddChildMethods$6 = {
    add: Add$6,
    // sizer.add could be override
    addSpace: function addSpace(proportion) {
      this.insertSpace(undefined, proportion);
      return this;
    },
    insertSpace: function insertSpace(index, proportion) {
      if (proportion === undefined) {
        proportion = 1;
      }

      Add$6.call(this, new Space(this.scene), {
        proportion: proportion,
        minWidth: 0,
        minHeight: 0,
        index: index
      }); // No problem if sizer.add is override

      return this;
    },
    insert: function insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
      if (IsPlainObject$a(proportion)) {
        proportion.index = index;
      }

      Add$6.call(this, gameObject, proportion, align, paddingConfig, expand, childKey, index, minSize); // No problem if sizer.add is override

      return this;
    },
    insertAtPosition: function insertAtPosition(x, y, gameObject, proportion, align, paddingConfig, expand, childKey, minSize) {
      var index = GetNearestChildIndex$1.call(this, x, y);

      if (index === -1) {
        index = undefined;
      }

      this.insert(index, gameObject, proportion, align, paddingConfig, expand, childKey, minSize);
      return this;
    }
  };

  var RemoveItem$5 = Phaser.Utils.Array.Remove;
  var RemoveChildMethods$5 = {
    remove: function remove(gameObject, destroyChild) {
      if (this.getParentSizer(gameObject) !== this) {
        return this;
      }

      RemoveItem$5(this.sizerChildren, gameObject);
      RemoveChild.call(this, gameObject, destroyChild);
      return this;
    },
    removeAll: function removeAll(destroyChild) {
      for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
        this.remove(this.sizerChildren[i], destroyChild);
      }

      return this;
    },
    clear: function clear(destroyChild) {
      this.sizerChildren.length = 0;
      ClearChildren.call(this, destroyChild);
      return this;
    }
  };

  var methods$c = {
    getChildrenWidth: GetChildrenWidth$3,
    getChildrenHeight: GetChildrenHeight$3,
    getExpandedChildWidth: GetExpandedChildWidth$1,
    getExpandedChildHeight: GetExpandedChildHeight$1,
    getChildrenSizers: GetChildrenSizers$3,
    preLayout: PreLayout$3,
    layoutChildren: LayoutChildren$4,
    resolveWidth: ResolveWidth$1,
    resolveHeight: ResolveHeight$1
  };
  Object.assign(methods$c, AddChildMethods$6, RemoveChildMethods$5);

  var GetChildrenProportion = function GetChildrenProportion() {
    var result = 0;
    var children = this.sizerChildren;
    var child, proportion;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child.rexSizer.hidden) {
        continue;
      }

      proportion = child.rexSizer.proportion;

      if (proportion > 0) {
        result += proportion;
      }
    }

    return result;
  };

  var OrientationMode = {
    x: 0,
    h: 0,
    horizontal: 0,
    'left-to-right': 0,
    y: 1,
    v: 1,
    vertical: 1,
    'top-to-bottom': 1
  };

  var GetOrientationMode = function GetOrientationMode(orientation) {
    if (typeof orientation === 'string') {
      orientation = OrientationMode[orientation];
    }

    return orientation;
  };

  var IsPlainObject$9 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$U = Phaser.Utils.Objects.GetValue;

  var Sizer = /*#__PURE__*/function (_BaseSizer) {
    _inherits(Sizer, _BaseSizer);

    var _super = _createSuper(Sizer);

    function Sizer(scene, x, y, minWidth, minHeight, orientation, config) {
      var _this;

      _classCallCheck(this, Sizer);

      if (IsPlainObject$9(x)) {
        config = x;
        x = GetValue$U(config, 'x', 0);
        y = GetValue$U(config, 'y', 0);
        minWidth = GetValue$U(config, 'width', undefined);
        minHeight = GetValue$U(config, 'height', undefined);
        orientation = GetValue$U(config, 'orientation', 0);
      } else if (IsPlainObject$9(minWidth)) {
        config = minWidth;
        minWidth = GetValue$U(config, 'width', undefined);
        minHeight = GetValue$U(config, 'height', undefined);
        orientation = GetValue$U(config, 'orientation', 0);
      } else if (IsPlainObject$9(orientation)) {
        config = orientation;
        orientation = GetValue$U(config, 'orientation', 0);
      }

      if (orientation === undefined) {
        orientation = 0;
      }

      _this = _super.call(this, scene, x, y, minWidth, minHeight, config);
      _this.type = 'rexSizer';
      _this.sizerChildren = [];

      _this.setOrientation(orientation);

      _this.setItemSpacing(GetValue$U(config, 'space.item', 0));

      _this.setRTL(GetValue$U(config, 'rtl', false));

      _this.addChildrenMap('items', _this.sizerChildren);

      return _this;
    }

    _createClass(Sizer, [{
      key: "setOrientation",
      value: function setOrientation(orientation) {
        this.orientation = GetOrientationMode(orientation);
        return this;
      }
    }, {
      key: "setItemSpacing",
      value: function setItemSpacing(space) {
        this.space.item = space;
        return this;
      }
    }, {
      key: "setRTL",
      value: function setRTL(enable) {
        if (enable === undefined) {
          enable = true;
        }

        this.rtl = enable;
        return this;
      }
    }, {
      key: "childrenProportion",
      get: function get() {
        if (this._childrenProportion === undefined) {
          this._childrenProportion = GetChildrenProportion.call(this);
        }

        return this._childrenProportion;
      }
    }]);

    return Sizer;
  }(Base);

  Object.assign(Sizer.prototype, methods$c);

  ObjectFactory.register('sizer', function (x, y, minWidth, minHeight, orientation, config) {
    var gameObject = new Sizer(this.scene, x, y, minWidth, minHeight, orientation, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Sizer', Sizer);

  var Sum = function Sum() {
    return Array.prototype.reduce.call(arguments, Add$5, 0);
  };

  var Add$5 = function Add(a, b) {
    return a + b;
  };

  var GetChildrenWidth$2 = function GetChildrenWidth() {
    if (this.rexSizer.hidden) {
      return 0;
    }

    var result = 0,
        columnWidth;
    var children = this.sizerChildren;
    var child, padding, childWidth, proportion;

    for (var i = 0; i < this.columnCount; i++) {
      proportion = this.columnProportions[i];
      columnWidth = 0;

      if (proportion === 0) {
        for (var j = 0; j < this.rowCount; j++) {
          child = children[j * this.columnCount + i];

          if (!child) {
            continue;
          }

          if (child.rexSizer.hidden) {
            continue;
          }

          padding = child.rexSizer.padding;
          childWidth = this.getChildWidth(child) + padding.left + padding.right;
          columnWidth = Math.max(columnWidth, childWidth);
        }

        result += columnWidth;
      } // else,(proportion > 0) : columnWidth is 0


      this.columnWidth[i] = columnWidth;
    }

    return result + Sum.apply(void 0, [this.space.left].concat(_toConsumableArray(this.space.column), [this.space.right]));
  };

  var GetChildrenHeight$2 = function GetChildrenHeight() {
    if (this.rexSizer.hidden) {
      return 0;
    }

    var result = 0,
        rowHeight;
    var children = this.sizerChildren;
    var child, padding, childHeight, proportion;

    for (var i = 0; i < this.rowCount; i++) {
      proportion = this.rowProportions[i];
      rowHeight = 0;

      if (proportion === 0) {
        for (var j = 0; j < this.columnCount; j++) {
          child = children[i * this.columnCount + j];

          if (!child) {
            continue;
          }

          if (child.rexSizer.hidden) {
            continue;
          }

          childHeight = child.isRexSizer ? Math.max(child.minHeight, child.childrenHeight) : child.hasOwnProperty('minHeight') ? child.minHeight : GetDisplayHeight(child);
          padding = child.rexSizer.padding;
          childHeight += padding.top + padding.bottom;
          rowHeight = Math.max(rowHeight, childHeight);
        }

        result += rowHeight;
      } // else,(proportion > 0) : rowHeight is 0


      this.rowHeight[i] = rowHeight;
    }

    return result + Sum.apply(void 0, [this.space.top].concat(_toConsumableArray(this.space.row), [this.space.bottom]));
  };

  var GetExpandedChildWidth = function GetExpandedChildWidth(child, colWidth) {
    var childWidth;
    var childConfig = child.rexSizer;

    if (childConfig.expand) {
      var padding = childConfig.padding;
      childWidth = colWidth - padding.left - padding.right;
    }

    return childWidth;
  };

  var GetExpandedChildHeight = function GetExpandedChildHeight(child, rowHeight) {
    var childHeight;
    var childConfig = child.rexSizer;

    if (childConfig.expand) {
      var padding = childConfig.padding;
      childHeight = rowHeight - padding.top - padding.bottom;
    }

    return childHeight;
  };

  var GetChildrenSizers$2 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }

    var children = this.sizerChildren,
        child;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child && child.isRexSizer) {
        out.push(child);
      }
    }

    return out;
  };

  var PreLayout$2 = function PreLayout() {
    this._totalColumnProportions = undefined;
    this._totalRowProportions = undefined;
    this.proportionWidthLength = undefined;
    this.proportionHeightLength = undefined;
    PreLayout$4.call(this);
    return this;
  };

  var LayoutChildren$3 = function LayoutChildren() {
    var child, childConfig, padding;
    var startX = this.innerLeft,
        startY = this.innerTop;
    var itemX = startX,
        itemY = startY;
    var x, y, width, height; // Align zone

    var childWidth, childHeight; // Layout grid children

    var columnSpace = this.space.column;
    var rowSpace = this.space.row;
    var colWidth, rowHeight;

    for (var rowIndex = 0; rowIndex < this.rowCount; rowIndex++) {
      rowHeight = this.getRowHeight(rowIndex);
      itemX = startX;

      for (var columnIndex = 0; columnIndex < this.columnCount; columnIndex++) {
        colWidth = this.getColumnWidth(columnIndex);
        child = this.getChildAt(columnIndex, rowIndex);

        if (!child || child.rexSizer.hidden) {
          itemX += colWidth + columnSpace[columnIndex];
          continue;
        }

        PreLayoutChild.call(this, child);
        childWidth = this.getExpandedChildWidth(child, colWidth);
        childHeight = this.getExpandedChildHeight(child, rowHeight);

        if (child.isRexSizer) {
          child.runLayout(this, childWidth, childHeight);
          CheckSize(child, this);
        } else {
          ResizeGameObject(child, childWidth, childHeight);
        }

        childConfig = child.rexSizer;
        padding = childConfig.padding;
        x = itemX + padding.left;
        width = colWidth - padding.left - padding.right;
        y = itemY + padding.top;
        height = rowHeight - padding.top - padding.bottom;
        LayoutChild.call(this, child, x, y, width, height, childConfig.align);
        itemX += colWidth + columnSpace[columnIndex];
      }

      itemY += rowHeight + rowSpace[rowIndex];
    }
  };

  var ResolveWidth = function ResolveWidth(width) {
    var width = ResolveWidth$2.call(this, width); // Get proportionLength

    if (this.proportionWidthLength === undefined) {
      var totalColumnProportions = this.totalColumnProportions;

      if (totalColumnProportions > 0) {
        var remainder = width - this.childrenWidth;

        if (remainder >= 0) {
          this.proportionWidthLength = remainder / totalColumnProportions;
        }
      } else {
        this.proportionWidthLength = 0;
      }
    }

    return width;
  };

  var ResolveHeight = function ResolveHeight(parent, height) {
    var height = ResolveHeight$2.call(this, parent, height); // Get proportionLength    

    if (this.proportionHeightLength === undefined) {
      var totalRowProportions = this.totalRowProportions;

      if (totalRowProportions > 0) {
        var remainder = height - this.childrenHeight;

        if (remainder >= 0) {
          this.proportionHeightLength = remainder / totalRowProportions;
        }
      } else {
        this.proportionHeightLength = 0;
      }
    }

    return height;
  };

  var ResolveChildrenWidth = function ResolveChildrenWidth(parentWidth) {
    // Resolve width of sizer children
    var child, childWidth;
    var colWidth;

    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];

      if (child && child.isRexSizer && !child.ignoreLayout) {
        colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
        childWidth = this.getExpandedChildWidth(child, colWidth);
        childWidth = child.resolveWidth(childWidth);
        child.resolveChildrenWidth(childWidth);
      }
    }
  };

  // Default method
  var RunWidthWrap$1 = function RunWidthWrap(width) {
    var child, childWidth;
    var colWidth;

    for (var i in this.sizerChildren) {
      child = this.sizerChildren[i];

      if (!child || child.isRexSizer && child.ignoreLayout || !child.runWidthWrap) {
        continue;
      }

      colWidth = this.getColumnWidth(parseInt(i) % this.columnCount);
      childWidth = this.getExpandedChildWidth(child, colWidth);

      if (child.isRexSizer) {
        childWidth = child.resolveWidth(childWidth);
      }

      child.runWidthWrap(childWidth);
    }

    return this;
  };

  var IsPlainObject$8 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$T = Phaser.Utils.Objects.GetValue;
  var ALIGN_CENTER$1 = Phaser.Display.Align.CENTER;

  var GetEmptyCellIndex = function GetEmptyCellIndex(columnIndex, rowIndex, cells, columnCount, rowCount) {
    if (typeof columnIndex === 'number' || typeof rowIndex === 'number') {
      if (columnIndex === undefined) {
        var idx;

        for (var i = 0; i < columnCount; i++) {
          idx = rowIndex * columnCount + i;

          if (!cells[idx]) {
            return idx;
          }
        }
      } else if (rowIndex === undefined) {
        var idx;

        for (var i = 0; i < rowCount; i++) {
          idx = i * columnCount + columnIndex;

          if (!cells[idx]) {
            return idx;
          }
        }
      } else {
        var idx = rowIndex * columnCount + columnIndex;

        if (!cells[idx]) {
          return idx;
        }
      }
    } else if (rowIndex === true) {
      var idx;

      for (var i = 0; i < columnCount; i++) {
        for (var j = 0; j < rowCount; j++) {
          idx = j * columnCount + i;

          if (!cells[idx]) {
            return idx;
          }
        }
      }
    } else {
      for (var i = 0, cnt = cells.length; i < cnt; i++) {
        if (!cells[i]) {
          return i;
        }
      }
    }

    return null;
  };

  var Add$4 = function Add(gameObject, columnIndex, rowIndex, align, paddingConfig, expand, childKey) {
    AddChild.call(this, gameObject);

    if (IsPlainObject$8(columnIndex)) {
      var config = columnIndex;
      columnIndex = GetValue$T(config, 'column', undefined);
      rowIndex = GetValue$T(config, 'row', undefined);
      align = GetValue$T(config, 'align', ALIGN_CENTER$1);
      paddingConfig = GetValue$T(config, 'padding', 0);
      expand = GetValue$T(config, 'expand', false);
      childKey = GetValue$T(config, 'key', undefined);
    } // Get insert index


    var itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);

    if (itemIndex === null) {
      // Specific index mode
      if (typeof columnIndex === 'number' && typeof rowIndex === 'number') {
        return this;
      }

      if (rowIndex === true || typeof rowIndex === 'number') {
        this.addEmptyColumn();
      } else {
        this.addEmptyRow();
      } // Get insert index again


      itemIndex = GetEmptyCellIndex(columnIndex, rowIndex, this.sizerChildren, this.columnCount, this.rowCount);
    }

    if (typeof align === 'string') {
      align = ALIGNMODE[align];
    }

    if (align === undefined) {
      align = ALIGN_CENTER$1;
    }

    if (paddingConfig === undefined) {
      paddingConfig = 0;
    }

    if (expand === undefined) {
      expand = true;
    }

    var config = this.getSizerConfig(gameObject);
    config.align = align;
    config.padding = GetBoundsConfig(paddingConfig);
    config.expand = expand;
    this.sizerChildren[itemIndex] = gameObject;

    if (childKey !== undefined) {
      this.addChildrenMap(childKey, gameObject);
    }

    return this;
  };

  var AddChildMethods$5 = {
    add: Add$4
  };

  var Fill = function Fill(arr, value, startIdx, endIdx) {
    if (startIdx === undefined) {
      startIdx = 0;
    }

    if (endIdx === undefined) {
      endIdx = arr.length - 1;
    }

    for (var i = startIdx; i <= endIdx; i++) {
      arr[i] = value;
    }

    return arr;
  };

  var RemoveChildMethods$4 = {
    remove: function remove(gameObject, destroyChild) {
      if (this.getParentSizer(gameObject) !== this) {
        return this;
      }

      var idx = this.sizerChildren.indexOf(gameObject);

      if (idx !== -1) {
        this.sizerChildren[idx] = null;
      }

      RemoveChild.call(this, gameObject, destroyChild);
      return this;
    },
    removeAt: function removeAt(columnIndex, rowIndex, destroyChild) {
      var child = this.getChildAt(columnIndex, rowIndex);

      if (child) {
        this.remove(child, destroyChild);
      }

      return this;
    },
    removeAll: function removeAll(destroyChild) {
      for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
        var child = this.sizerChildren[i];

        if (!child) {
          continue;
        }

        this.remove(child, destroyChild);
      }

      return this;
    },
    clear: function clear(destroyChild) {
      Fill(this.sizerChildren, null);
      ClearChildren.call(this, destroyChild);
      return this;
    }
  };

  var GetValue$S = Phaser.Utils.Objects.GetValue;

  var ResetGrid = function ResetGrid(columnCount, rowCount, columnProportions, rowProportions, space) {
    if (columnProportions === undefined) {
      columnProportions = 0;
    }

    if (rowProportions === undefined) {
      rowProportions = 0;
    }

    this.columnCount = columnCount;
    this.rowCount = rowCount;
    this.gridCount = columnCount * rowCount; // children

    if (this.sizerChildren === undefined) {
      this.sizerChildren = [];
    } else {
      this.removeAll();
    }

    this.sizerChildren.length = columnCount * rowCount;
    Fill(this.sizerChildren, null); // proportions

    this.columnProportions = [];
    this.columnProportions.length = columnCount;

    if (typeof columnProportions === 'number') {
      Fill(this.columnProportions, columnProportions);
    } else {
      for (var i = 0; i < columnCount; i++) {
        this.columnProportions[i] = columnProportions[i] || 0;
      }
    }

    this.rowProportions = [];
    this.rowProportions.length = rowCount;

    if (typeof rowProportions === 'number') {
      Fill(this.rowProportions, rowProportions);
    } else {
      for (var i = 0; i < rowCount; i++) {
        this.rowProportions[i] = rowProportions[i] || 0;
      }
    } // width & height


    this.columnWidth = [];
    this.columnWidth.length = columnCount;
    this.rowHeight = [];
    this.rowHeight.length = rowCount; // space

    this.space.column = [];
    this.space.column.length = columnCount - 1;
    var columnSpace = GetValue$S(space, 'column', 0);

    if (typeof columnSpace === 'number') {
      Fill(this.space.column, columnSpace);
    } else {
      for (var i = 0, cnt = this.space.column.length; i < cnt; i++) {
        this.space.column[i] = columnSpace[i] || 0;
      }
    }

    this.space.row = [];
    this.space.row.length = rowCount - 1;
    var rowSpace = GetValue$S(space, 'row', 0);

    if (typeof rowSpace === 'number') {
      Fill(this.space.row, rowSpace);
    } else {
      for (var i = 0, cnt = this.space.row.length; i < cnt; i++) {
        this.space.row[i] = rowSpace[i] || 0;
      }
    }

    return this;
  };

  var InseryEmptyRow = function InseryEmptyRow(rowIndex, proportion, space) {
    if (proportion === undefined) {
      proportion = this.rowProportions[0] || 0;
    }

    if (space === undefined) {
      space = this.space.row[0] || 0;
    }

    this.rowCount += 1;
    this.gridCount += this.columnCount;
    var args = [rowIndex * this.columnCount, 0];

    for (var i = 0; i < this.columnCount; i++) {
      args.push(null);
    }

    this.sizerChildren.splice.apply(this.sizerChildren, args);
    this.rowProportions.push(proportion);
    this.rowHeight.length += 1; // this.rowHeight will be recalculated when layout()    

    this.space.row.splice(rowIndex, 0, space);
    return this;
  };

  var AddEmptyRow = function AddEmptyRow(proportion, space) {
    InseryEmptyRow.call(this, this.rowCount, proportion, space);
    return this;
  };

  var InsertEmptyColumn = function InsertEmptyColumn(colIndex, proportion, space) {
    if (proportion === undefined) {
      proportion = this.columnProportions[0] || 0;
    }

    if (space === undefined) {
      space = this.space.column[0] || 0;
    }

    this.columnCount += 1;
    this.gridCount += this.rowCount;

    for (var i = this.rowCount - 1; i >= 0; i--) {
      var insertIndex = i * this.columnCount + colIndex;
      this.sizerChildren.splice(insertIndex, 0, null);
    }

    this.columnProportions.push(proportion);
    this.columnWidth.length += 1; // this.columnWidth will be recalculated when layout()    

    this.space.column.splice(colIndex, 0, space);
    return this;
  };

  var AddEmptyColumn = function AddEmptyColumn(proportion, space) {
    InsertEmptyColumn.call(this, this.columnCount, proportion, space);
    return this;
  };

  var methods$b = {
    getChildrenWidth: GetChildrenWidth$2,
    getChildrenHeight: GetChildrenHeight$2,
    getExpandedChildWidth: GetExpandedChildWidth,
    getExpandedChildHeight: GetExpandedChildHeight,
    getChildrenSizers: GetChildrenSizers$2,
    preLayout: PreLayout$2,
    layoutChildren: LayoutChildren$3,
    resolveWidth: ResolveWidth,
    resolveHeight: ResolveHeight,
    resolveChildrenWidth: ResolveChildrenWidth,
    runWidthWrap: RunWidthWrap$1,
    resetGrid: ResetGrid,
    inseryEmptyRow: InseryEmptyRow,
    addEmptyRow: AddEmptyRow,
    insertEmptyColumn: InsertEmptyColumn,
    addEmptyColumn: AddEmptyColumn
  };
  Object.assign(methods$b, AddChildMethods$5, RemoveChildMethods$4);

  var GetTotalColumnProportions = function GetTotalColumnProportions() {
    var result = 0,
        proportion;

    for (var i = 0; i < this.columnCount; i++) {
      proportion = this.columnProportions[i];

      if (proportion > 0) {
        result += proportion;
      }
    }

    return result;
  };

  var GetTotalRowProportions = function GetTotalRowProportions() {
    var result = 0,
        proportion;

    for (var i = 0; i < this.rowCount; i++) {
      proportion = this.rowProportions[i];

      if (proportion > 0) {
        result += proportion;
      }
    }

    return result;
  };

  var IsPlainObject$7 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$R = Phaser.Utils.Objects.GetValue;

  var GridSizer = /*#__PURE__*/function (_BaseSizer) {
    _inherits(GridSizer, _BaseSizer);

    var _super = _createSuper(GridSizer);

    function GridSizer(scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportions, config) {
      var _this;

      _classCallCheck(this, GridSizer);

      if (IsPlainObject$7(x)) {
        config = x;
        x = GetValue$R(config, 'x', 0);
        y = GetValue$R(config, 'y', 0);
        minWidth = GetValue$R(config, 'width', undefined);
        minHeight = GetValue$R(config, 'height', undefined);
        columnCount = GetValue$R(config, 'column', 0);
        rowCount = GetValue$R(config, 'row', 0);
        columnProportions = GetValue$R(config, 'columnProportions', 0);
        rowProportions = GetValue$R(config, 'rowProportions', 0);
      } else if (IsPlainObject$7(minWidth)) {
        config = minWidth;
        minWidth = GetValue$R(config, 'width', undefined);
        minHeight = GetValue$R(config, 'height', undefined);
        columnCount = GetValue$R(config, 'column', 0);
        rowCount = GetValue$R(config, 'row', 0);
        columnProportions = GetValue$R(config, 'columnProportions', 0);
        rowProportions = GetValue$R(config, 'rowProportions', 0);
      } else if (IsPlainObject$7(columnCount)) {
        config = columnCount;
        columnCount = GetValue$R(config, 'column', 0);
        rowCount = GetValue$R(config, 'row', 0);
        columnProportions = GetValue$R(config, 'columnProportions', 0);
        rowProportions = GetValue$R(config, 'rowProportions', 0);
      } else if (IsPlainObject$7(columnProportions)) {
        config = columnProportions;
        columnProportions = GetValue$R(config, 'columnProportions', 0);
        rowProportions = GetValue$R(config, 'rowProportions', 0);
      }

      _this = _super.call(this, scene, x, y, minWidth, minHeight, config);
      _this.type = 'rexGridSizer';

      _this.resetGrid(columnCount, rowCount, columnProportions, rowProportions, GetValue$R(config, 'space', undefined));

      _this.addChildrenMap('items', _this.sizerChildren);

      var createCellContainerCallback = GetValue$R(config, 'createCellContainerCallback');

      if (createCellContainerCallback) {
        for (var y = 0, ycnt = _this.rowCount; y < ycnt; y++) {
          for (var x = 0, xcnt = _this.columnCount; x < xcnt; x++) {
            var addConfig = {
              column: x,
              row: y
            };
            var child = createCellContainerCallback(scene, x, y, addConfig);

            if (child) {
              _this.add(child, addConfig);
            }
          }
        }
      }

      return _this;
    }

    _createClass(GridSizer, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        _get(_getPrototypeOf(GridSizer.prototype), "destroy", this).call(this, fromScene); // More free resources


        this.columnProportions = undefined;
        this.rowProportions = undefined;
        this.columnWidth = undefined;
        this.rowHeight = undefined;
      }
    }, {
      key: "setColumnProportion",
      value: function setColumnProportion(columnIndex, proportion) {
        if (columnIndex >= this.columnProportions.length) {
          return this;
        }

        this.columnProportions[columnIndex] = proportion;
        return this;
      }
    }, {
      key: "setRowProportion",
      value: function setRowProportion(rowIndex, proportion) {
        if (rowIndex >= this.rowProportions.length) {
          return this;
        }

        this.rowProportions[rowIndex] = proportion;
        return this;
      }
    }, {
      key: "totalColumnProportions",
      get: function get() {
        if (this._totalColumnProportions === undefined) {
          this._totalColumnProportions = GetTotalColumnProportions.call(this);
        }

        return this._totalColumnProportions;
      }
    }, {
      key: "totalRowProportions",
      get: function get() {
        if (this._totalRowProportions === undefined) {
          this._totalRowProportions = GetTotalRowProportions.call(this);
        }

        return this._totalRowProportions;
      }
    }, {
      key: "getChildAt",
      value: function getChildAt(columnIndex, rowIndex) {
        return this.sizerChildren[rowIndex * this.columnCount + columnIndex];
      }
    }, {
      key: "childToGridIndex",
      value: function childToGridIndex(child, out) {
        if (!child) {
          return null;
        }

        var index = this.sizerChildren.indexOf(child);

        if (index === -1) {
          return null;
        }

        if (out === undefined) {
          out = {};
        }

        out.x = index % this.columnCount;
        out.y = Math.floor(index / this.columnCount);
        return out;
      }
    }, {
      key: "getColumnWidth",
      value: function getColumnWidth(columnIndex) {
        var colProportion = this.columnProportions[columnIndex];
        var colWidth = colProportion === 0 ? this.columnWidth[columnIndex] : colProportion * this.proportionWidthLength;
        return colWidth;
      }
    }, {
      key: "getRowHeight",
      value: function getRowHeight(rowIndex) {
        var rowProportion = this.rowProportions[rowIndex];
        var rowHeight = rowProportion === 0 ? this.rowHeight[rowIndex] : rowProportion * this.proportionHeightLength;
        return rowHeight;
      }
    }]);

    return GridSizer;
  }(Base);

  Object.assign(GridSizer.prototype, methods$b);

  ObjectFactory.register('gridSizer', function (x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportion, config) {
    var gameObject = new GridSizer(this.scene, x, y, minWidth, minHeight, columnCount, rowCount, columnProportions, rowProportion, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.GridSizer', GridSizer);

  var GetChildrenWidth$1 = function GetChildrenWidth() {
    if (this.rexSizer.hidden) {
      return 0;
    } // Before RunChildrenWrap


    return this.maxChildWidth + this.space.left + this.space.right;
  };

  var GetChildrenHeight$1 = function GetChildrenHeight() {
    if (this.rexSizer.hidden) {
      return 0;
    } // After RunChildrenWrap


    return this.widthWrapResult.height + this.space.top + this.space.bottom;
  };

  var GetChildrenSizers$1 = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }

    var children = this.sizerChildren,
        child;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child === '\n') {
        continue;
      }

      if (child.isRexSizer) {
        out.push(child);
      }
    }

    return out;
  };

  var PreLayout$1 = function PreLayout() {
    this._maxChildWidth = undefined;
    this._maxChildHeight = undefined;
    PreLayout$4.call(this);
    return this;
  };

  var LayoutChildren$2 = function LayoutChildren() {
    var innerLineWidth = this.innerWidth;
    var justifyPercentage = this.justifyPercentage;
    var child,
        childConfig,
        padding,
        justifySpace = 0;
    var startX = this.innerLeft,
        startY = this.innerTop;
    var itemX = startX,
        itemY = startY;
    var x, y, width, height; // Align zone

    var lines = this.widthWrapResult.lines;
    var line, lineChlidren, remainderLineWidth;

    for (var i = 0, icnt = lines.length; i < icnt; i++) {
      line = lines[i];
      lineChlidren = line.children;

      if (this.rtl) {
        lineChlidren.reverse();
      }

      remainderLineWidth = innerLineWidth - line.width;

      switch (this.align) {
        case 0:
          // left
          break;

        case 1:
          // right
          itemX += remainderLineWidth;
          break;

        case 2:
          // center
          itemX += remainderLineWidth / 2;
          break;

        case 3:
          // justify-left
          justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);
          break;

        case 4:
          // justify-right
          justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);

          if (justifySpace === 0) {
            // Align right
            itemX += remainderLineWidth;
          }

          break;

        case 5:
          // justify-center
          justifySpace = GetJustifySpace(innerLineWidth, remainderLineWidth, justifyPercentage, lineChlidren.length);

          if (justifySpace === 0) {
            // Align center
            itemX += remainderLineWidth / 2;
          }

          break;
      }

      for (var j = 0, jcnt = lineChlidren.length; j < jcnt; j++) {
        child = lineChlidren[j];

        if (child.rexSizer.hidden) {
          continue;
        }

        childConfig = child.rexSizer;
        padding = childConfig.padding;
        PreLayoutChild.call(this, child);
        x = itemX + padding.left;

        if (j > 0) {
          x += this.space.item;
        }

        y = itemY + padding.top;
        width = GetDisplayWidth(child);
        height = GetDisplayHeight(child);
        itemX = x + width + padding.right + justifySpace;
        LayoutChild.call(this, child, x, y, width, height, childConfig.align);
      }

      itemX = startX;
      itemY += line.height + this.space.line;
    }
  };

  var GetJustifySpace = function GetJustifySpace(total, remainder, justifyPercentage, childCount) {
    return remainder / total <= justifyPercentage ? remainder / (childCount - 1) : 0;
  };

  var RunChildrenWrap = function RunChildrenWrap(lineWidth, out) {
    if (out === undefined) {
      out = {
        lines: [],
        width: 0,
        height: 0
      };
    } else {
      out.lines.length = 0;
      out.width = 0;
      out.height = 0;
    }

    var children = this.sizerChildren;
    var child,
        childWidth,
        childHeight,
        remainder = 0;
    var lines = out.lines,
        lastLine = undefined,
        newLine;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child === '\n') {
        child = undefined;
        childWidth = 0;
        newLine = true;
      } else {
        if (child.rexSizer.hidden) {
          continue;
        }

        if (child.isRexSizer) {
          child.layout(); // Use original size
        }

        childWidth = GetChildWidth(child);
        newLine = remainder < childWidth || lastLine === undefined;
      } // New line


      if (newLine) {
        if (lastLine) {
          lastLine.width = lineWidth - (remainder + this.space.item);
          out.width = Math.max(out.width, lastLine.width);
          out.height += lastLine.height + this.space.line;
        }

        lastLine = {
          children: [],
          // width: 0,
          height: 0
        };
        lines.push(lastLine);
        remainder = lineWidth;
      }

      remainder -= childWidth + this.space.item;

      if (child) {
        lastLine.children.push(child);
        childHeight = GeChildHeight(child);
        lastLine.height = Math.max(lastLine.height, childHeight);
      }
    }

    if (lastLine) {
      lastLine.width = lineWidth - (remainder + this.space.item);
      out.width = Math.max(out.width, lastLine.width);
      out.height += lastLine.height;
    }

    return out;
  };

  var GetChildWidth = function GetChildWidth(child) {
    var padding = child.rexSizer.padding;
    return GetDisplayWidth(child) + padding.left + padding.right;
  };

  var GeChildHeight = function GeChildHeight(child) {
    var padding = child.rexSizer.padding;
    return GetDisplayHeight(child) + padding.top + padding.bottom;
  };

  var RunWidthWrap = function RunWidthWrap(width) {
    var innerWidth = width - this.space.left - this.space.right;
    this.widthWrapResult = RunChildrenWrap.call(this, innerWidth, this.widthWrapResult);
    RunWidthWrap$2.call(this, width);
  };

  var DistanceBetween$2 = Phaser.Math.Distance.Between;

  var GetNearestChildIndex = function GetNearestChildIndex(x, y) {
    var children = this.sizerChildren;

    if (children.length === 0) {
      return -1;
    }

    var nearestIndex = -1,
        minDistance = Infinity;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      var child = children[i]; // position is not at this line

      if (Math.abs(child.centerY - y) > child.height / 2) {
        continue;
      } // Check left bound


      var distance = DistanceBetween$2(child.left, child.centerY, x, y);

      if (minDistance > distance) {
        minDistance = distance;
        nearestIndex = i;
      } // Is last child of this line


      var nextChild = children[i + 1];

      if (nextChild && nextChild.y === child.y) {
        continue;
      }

      var distance = DistanceBetween$2(child.right, child.centerY, x, y);

      if (minDistance > distance) {
        minDistance = distance;
        nearestIndex = i + 1;
      }
    }

    return nearestIndex;
  };

  var IsPlainObject$6 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$Q = Phaser.Utils.Objects.GetValue;
  var ALIGN_CENTER = Phaser.Display.Align.CENTER;

  var Add$3 = function Add(gameObject, paddingConfig, childKey, index) {
    if (gameObject === '\n') {
      this.addNewLine();
      return this;
    }

    AddChild.call(this, gameObject);

    if (IsPlainObject$6(paddingConfig)) {
      var config = paddingConfig;
      paddingConfig = GetValue$Q(config, 'padding', 0);
      childKey = GetValue$Q(config, 'key', undefined);
      index = GetValue$Q(config, 'index', undefined);
    }

    if (paddingConfig === undefined) {
      paddingConfig = 0;
    }

    var config = this.getSizerConfig(gameObject);
    config.align = ALIGN_CENTER;
    config.padding = GetBoundsConfig(paddingConfig);

    if (index === undefined || index >= this.sizerChildren.length) {
      this.sizerChildren.push(gameObject);
    } else {
      this.sizerChildren.splice(index, 0, gameObject);
    }

    if (childKey !== undefined) {
      this.addChildrenMap(childKey, gameObject);
    }

    return this;
  };

  var AddChildMethods$4 = {
    add: function add(gameObject, paddingConfig, childKey) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;

        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$3.call(this, gameObjects[i], paddingConfig);
        }
      } else {
        Add$3.call(this, gameObject, paddingConfig, childKey);
      }

      return this;
    },
    addNewLine: function addNewLine() {
      this.sizerChildren.push('\n');
      return this;
    },
    insert: function insert(index, gameObject, paddingConfig, childKey) {
      Add$3.call(this, gameObject, paddingConfig, childKey, index);
      return this;
    },
    insertAtPosition: function insertAtPosition(x, y, gameObject, paddingConfig, childKey) {
      var index = GetNearestChildIndex.call(this, x, y);

      if (index === -1) {
        index = undefined;
      }

      this.insert(index, gameObject, paddingConfig, childKey);
      return this;
    }
  };

  var RemoveItem$4 = Phaser.Utils.Array.Remove;
  var RemoveChildMethods$3 = {
    remove: function remove(gameObject, destroyChild) {
      if (this.getParentSizer(gameObject) !== this) {
        return this;
      }

      RemoveItem$4(this.sizerChildren, gameObject);
      RemoveChild.call(this, gameObject, destroyChild);
      return this;
    },
    removeAll: function removeAll(destroyChild) {
      for (var i = this.sizerChildren.length - 1; i >= 0; i--) {
        this.remove(this.sizerChildren[i], destroyChild);
      }

      return this;
    },
    clear: function clear(destroyChild) {
      this.sizerChildren.length = 0;
      ClearChildren.call(this, destroyChild);
      return this;
    }
  };

  var methods$a = {
    getChildrenWidth: GetChildrenWidth$1,
    getChildrenHeight: GetChildrenHeight$1,
    getChildrenSizers: GetChildrenSizers$1,
    preLayout: PreLayout$1,
    layoutChildren: LayoutChildren$2,
    runWidthWrap: RunWidthWrap
  };
  Object.assign(methods$a, AddChildMethods$4, RemoveChildMethods$3);

  var GetMaxChildWidth = function GetMaxChildWidth(children) {
    if (children === undefined) {
      children = this.sizerChildren;
    }

    var result = 0;
    var child, childWidth;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child === '\n') {
        continue;
      }

      childWidth = this.getChildWidth(child);
      result = Math.max(childWidth, result);
    }

    return result;
  };

  var GetMaxChildHeight = function GetMaxChildHeight(children) {
    if (children === undefined) {
      children = this.sizerChildren;
    }

    var result = 0;
    var child, childHeight;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child === '\n') {
        continue;
      }

      childHeight = child.isRexSizer ? Math.max(child.minHeight, child.childrenHeight) : child.hasOwnProperty('minHeight') ? child.minHeight : GetDisplayHeight(child);
      result = Math.max(childHeight, result);
    }

    return result;
  };

  var IsPlainObject$5 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$P = Phaser.Utils.Objects.GetValue;

  var FixWidthSizer = /*#__PURE__*/function (_BaseSizer) {
    _inherits(FixWidthSizer, _BaseSizer);

    var _super = _createSuper(FixWidthSizer);

    function FixWidthSizer(scene, x, y, minWidth, minHeight, config) {
      var _this;

      _classCallCheck(this, FixWidthSizer);

      if (IsPlainObject$5(x)) {
        config = x;
        x = GetValue$P(config, 'x', 0);
        y = GetValue$P(config, 'y', 0);
        minWidth = GetValue$P(config, 'width', undefined);
        minHeight = GetValue$P(config, 'height', undefined);
      } else if (IsPlainObject$5(minWidth)) {
        config = minWidth;
        minWidth = GetValue$P(config, 'width', undefined);
        minHeight = GetValue$P(config, 'height', undefined);
      }

      _this = _super.call(this, scene, x, y, minWidth, minHeight, config);
      _this.type = 'rexFixWidthSizer';
      _this.sizerChildren = [];

      _this.setOrientation(GetValue$P(config, 'orientation', 0));

      _this.setItemSpacing(GetValue$P(config, 'space.item', 0));

      _this.setLineSpacing(GetValue$P(config, 'space.line', 0));

      _this.setAlign(GetValue$P(config, 'align', 0));

      _this.setJustifyPercentage(GetValue$P(config, 'justifyPercentage', 0.25));

      _this.setRTL(GetValue$P(config, 'rtl', false));

      _this.addChildrenMap('items', _this.sizerChildren);

      return _this;
    }

    _createClass(FixWidthSizer, [{
      key: "setOrientation",
      value: function setOrientation(orientation) {
        this.orientation = GetOrientationMode(orientation);
        return this;
      }
    }, {
      key: "setItemSpacing",
      value: function setItemSpacing(space) {
        this.space.item = space;
        return this;
      }
    }, {
      key: "setLineSpacing",
      value: function setLineSpacing(space) {
        this.space.line = space;
        return this;
      }
    }, {
      key: "setAlign",
      value: function setAlign(align) {
        if (typeof align === 'string') {
          align = ALIGN[align];
        }

        this.align = align;
        return this;
      }
    }, {
      key: "setJustifyPercentage",
      value: function setJustifyPercentage(value) {
        this.justifyPercentage = value;
        return this;
      }
    }, {
      key: "setRTL",
      value: function setRTL(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }

        this.rtl = enabled;
        return this;
      }
    }, {
      key: "maxChildWidth",
      get: function get() {
        if (this._maxChildWidth === undefined) {
          this._maxChildWidth = GetMaxChildWidth.call(this);
        }

        return this._maxChildWidth;
      }
    }, {
      key: "maxChildHeight",
      get: function get() {
        if (this._maxChildHeight === undefined) {
          this._maxChildHeight = GetMaxChildHeight.call(this);
        }

        return this._maxChildHeight;
      }
    }]);

    return FixWidthSizer;
  }(Base);

  var ALIGN = {
    left: 0,
    top: 0,
    right: 1,
    bottom: 1,
    center: 2,
    justify: 3,
    'justify-left': 3,
    'justify-top': 3,
    'justify-right': 4,
    'justify-bottom': 4,
    'justify-center': 5
  };
  Object.assign(FixWidthSizer.prototype, methods$a);

  ObjectFactory.register('fixWidthSizer', function (x, y, minWidth, minHeight, config) {
    var gameObject = new FixWidthSizer(this.scene, x, y, minWidth, minHeight, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.FixWidthSizer', FixWidthSizer);

  ObjectFactory.register('overlapSizer', function (x, y, minWidth, minHeight, config) {
    var gameObject = new OverlapSizer(this.scene, x, y, minWidth, minHeight, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.OverlapSizer', OverlapSizer);

  ObjectFactory.register('space', function () {
    var gameObject = new Space(this.scene); // Don't add Zone into scene
    // this.scene.add.existing(gameObject);

    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Space', Space);

  var AddChildMask = function AddChildMask(maskTarget, sizeTarget, shape, padding) {
    var maskGameObject = new DefaultMaskGraphics(sizeTarget, shape, padding); // A Graphics game object

    if (maskTarget && !maskTarget.isRexSizer) {
      // Sizer game object can't apply mask
      var mask = maskGameObject.createGeometryMask();
      maskTarget.setMask(mask);
      this.once('destroy', function () {
        maskTarget.setMask();
        mask.destroy();
      });
    }

    this.pin(maskGameObject);
    return maskGameObject;
  };

  var GetValue$O = Phaser.Utils.Objects.GetValue;

  var Label = /*#__PURE__*/function (_Sizer) {
    _inherits(Label, _Sizer);

    var _super = _createSuper(Label);

    function Label(scene, config) {
      var _this;

      _classCallCheck(this, Label);

      // Create sizer
      _this = _super.call(this, scene, config);
      _this.type = 'rexLabel'; // Add elements

      var background = GetValue$O(config, 'background', undefined);
      var icon = GetValue$O(config, 'icon', undefined);
      var iconMask = GetValue$O(config, 'iconMask', undefined);
      var text = GetValue$O(config, 'text', undefined);
      var action = GetValue$O(config, 'action', undefined);
      var actionMask = GetValue$O(config, 'actionMask', undefined); // Align

      var align = GetValue$O(config, 'align', undefined); // undefined/left/top: no space
      // Space

      var iconSpace = GetValue$O(config, 'space.icon', 0);
      var textSpace = GetValue$O(config, 'space.text', 0);

      if (background) {
        _this.addBackground(background);
      } // Add space


      if (align === 'right' || align === 'bottom' || align === 'center') {
        _this.addSpace();
      }

      if (icon) {
        var padding;

        if (_this.orientation === 0) {
          if (text || action) {
            padding = {
              right: iconSpace
            };
          }
        } else {
          if (text || action) {
            padding = {
              bottom: iconSpace
            };
          }
        }

        _this.add(icon, 0, 'center', padding);

        if (iconMask) {
          iconMask = AddChildMask.call(_assertThisInitialized(_this), icon, icon, 1); // Circle mask
        }
      }

      if (text) {
        var expandTextWidth = GetValue$O(config, 'expandTextWidth', false);
        var expandTextHeight = GetValue$O(config, 'expandTextHeight', false);
        var proportion, padding, expand;

        if (_this.orientation === 0) {
          proportion = expandTextWidth ? 1 : 0;

          if (action) {
            padding = {
              right: textSpace
            };
          }

          expand = expandTextHeight;
        } else {
          proportion = expandTextHeight ? 1 : 0;

          if (action) {
            padding = {
              bottom: textSpace
            };
          }

          expand = expandTextWidth;
        }

        _this.add(text, proportion, 'center', padding, expand);
      }

      if (action) {
        _this.add(action);

        if (actionMask) {
          actionMask = AddChildMask.call(_assertThisInitialized(_this), action, action, 1); // Circle mask
        }
      } // Add space


      if (align === 'center') {
        _this.addSpace();
      }

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('icon', icon);

      _this.addChildrenMap('iconMask', iconMask);

      _this.addChildrenMap('text', text);

      _this.addChildrenMap('action', action);

      _this.addChildrenMap('actionMask', actionMask);

      return _this;
    } // Access text game object


    _createClass(Label, [{
      key: "text",
      get: function get() {
        var textObject = this.childrenMap.text;

        if (textObject === undefined) {
          return '';
        }

        return textObject.text;
      },
      set: function set(value) {
        var textObject = this.childrenMap.text;

        if (textObject === undefined) {
          return;
        }

        textObject.setText(value);
      }
    }, {
      key: "setText",
      value: function setText(value) {
        this.text = value;
        return this;
      }
    }, {
      key: "appendText",
      value: function appendText(value) {
        this.text += value;
        return this;
      } // Access icon game object

    }, {
      key: "setTexture",
      value: function setTexture(key, frame) {
        var imageObject = this.childrenMap.icon;

        if (imageObject === undefined) {
          return;
        }

        imageObject.setTexture(key, frame);
        return this;
      }
    }, {
      key: "texture",
      get: function get() {
        var imageObject = this.childrenMap.icon;

        if (imageObject === undefined) {
          return undefined;
        }

        return imageObject.texture;
      }
    }, {
      key: "frame",
      get: function get() {
        var imageObject = this.childrenMap.icon;

        if (imageObject === undefined) {
          return undefined;
        }

        return imageObject.frame;
      }
    }, {
      key: "runLayout",
      value: function runLayout(parent, newWidth, newHeight) {
        if (this.ignoreLayout) {
          return this;
        }

        _get(_getPrototypeOf(Label.prototype), "runLayout", this).call(this, parent, newWidth, newHeight); // Pin icon-mask to icon game object


        var iconMask = this.childrenMap.iconMask;

        if (iconMask) {
          iconMask.setPosition();
          this.resetChildPositionState(iconMask);
        } // Pin action-mask to action game object


        var actionMask = this.childrenMap.actionMask;

        if (actionMask) {
          actionMask.setPosition();
          this.resetChildPositionState(actionMask);
        }

        return this;
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        _get(_getPrototypeOf(Label.prototype), "resize", this).call(this, width, height); // Resize icon-mask to icon game object


        var iconMask = this.childrenMap.iconMask;

        if (iconMask) {
          iconMask.resize();
        } // Resize action-mask to icon game object


        var actionMask = this.childrenMap.actionMask;

        if (actionMask) {
          actionMask.resize();
        }

        return this;
      }
    }]);

    return Label;
  }(Sizer);

  ObjectFactory.register('label', function (config) {
    var gameObject = new Label(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Label', Label);

  var SizerAdd$2 = Sizer.prototype.add;
  var SizerAddSpace = Sizer.prototype.addSpace;

  var Add$2 = function Add(gameObject) {
    var isNormalGameObject = !gameObject.isRexSpace;
    var proportion = !isNormalGameObject || this.buttonsExpand ? 1 : 0;

    if (this.sizerChildren.length === 0) {
      // First element
      if (isNormalGameObject) {
        // Add space at head
        var hasHeadSpace = !this.buttonsExpand && (this.buttonsAlign === 'right' || this.buttonsAlign === 'center' || this.buttonsAlign === 'bottom');

        if (hasHeadSpace) {
          SizerAddSpace.call(this);
        }

        SizerAdd$2.call(this, gameObject, {
          proportion: proportion,
          expand: true
        }); // Add space at tail

        var hasTailSpace = !this.buttonsExpand && this.buttonsAlign === 'center';

        if (hasTailSpace) {
          SizerAddSpace.call(this);
        }

        this.hasTailSpace = hasTailSpace;
      } else {
        // A space
        SizerAdd$2.call(this, gameObject, {
          proportion: proportion,
          expand: true
        });
        this.hasTailSpace = false;
      }
    } else {
      // Others
      if (this.hasTailSpace) {
        var lastIndex = this.sizerChildren.length - 1;
        SizerAdd$2.call(this, gameObject, {
          index: lastIndex,
          proportion: proportion,
          expand: true
        });
      } else {
        SizerAdd$2.call(this, gameObject, {
          proportion: proportion,
          expand: true
        });
      }
    } // Space or other game object as button


    if (isNormalGameObject) {
      this.buttonGroup.add(gameObject);
    }

    return this;
  };

  var AddChildMethods$3 = {
    addButton: function addButton(gameObject) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;

        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$2.call(this, gameObjects[i]);
        }
      } else {
        Add$2.call(this, gameObject);
      }

      return this;
    },
    addButtons: function addButtons(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        Add$2.call(this, gameObjects[i]);
      }

      return this;
    }
  };

  var RemoveItem$3 = Phaser.Utils.Array.Remove;
  var SizerRmove$2 = Sizer.prototype.remove;
  var SizerClear$2 = Sizer.prototype.clear;

  var Remove$2 = function Remove(gameObject, destroyChild) {
    if (this.getParentSizer(gameObject) !== this) {
      return this;
    }

    var buttons = this.buttonGroup.buttons;
    RemoveItem$3(buttons, gameObject);
    SizerRmove$2.call(this, gameObject, destroyChild);
    return this;
  };

  var RemoveChildMethods$2 = {
    remove: function remove(gameObject, destroyChild) {
      // Remove gameObject no matter it is a button or not
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;

        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Remove$2.call(this, gameObjects[i], destroyChild);
        }
      } else {
        Remove$2.call(this, gameObject, destroyChild);
      }

      return this;
    },
    clear: function clear(destroyChild) {
      var buttons = this.buttonGroup.buttons;
      buttons.length = 0;
      SizerClear$2.call(this, destroyChild);
      return this;
    },
    removeButton: function removeButton(gameObject, destroyChild) {
      var gameObject = this.getButton(gameObject); // Don't remove this gameObject, it is not a button

      if (!gameObject) {
        return this;
      }

      this.remove(gameObject, destroyChild);
      return this;
    },
    clearButtons: function clearButtons(destroyChild) {
      var buttons = this.buttonGroup.buttons;

      for (var i = buttons.length - 1; i >= 0; i--) {
        Remove$2.call(this, buttons[i], destroyChild);
      }

      return this;
    }
  };

  var AddMethods = {
    add: function add(gameObject) {
      this.buttons.push(gameObject); //Default: Fire 'click' event when touch released after pressed.

      gameObject._buttonBehavior = new Button(gameObject, this.clickConfig);

      gameObject._buttonBehavior.on('click', function (buttonBehavior, gameObject, pointer, event) {
        this.fireEvent('button.click', gameObject, pointer, event);
      }, this).on('enable', function (buttonBehavior, gameObject) {
        this.fireEvent('button.enable', gameObject);
      }, this).on('disable', function (buttonBehavior, gameObject) {
        this.fireEvent('button.disable', gameObject);
      }, this);

      gameObject.on('pointerover', function (pointer, localX, localY, event) {
        this.fireEvent('button.over', gameObject, pointer, event);
      }, this).on('pointerout', function (pointer, event) {
        this.fireEvent('button.out', gameObject, pointer, event);
      }, this);
      return this;
    },
    addMultiple: function addMultiple(gameObjects) {
      for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
        this.add(gameObject[i]);
      }

      return this;
    }
  };

  var FireEvent = function FireEvent(eventName, button, pointer, event) {
    var index;

    if (typeof button === 'number') {
      index = button;
      button = this.buttons[index];

      if (!button) {
        return;
      }
    } else {
      index = this.buttons.indexOf(button);

      if (index === -1) {
        return;
      }
    } // Buttons is a child. Fire internal events.


    if (this.eventEmitter !== this.parent) {
      this.parent.emit(eventName, button, index, pointer, event);
    }

    if (this.groupName !== undefined) {
      this.eventEmitter.emit(eventName, button, this.groupName, index, pointer, event);
    } else {
      this.eventEmitter.emit(eventName, button, index, pointer, event);
    }
  };

  var GetValue$N = Phaser.Utils.Objects.GetValue;

  var InitData = function InitData(config, initialValue) {
    if (initialValue === undefined) {
      initialValue = false;
    }

    var dataManager = GetValue$N(config, 'dataManager', undefined);
    var setValueCallback, setValueCallbackScope;
    setValueCallback = GetValue$N(config, 'setValueCallback', undefined);
    setValueCallbackScope = GetValue$N(config, 'setValueCallbackScope', undefined);

    if (setValueCallback === undefined) {
      setValueCallback = GetValue$N(config, 'setButtonStateCallback', undefined);
      setValueCallbackScope = GetValue$N(config, 'setButtonStateCallbackScope', undefined);
    }

    if (dataManager === undefined) {
      var parent = this.parent;
      parent.setDataEnabled();
      dataManager = parent.data;
    }

    this.buttons.forEach(function (button) {
      var key = button.name;

      if (setValueCallback) {
        dataManager.events.on("changedata-".concat(key), function (parent, value, previousValue) {
          if (setValueCallbackScope) {
            setValueCallback.call(setValueCallbackScope, button, value, previousValue);
          } else {
            setValueCallback(button, value, previousValue);
          }
        });
      }

      dataManager.set(key, undefined);
      dataManager.set(key, initialValue); // Trigger data event 'changedata'
    });
    this.dataManager = dataManager;
  };

  var SetTypeMethods = {
    setButtonsType: function setButtonsType(config) {
      if (config === undefined) {
        config = {};
      }

      var type = GetValue$N(config, 'buttonsType', config.type);
      this.buttonsType = type;

      switch (type) {
        case 'radio':
          this.setRadioType(config);
          break;

        case 'checkboxes':
          this.setCheckboxesType(config);
          break;
      }

      return this;
    },
    setRadioType: function setRadioType(config) {
      InitData.call(this, config);
      var radioValue = undefined;
      var parent = this.parent,
          buttons = this.buttons,
          dataManager = this.dataManager;
      Object.defineProperty(parent, 'value', {
        get: function get() {
          return radioValue;
        },
        set: function set(newValue) {
          if (newValue === radioValue) {
            return;
          }

          radioValue = newValue; // Update state of button -> Fire `changedata-btnName` event -> setValueCallback                

          buttons.forEach(function (button) {
            var key = button.name;
            var state = dataManager.get(key);

            if (key === newValue) {
              if (!state) {
                dataManager.set(key, true);
              }
            } else {
              if (state) {
                dataManager.set(key, false);
              }
            }
          });
        },
        enumerable: true,
        configurable: true
      });
      parent.on('button.click', function (button) {
        parent.value = button.name;
      });
      return this;
    },
    setCheckboxesType: function setCheckboxesType(config) {
      InitData.call(this, config);
      var parent = this.parent,
          dataManager = this.dataManager;
      parent.on('button.click', function (button) {
        dataManager.toggle(button.name);
      });
      return this;
    },
    // For radio
    setSelectedButtonName: function setSelectedButtonName(name) {
      this.parent.value = name;
      return this;
    },
    getSelectedButtonName: function getSelectedButtonName() {
      return this.parent.value;
    },
    // For checkboxes
    setButtonState: function setButtonState(name, state) {
      if (state === undefined) {
        state = true;
      }

      this.dataManager.set(name, state);
      return this;
    },
    getButtonState: function getButtonState(name) {
      return this.dataManager.get(name);
    }
  };

  var GetGameObjectByName = function GetGameObjectByName(children, name) {
    if (!children) {
      return null;
    } else if (IsArray(children)) {
      var child;

      for (var i = 0, cnt = children.length; i < cnt; i++) {
        child = TestName(children[i], name);

        if (child) {
          return child;
        }
      }
    } else {
      // Is plain object
      var child;

      for (var key in children) {
        child = TestName(children[key], name);

        if (child) {
          return child;
        }
      }
    }
  };

  var TestName = function TestName(gameObject, name) {
    if (!gameObject) {
      return null;
    } else if (gameObject.hasOwnProperty('name')) {
      return gameObject.name === name ? gameObject : null;
    } else {
      // Array, or plain object
      return GetElementByName(gameObject, name);
    }
  };

  var ButtonMethods$2 = {
    getButton: function getButton(index) {
      // buttonGroup and button-sizer have *buttons* member both
      var buttons = this.buttons,
          button;

      var indexType = _typeof(index);

      switch (indexType) {
        case 'number':
          button = buttons[index];
          break;

        case 'string':
          button = GetGameObjectByName(buttons, index);
          break;

        default:
          button = index;

          if (buttons.indexOf(button) === -1) {
            button = undefined;
          }

          break;
      }

      return button;
    },
    setButtonEnable: function setButtonEnable(index, enabled) {
      // buttonGroup and button-sizer have *buttons* member both
      var buttons = this.buttons;

      if (index === undefined || typeof index === 'boolean') {
        enabled = index;

        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          buttons[i]._buttonBehavior.setEnable(enabled);
        }
      } else {
        this.getButton(index)._buttonBehavior.setEnable(enabled);
      }

      return this;
    },
    toggleButtonEnable: function toggleButtonEnable(index) {
      // buttonGroup and button-sizer have *buttons* member both
      var buttons = this.buttons;

      if (index === undefined || typeof index === 'boolean') {
        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          buttons[i]._buttonBehavior.toggleEnable();
        }
      } else {
        this.getButton(index)._buttonBehavior.toggleEnable();
      }

      return this;
    },
    getButtonEnable: function getButtonEnable(index) {
      if (index === undefined) {
        index = 0;
      }

      return this.getButton(index)._buttonBehavior.enable;
    },
    emitButtonClick: function emitButtonClick(index) {
      // index or button game object
      // this: buttonGroup or button-sizer
      var buttonGroup = this.buttonGroup ? this.buttonGroup : this;
      buttonGroup.fireEvent('button.click', index);
      return this;
    },
    showButton: function showButton(index) {
      Show(this.getButton(index));
      return this;
    },
    hideButton: function hideButton(index) {
      Hide(this.getButton(index));
      return this;
    },
    isButtonShown: function isButtonShown(index) {
      IsShown(this.getButton(index));
      return this;
    },
    forEachButtton: function forEachButtton(callback, scope) {
      // buttonGroup and button-sizer have *buttons* member both
      var buttons = this.buttons;

      for (var i = 0, cnt = buttons.length; i < cnt; i++) {
        if (scope) {
          callback.call(scope, buttons[i], i, buttons);
        } else {
          callback(buttons[i], i, buttons);
        }
      }

      return this;
    }
  };

  var ButtonGroup = /*#__PURE__*/function () {
    function ButtonGroup(config) {
      _classCallCheck(this, ButtonGroup);

      this.parent = config.parent;
      this.eventEmitter = config.eventEmitter;
      this.groupName = config.groupName;
      this.clickConfig = config.clickConfig;
      this.buttons = [];
    }

    _createClass(ButtonGroup, [{
      key: "destroy",
      value: function destroy() {
        this.parent = undefined;
        this.eventEmitter = undefined;
        this.clickConfig = undefined;
        this.buttons = undefined; // GameObjects will be destroyed outside
      }
    }]);

    return ButtonGroup;
  }();

  var methods$9 = {
    fireEvent: FireEvent
  };
  Object.assign(ButtonGroup.prototype, AddMethods, SetTypeMethods, ButtonMethods$2, methods$9);

  // Include in Buttons/GridButtons/FixedWidthButtons class
  var ButtonStateMethods = {
    // For radio
    setSelectedButtonName: function setSelectedButtonName(name) {
      this.buttonGroup.setSelectedButtonName(name);
      return this;
    },
    getSelectedButtonName: function getSelectedButtonName() {
      return this.buttonGroup.getSelectedButtonName();
    },
    // For checkboxes
    setButtonState: function setButtonState(name, state) {
      this.buttonGroup.setButtonState(name, state);
      return this;
    },
    getButtonState: function getButtonState(name) {
      return this.buttonGroup.getButtonState(name);
    }
  };

  var GetValue$M = Phaser.Utils.Objects.GetValue;

  var Buttons$1 = /*#__PURE__*/function (_Sizer) {
    _inherits(Buttons, _Sizer);

    var _super = _createSuper(Buttons);

    function Buttons(scene, config) {
      var _this;

      _classCallCheck(this, Buttons);

      if (config === undefined) {
        config = {};
      }

      var buttonSpace = config.space;

      if (typeof buttonSpace === 'number') {
        config.space = {
          item: buttonSpace
        };
      } // Create


      _this = _super.call(this, scene, config);
      _this.type = 'rexButtons';
      _this.buttonGroup = new ButtonGroup({
        parent: _assertThisInitialized(_this),
        eventEmitter: GetValue$M(config, 'eventEmitter', _assertThisInitialized(_this)),
        groupName: GetValue$M(config, 'groupName', undefined),
        clickConfig: GetValue$M(config, 'click', undefined)
      }); // Add elements

      var background = GetValue$M(config, 'background', undefined);
      var buttons = GetValue$M(config, 'buttons', undefined); // Buttons properties

      _this.buttonsExpand = GetValue$M(config, 'expand', false);
      _this.buttonsAlign = GetValue$M(config, 'align', undefined); // undefined/left/top: no space                

      if (background) {
        _this.addBackground(background);
      }

      if (buttons) {
        _this.addButtons(buttons);
      }

      _this.buttonGroup.setButtonsType(config);

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('buttons', _this.buttonGroup.buttons);

      return _this;
    }

    _createClass(Buttons, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        _get(_getPrototypeOf(Buttons.prototype), "destroy", this).call(this, fromScene);

        this.buttonGroup.destroy();
        this.buttonGroup = undefined;
      }
    }, {
      key: "buttons",
      get: function get() {
        return this.buttonGroup.buttons;
      }
    }, {
      key: "groupName",
      get: function get() {
        return this.buttonGroup.groupName;
      },
      set: function set(value) {
        this.buttonGroup.groupName = value;
      }
    }, {
      key: "eventEmitter",
      get: function get() {
        return this.buttonGroup.eventEmitter;
      }
    }]);

    return Buttons;
  }(Sizer);

  Object.assign(Buttons$1.prototype, AddChildMethods$3, RemoveChildMethods$2, ButtonMethods$2, ButtonStateMethods);

  ObjectFactory.register('buttons', function (config) {
    var gameObject = new Buttons$1(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Buttons', Buttons$1);

  var SizerAdd$1 = GridSizer.prototype.add;
  var AddChildMethods$2 = {
    addButton: function addButton(gameObject, columnIndex, rowIndex) {
      SizerAdd$1.call(this, gameObject, columnIndex, rowIndex, undefined, 0, this.buttonsExpand);
      this.buttonGroup.add(gameObject);
      return this;
    },
    addButtons: function addButtons(gameObjects, rowThenColumn) {
      for (var i = 0, cnt = gameObjects; i < cnt; i++) {
        this.addButton(gameObjects[i], undefined, rowThenColumn);
      }

      return this;
    }
  };

  var RemoveItem$2 = Phaser.Utils.Array.Remove;
  var SizerRmove$1 = GridSizer.prototype.remove;
  var SizerClear$1 = GridSizer.prototype.clear;

  var Remove$1 = function Remove(gameObject, destroyChild) {
    var gameObject = this.getButton(gameObject);

    if (!gameObject) {
      return this;
    }

    var buttons = this.buttonGroup.buttons;
    RemoveItem$2(buttons, gameObject);
    SizerRmove$1.call(this, gameObject, destroyChild);
    return this;
  };

  var RemoveChildMethods$1 = {
    remove: function remove(gameObject, destroyChild) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;

        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Remove$1.call(this, gameObjects[i], destroyChild);
        }
      } else {
        Remove$1.call(this, gameObject, destroyChild);
      }

      return this;
    },
    clear: function clear(destroyChild) {
      var buttons = this.buttonGroup.buttons;
      buttons.length = 0;
      SizerClear$1.call(this, destroyChild);
      return this;
    },
    removeButton: function removeButton(gameObject, destroyChild) {
      this.remove(gameObject, destroyChild);
      return this;
    },
    clearButtons: function clearButtons(destroyChild) {
      var buttons = this.buttonGroup.buttons;

      for (var i = buttons.length - 1; i >= 0; i--) {
        Remove$1.call(this, buttons[i], destroyChild);
      }

      return this;
    }
  };

  var GetValue$L = Phaser.Utils.Objects.GetValue;

  var GridButtons = /*#__PURE__*/function (_GridSizer) {
    _inherits(GridButtons, _GridSizer);

    var _super = _createSuper(GridButtons);

    function GridButtons(scene, config) {
      var _this;

      _classCallCheck(this, GridButtons);

      if (config === undefined) {
        config = {};
      }

      var row = GetValue$L(config, 'row', 0);
      var col = GetValue$L(config, 'col', 0);
      var createCellContainerCallback = GetValue$L(config, 'createCellContainerCallback');
      var buttons = GetValue$L(config, 'buttons', undefined);
      var buttonsExpand = GetValue$L(config, 'expand', true);
      var buttonProportion = buttonsExpand ? 1 : 0;

      if (createCellContainerCallback) {
        config.createCellContainerCallback = undefined;
      }

      if (buttons !== undefined) {
        row = Math.max(row, buttons.length);

        for (var i = 0, cnt = buttons.length; i < cnt; i++) {
          col = Math.max(col, buttons[i].length);
        }
      }

      config.row = row;
      config.column = col;
      config.columnProportions = buttonProportion;
      config.rowProportions = buttonProportion; // Create

      _this = _super.call(this, scene, config);
      _this.type = 'rexGridButtons';
      _this.buttonGroup = new ButtonGroup({
        parent: _assertThisInitialized(_this),
        eventEmitter: GetValue$L(config, 'eventEmitter', _assertThisInitialized(_this)),
        groupName: GetValue$L(config, 'groupName', undefined),
        clickConfig: GetValue$L(config, 'click', undefined)
      }); // Add elements

      var background = GetValue$L(config, 'background', undefined); // Buttons properties

      _this.buttonsExpand = buttonsExpand;
      GetValue$L(config, 'space', undefined);

      if (background) {
        _this.addBackground(background);
      }

      if (buttons) {
        var rowButtons, button;

        for (var r = 0, rcnt = buttons.length; r < rcnt; r++) {
          // row
          rowButtons = buttons[r];

          for (var c = 0, ccnt = rowButtons.length; c < ccnt; c++) {
            // col
            button = rowButtons[c];

            if (button) {
              _this.addButton(button, c, r);
            }
          }
        }
      } else if (createCellContainerCallback) {
        for (var y = 0; y < row; y++) {
          for (var x = 0; x < col; x++) {
            var button = createCellContainerCallback(scene, x, y);

            if (button) {
              _this.addButton(button, x, y);
            }
          }
        }
      }

      _this.buttonGroup.setButtonsType(config);

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('buttons', _this.buttonGroup.buttons);

      return _this;
    }

    _createClass(GridButtons, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        _get(_getPrototypeOf(GridButtons.prototype), "destroy", this).call(this, fromScene);

        this.buttonGroup.destroy();
        this.buttonGroup = undefined;
      }
    }, {
      key: "buttons",
      get: function get() {
        return this.buttonGroup.buttons;
      }
    }, {
      key: "groupName",
      get: function get() {
        return this.buttonGroup.groupName;
      },
      set: function set(value) {
        this.buttonGroup.groupName = value;
      }
    }, {
      key: "eventEmitter",
      get: function get() {
        return this.buttonGroup.eventEmitter;
      }
    }]);

    return GridButtons;
  }(GridSizer);

  Object.assign(GridButtons.prototype, AddChildMethods$2, RemoveChildMethods$1, ButtonMethods$2, ButtonStateMethods);

  ObjectFactory.register('gridButtons', function (config) {
    var gameObject = new GridButtons(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.GridButtons', GridButtons);

  var SizerAdd = FixWidthSizer.prototype.add;

  var Add$1 = function Add(gameObject) {
    SizerAdd.call(this, gameObject);
    this.buttonGroup.add(gameObject);
    return this;
  };

  var AddChildMethods$1 = {
    addButton: function addButton(gameObject) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;

        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$1.call(this, gameObjects[i]);
        }
      } else {
        Add$1.call(this, gameObject);
      }

      return this;
    },
    addButtons: function addButtons(gameObjects) {
      if (IsArray(gameObjects[0])) {
        // 2d array
        var lines = gameObjects,
            line;

        for (var lineIdx = 0, lastLineIdx = lines.length - 1; lineIdx <= lastLineIdx; lineIdx++) {
          line = lines[lineIdx];

          for (var i = 0, cnt = line.length; i < cnt; i++) {
            Add$1.call(this, line[i]);
          }

          if (lineIdx > lastLineIdx) {
            SizerAdd.addNewLine(this);
          }
        }
      } else {
        // 1d array
        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Add$1.call(this, gameObjects[i]);
        }
      }

      return this;
    }
  };

  var RemoveItem$1 = Phaser.Utils.Array.Remove;
  var SizerRmove = FixWidthSizer.prototype.remove;
  var SizerClear = FixWidthSizer.prototype.clear;

  var Remove = function Remove(gameObject, destroyChild) {
    var gameObject = this.getButton(gameObject);

    if (!gameObject) {
      return this;
    }

    var buttons = this.buttonGroup.buttons;
    RemoveItem$1(buttons, gameObject);
    SizerRmove.call(this, gameObject, destroyChild);
    return this;
  };

  var RemoveChildMethods = {
    remove: function remove(gameObject, destroyChild) {
      if (IsArray(gameObject)) {
        var gameObjects = gameObject;

        for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
          Remove.call(this, gameObjects[i], destroyChild);
        }
      } else {
        Remove.call(this, gameObject, destroyChild);
      }

      return this;
    },
    clear: function clear(destroyChild) {
      var buttons = this.buttonGroup.buttons;
      buttons.length = 0;
      SizerClear.call(this, destroyChild);
      return this;
    },
    removeButton: function removeButton(gameObject, destroyChild) {
      this.remove(gameObject, destroyChild);
      return this;
    },
    clearButtons: function clearButtons(destroyChild) {
      var buttons = this.buttonGroup.buttons;

      for (var i = buttons.length - 1; i >= 0; i--) {
        Remove.call(this, buttons[i], destroyChild);
      }

      return this;
    }
  };

  var GetValue$K = Phaser.Utils.Objects.GetValue;

  var Buttons = /*#__PURE__*/function (_FixWidthSizer) {
    _inherits(Buttons, _FixWidthSizer);

    var _super = _createSuper(Buttons);

    function Buttons(scene, config) {
      var _this;

      _classCallCheck(this, Buttons);

      if (config === undefined) {
        config = {};
      }

      var buttonSpace = config.space;

      if (typeof buttonSpace === 'number') {
        config.space = {
          item: buttonSpace,
          line: buttonSpace
        };
      } // Create


      _this = _super.call(this, scene, config);
      _this.type = 'rexFixWidthButtons';
      _this.buttonGroup = new ButtonGroup({
        parent: _assertThisInitialized(_this),
        eventEmitter: GetValue$K(config, 'eventEmitter', _assertThisInitialized(_this)),
        groupName: GetValue$K(config, 'groupName', undefined),
        clickConfig: GetValue$K(config, 'click', undefined)
      }); // Add elements

      var background = GetValue$K(config, 'background', undefined);
      var buttons = GetValue$K(config, 'buttons', undefined); // Buttons properties

      _this.buttonsAlign = GetValue$K(config, 'align', undefined);

      if (background) {
        _this.addBackground(background);
      }

      if (buttons) {
        _this.addButtons(buttons);
      }

      _this.buttonGroup.setButtonsType(config);

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('buttons', _this.buttonGroup.buttons);

      return _this;
    }

    _createClass(Buttons, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        _get(_getPrototypeOf(Buttons.prototype), "destroy", this).call(this, fromScene);

        this.buttonGroup.destroy();
        this.buttonGroup = undefined;
      }
    }, {
      key: "buttons",
      get: function get() {
        return this.buttonGroup.buttons;
      }
    }, {
      key: "groupName",
      get: function get() {
        return this.buttonGroup.groupName;
      },
      set: function set(value) {
        this.buttonGroup.groupName = value;
      }
    }, {
      key: "eventEmitter",
      get: function get() {
        return this.buttonGroup.eventEmitter;
      }
    }]);

    return Buttons;
  }(FixWidthSizer);

  Object.assign(Buttons.prototype, AddChildMethods$1, RemoveChildMethods, ButtonMethods$2, ButtonStateMethods);

  ObjectFactory.register('fixWidthButtons', function (config) {
    var gameObject = new Buttons(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.FixWidthButtons', Buttons);

  var ButtonMethods$1 = {
    getChoice: function getChoice(index) {
      return this.childrenMap.choicesSizer.getButton(index);
    },
    getAction: function getAction(index) {
      return this.childrenMap.actionsSizer.getButton(index);
    },
    getToolbar: function getToolbar(index) {
      return this.childrenMap.toolbarSizer.getButton(index);
    },
    getLeftToolbar: function getLeftToolbar(index) {
      return this.childrenMap.leftToolbarSizer.getButton(index);
    },
    setChoiceEnable: function setChoiceEnable(index, enabled) {
      this.childrenMap.choicesSizer.setButtonEnable(index, enabled);
      return this;
    },
    setActionEnable: function setActionEnable(index, enabled) {
      this.childrenMap.actionsSizer.setButtonEnable(index, enabled);
      return this;
    },
    setToolbarEnable: function setToolbarEnable(index, enabled) {
      this.childrenMap.toolbarSizer.setButtonEnable(index, enabled);
      return this;
    },
    setLeftToolbarEnable: function setLeftToolbarEnable(index, enabled) {
      this.childrenMap.leftToolbarSizer.setButtonEnable(index, enabled);
      return this;
    },
    toggleChoiceEnable: function toggleChoiceEnable(index) {
      this.childrenMap.choicesSizer.toggleButtonEnable(index);
      return this;
    },
    toggleActionEnable: function toggleActionEnable(index) {
      this.childrenMap.actionsSizer.toggleButtonEnable(index);
      return this;
    },
    toggleToolbarEnable: function toggleToolbarEnable(index) {
      this.childrenMap.toolbarSizer.toggleButtonEnable(index);
      return this;
    },
    toggleLeftToolbarEnable: function toggleLeftToolbarEnable(index) {
      this.childrenMap.leftToolbarSizer.toggleButtonEnable(index);
      return this;
    },
    getChoiceEnable: function getChoiceEnable(index) {
      return this.childrenMap.choicesSizer.getButtonEnable(index);
    },
    getActionEnable: function getActionEnable(index) {
      return this.childrenMap.actionsSizer.getButtonEnable(index);
    },
    getToolbarEnable: function getToolbarEnable(index) {
      return this.childrenMap.toolbarSizer.getButtonEnable(index);
    },
    getLeftToolbarEnable: function getLeftToolbarEnable(index) {
      return this.childrenMap.leftToolbarSizer.getButtonEnable(index);
    },
    emitChoiceClick: function emitChoiceClick(index) {
      this.childrenMap.choicesSizer.emitButtonClick(index);
      return this;
    },
    emitActionClick: function emitActionClick(index) {
      this.childrenMap.actionsSizer.emitButtonClick(index);
      return this;
    },
    emitToolbarClick: function emitToolbarClick(index) {
      this.childrenMap.toolbarSizer.emitButtonClick(index);
      return this;
    },
    emitLeftToolbarClick: function emitLeftToolbarClick(index) {
      this.childrenMap.leftToolbarSizer.emitButtonClick(index);
      return this;
    },
    showChoice: function showChoice(index) {
      this.childrenMap.choicesSizer.showButton(index);
      return this;
    },
    showAction: function showAction(index) {
      this.childrenMap.actionsSizer.showButton(index);
      return this;
    },
    showToolbar: function showToolbar(index) {
      this.childrenMap.toolbarSizer.showButton(index);
      return this;
    },
    showLeftToolbar: function showLeftToolbar(index) {
      this.childrenMap.leftToolbarSizer.showButton(index);
      return this;
    },
    hideChoice: function hideChoice(index) {
      this.childrenMap.choicesSizer.hideButton(index);
      return this;
    },
    hideAction: function hideAction(index) {
      this.childrenMap.actionsSizer.hideButton(index);
      return this;
    },
    hideToolbar: function hideToolbar(index) {
      this.childrenMap.toolbarSizer.hideButton(index);
      return this;
    },
    hideLeftToolbar: function hideLeftToolbar(index) {
      this.childrenMap.leftToolbarSizer.hideButton(index);
      return this;
    },
    addChoice: function addChoice(gameObject) {
      this.childrenMap.choicesSizer.addButton(gameObject);
      return this;
    },
    addAction: function addAction(gameObject) {
      this.childrenMap.actionsSizer.addButton(gameObject);
      return this;
    },
    addToolbar: function addToolbar(gameObject) {
      this.childrenMap.toolbarSizer.addButton(gameObject);
      return this;
    },
    addLeftToolbar: function addLeftToolbar(gameObject) {
      this.childrenMap.leftToolbarSizer.addButton(gameObject);
      return this;
    },
    removeChoice: function removeChoice(index, destroyChild) {
      this.childrenMap.choicesSizer.removeButton(index, destroyChild);
      return this;
    },
    removeAction: function removeAction(index, destroyChild) {
      this.childrenMap.actionsSizer.removeButton(index, destroyChild);
      return this;
    },
    removeToolbar: function removeToolbar(index, destroyChild) {
      this.childrenMap.toolbarSizer.removeButton(index, destroyChild);
      return this;
    },
    removeLeftToolbar: function removeLeftToolbar(index, destroyChild) {
      this.childrenMap.leftToolbarSizer.removeButton(index, destroyChild);
      return this;
    },
    clearChoices: function clearChoices(destroyChild) {
      this.childrenMap.choicesSizer.clearButtons(destroyChild);
      return this;
    },
    clearActions: function clearActions(destroyChild) {
      this.childrenMap.actionsSizer.clearButtons(destroyChild);
      return this;
    },
    clearToolbar: function clearToolbar(destroyChild) {
      this.childrenMap.toolbarSizer.clearButtons(destroyChild);
      return this;
    },
    clearLeftToolbar: function clearLeftToolbar(destroyChild) {
      this.childrenMap.leftToolbarSizer.clearButtons(destroyChild);
      return this;
    },
    forEachChoice: function forEachChoice(callback, scope) {
      this.childrenMap.choicesSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachAction: function forEachAction(callback, scope) {
      this.childrenMap.actionsSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachToolbar: function forEachToolbar(callback, scope) {
      this.childrenMap.toolbarSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachLeftToolbar: function forEachLeftToolbar(callback, scope) {
      this.childrenMap.leftToolbarSizer.forEachButtton(callback, scope);
      return this;
    }
  };

  var GetValue$J = Phaser.Utils.Objects.GetValue;

  var Dialog = /*#__PURE__*/function (_Sizer) {
    _inherits(Dialog, _Sizer);

    var _super = _createSuper(Dialog);

    function Dialog(scene, config) {
      var _this;

      _classCallCheck(this, Dialog);

      if (config === undefined) {
        config = {};
      } // Create sizer        


      config.orientation = 1; // Top to bottom

      _this = _super.call(this, scene, config);
      _this.type = 'rexDialog';
      _this.eventEmitter = GetValue$J(config, 'eventEmitter', _assertThisInitialized(_this)); // Add elements

      var background = GetValue$J(config, 'background', undefined);
      var title = GetValue$J(config, 'title', undefined);
      var toolbar = GetValue$J(config, 'toolbar', undefined);
      var toolbarBackground = GetValue$J(config, 'toolbarBackground', undefined);
      var leftToolbar = GetValue$J(config, 'leftToolbar', undefined);
      var leftToolbarBackground = GetValue$J(config, 'leftToolbarBackground', undefined);
      var content = GetValue$J(config, 'content', undefined);
      var description = GetValue$J(config, 'description', undefined);
      var choicesSizer;
      var choices = GetValue$J(config, 'choices', undefined);
      var choicesBackground = GetValue$J(config, 'choicesBackground', undefined);
      var actionsSizer;
      var actions = GetValue$J(config, 'actions', undefined);
      var actionsBackground = GetValue$J(config, 'actionsBackground', undefined);
      var clickConfig = GetValue$J(config, 'click', undefined);

      if (background) {
        _this.addBackground(background);
      }

      var toolbarSizer;

      if (toolbar) {
        toolbarSizer = new Buttons$1(scene, {
          groupName: 'toolbar',
          background: toolbarBackground,
          buttons: toolbar,
          orientation: 0,
          // Left-right
          space: {
            item: GetValue$J(config, 'space.toolbarItem', 0)
          },
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
      }

      var leftToolbarSizer;

      if (leftToolbar) {
        leftToolbarSizer = new Buttons$1(scene, {
          groupName: 'leftToolbar',
          background: leftToolbarBackground,
          buttons: leftToolbar,
          orientation: 0,
          // Left-right
          space: {
            item: GetValue$J(config, 'space.leftToolbarItem', 0)
          },
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
      } // title only


      if (title && !toolbar && !leftToolbar) {
        var align = GetValue$J(config, 'align.title', 'center');
        var titleSpace = GetValue$J(config, 'space.title', 0);
        var padding;

        if (content || description || choices || actions) {
          padding = {
            bottom: titleSpace
          };
        }

        var expand = GetValue$J(config, 'expand.title', true);

        _this.add(title, {
          align: align,
          padding: padding,
          expand: expand
        });
      } // toolbar only


      if (toolbar && !title && !leftToolbar) {
        var titleSpace = GetValue$J(config, 'space.title', 0);
        var padding;

        if (content || description || choices || actions) {
          padding = {
            bottom: titleSpace
          };
        }

        var expand = GetValue$J(config, 'expand.toolbar', true);

        _this.add(toolbarSizer, {
          align: 'right',
          padding: padding,
          expand: expand
        });
      } // leftToolbar only


      if (leftToolbar && !title && !toolbar) {
        var titleSpace = GetValue$J(config, 'space.title', 0);
        var padding;

        if (content || description || choices || actions) {
          padding = {
            bottom: titleSpace
          };
        }

        var expand = GetValue$J(config, 'expand.leftToolbar', true);

        _this.add(leftToolbarSizer, {
          align: 'left',
          padding: padding,
          expand: expand
        });
      } // tilte and (toolbar or leftToolbar)


      if (title && (toolbar || leftToolbar)) {
        var titleSizer = new Sizer(scene, {
          orientation: 0
        }); // Add leftToolbar

        if (leftToolbarSizer) {
          titleSizer.add(leftToolbarSizer, {
            align: 'right',
            expand: false
          });
        } // Add title


        var align = GetValue$J(config, 'align.title', 'left');
        var expand = GetValue$J(config, 'expand.title', true); // Add space if not expand

        if (!expand && (align === 'right' || align === 'center')) {
          titleSizer.addSpace();
        }

        var padding = {
          left: GetValue$J(config, 'space.titleLeft', 0),
          right: GetValue$J(config, 'space.titleRight', 0)
        };
        var proportion = expand ? 1 : 0;
        titleSizer.add(title, {
          proportion: proportion,
          align: 'center',
          padding: padding,
          expand: expand
        }); // Add space if not expand

        if (!expand && (align === 'left' || align === 'center')) {
          titleSizer.addSpace();
        } // Add toolbar


        if (toolbarSizer) {
          titleSizer.add(toolbarSizer, {
            align: 'right',
            expand: false
          });
        } // Add sizer to dialog


        var titleSpace = GetValue$J(config, 'space.title', 0);
        var padding;

        if (content || description || choices || actions) {
          padding = {
            bottom: titleSpace
          };
        }

        _this.add(titleSizer, {
          align: 'center',
          padding: padding,
          expand: true
        });
      }

      if (content) {
        var align = GetValue$J(config, 'align.content', 'center');
        var contentSpace = GetValue$J(config, 'space.content', 0);
        var padding = {
          left: GetValue$J(config, 'space.contentLeft', 0),
          right: GetValue$J(config, 'space.contentRight', 0),
          bottom: description || choices || actions ? contentSpace : 0
        };
        var expand = GetValue$J(config, 'expand.content', true);

        _this.add(content, {
          align: align,
          padding: padding,
          expand: expand
        });
      }

      if (description) {
        var align = GetValue$J(config, 'align.description', 'center');
        var descriptionSpace = GetValue$J(config, 'space.description', 0);
        var padding = {
          left: GetValue$J(config, 'space.descriptionLeft', 0),
          right: GetValue$J(config, 'space.descriptionRight', 0),
          bottom: choices || actions ? descriptionSpace : 0
        };
        var expand = GetValue$J(config, 'expand.description', true);

        _this.add(description, {
          align: align,
          padding: padding,
          expand: expand
        });
      }

      if (choices) {
        var align = GetValue$J(config, 'align.choices', 'center');
        choicesSizer = new Buttons$1(scene, {
          groupName: 'choices',
          background: choicesBackground,
          buttons: choices,
          orientation: 1,
          // Top-Bottom
          space: {
            item: GetValue$J(config, 'space.choice', 0)
          },
          click: clickConfig,
          eventEmitter: _this.eventEmitter,
          type: GetValue$J(config, 'choicesType', undefined),
          setValueCallback: GetValue$J(config, 'choicesSetValueCallback', undefined),
          setValueCallbackScope: GetValue$J(config, 'choicesSetValueCallbackScope', undefined)
        });
        var choicesSpace = GetValue$J(config, 'space.choices', 0);
        var padding = {
          left: GetValue$J(config, 'space.choicesLeft', 0),
          right: GetValue$J(config, 'space.choicesRight', 0),
          bottom: actions ? choicesSpace : 0
        };
        var expand = GetValue$J(config, 'expand.choices', true);

        _this.add(choicesSizer, {
          align: align,
          padding: padding,
          expand: expand
        });
      }

      if (actions) {
        actionsSizer = new Buttons$1(scene, {
          groupName: 'actions',
          background: actionsBackground,
          buttons: actions,
          orientation: 0,
          // Left-right
          space: {
            item: GetValue$J(config, 'space.action', 0)
          },
          expand: GetValue$J(config, 'expand.actions', false),
          align: GetValue$J(config, 'align.actions', 'center'),
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        var padding = {
          left: GetValue$J(config, 'space.actionsLeft', 0),
          right: GetValue$J(config, 'space.actionsRight', 0)
        };

        _this.add(actionsSizer, {
          align: 'center',
          padding: padding,
          expand: true
        });
      }

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('title', title);

      _this.addChildrenMap('toolbar', toolbar);

      _this.addChildrenMap('leftToolbar', leftToolbar);

      _this.addChildrenMap('content', content);

      _this.addChildrenMap('description', description);

      _this.addChildrenMap('choices', choices);

      _this.addChildrenMap('actions', actions);

      _this.addChildrenMap('choicesSizer', choicesSizer);

      _this.addChildrenMap('actionsSizer', actionsSizer);

      _this.addChildrenMap('toolbarSizer', toolbarSizer);

      _this.addChildrenMap('leftToolbarSizer', leftToolbarSizer);

      return _this;
    }

    return _createClass(Dialog);
  }(Sizer);

  Object.assign(Dialog.prototype, ButtonMethods$1);

  ObjectFactory.register('dialog', function (config) {
    var gameObject = new Dialog(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Dialog', Dialog);

  var GetValue$I = Phaser.Utils.Objects.GetValue;

  var HolyGrail = /*#__PURE__*/function (_Sizer) {
    _inherits(HolyGrail, _Sizer);

    var _super = _createSuper(HolyGrail);

    function HolyGrail(scene, config) {
      var _this;

      _classCallCheck(this, HolyGrail);

      if (config === undefined) {
        config = {};
      }

      config.orientation = 1; // top-to-bottom
      // Create sizer

      _this = _super.call(this, scene, config);
      _this.type = 'rexHolyGrail'; // Add Background

      var background = GetValue$I(config, 'background', undefined);

      if (background) {
        _this.addBackground(background);
      } // Add Header


      var header = GetValue$I(config, 'header', undefined);

      if (header) {
        var proportion = GetValue$I(config, 'proportion.header', 0);
        var align = GetValue$I(config, 'align.header', 'center');
        var padding = GetValue$I(config, 'space.header', undefined);

        if (typeof padding === 'number') {
          padding = {
            bottom: padding
          };
        }

        var expand = GetValue$I(config, 'expand.header', true);

        _this.add(header, {
          proportion: proportion,
          align: align,
          padding: padding,
          expand: expand
        });
      }

      var bodySizer = new Sizer(scene, {
        orientation: 0 // left-to-right

      });

      _this.add(bodySizer, {
        proportion: 1,
        align: 'center',
        padding: 0,
        expand: true
      }); // Add Left-side


      var leftSide = GetValue$I(config, 'leftSide', undefined);

      if (leftSide) {
        var proportion = GetValue$I(config, 'proportion.leftSide', 0);
        var align = GetValue$I(config, 'align.leftSide', 'center');
        var padding = GetValue$I(config, 'space.leftSide', undefined);

        if (typeof padding === 'number') {
          padding = {
            right: padding
          };
        }

        var expand = GetValue$I(config, 'expand.leftSide', true);
        bodySizer.add(leftSide, {
          proportion: proportion,
          align: align,
          padding: padding,
          expand: expand
        });
      } // Add content


      var content = GetValue$I(config, 'content', undefined);

      if (content) {
        var proportion = GetValue$I(config, 'proportion.content', 1);
        var align = GetValue$I(config, 'align.content', 'center');
        var padding = GetValue$I(config, 'space.content', undefined);
        var expand = GetValue$I(config, 'expand.content', true);
        bodySizer.add(content, {
          proportion: proportion,
          align: align,
          padding: padding,
          expand: expand
        });
      } // Add Right-side


      var rightSide = GetValue$I(config, 'rightSide', undefined);

      if (rightSide) {
        var proportion = GetValue$I(config, 'proportion.rightSide', 0);
        var align = GetValue$I(config, 'align.rightSide', 'center');
        var padding = GetValue$I(config, 'space.rightSide', undefined);

        if (typeof padding === 'number') {
          padding = {
            left: padding
          };
        }

        var expand = GetValue$I(config, 'expand.rightSide', true);
        bodySizer.add(rightSide, {
          proportion: proportion,
          align: align,
          padding: padding,
          expand: expand
        });
      } // Add Footer


      var footer = GetValue$I(config, 'footer', undefined);

      if (footer) {
        var proportion = GetValue$I(config, 'proportion.footer', 0);
        var align = GetValue$I(config, 'align.footer', 'center');
        var padding = GetValue$I(config, 'space.footer', undefined);

        if (typeof padding === 'number') {
          padding = {
            top: padding
          };
        }

        var expand = GetValue$I(config, 'expand.footer', true);

        _this.add(footer, {
          proportion: proportion,
          align: align,
          padding: padding,
          expand: expand
        });
      }

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('header', header);

      _this.addChildrenMap('leftSide', leftSide);

      _this.addChildrenMap('content', content);

      _this.addChildrenMap('rightSide', rightSide);

      _this.addChildrenMap('footer', footer);

      return _this;
    }

    return _createClass(HolyGrail);
  }(Sizer);

  ObjectFactory.register('holyGrail', function (config) {
    var gameObject = new HolyGrail(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.HolyGrail', HolyGrail);

  var ButtonMethods = {
    getButtonsSizer: function getButtonsSizer(groupName) {
      return this.childrenMap["".concat(groupName, "ButtonsSizer")];
    },
    getButton: function getButton(groupName, index) {
      var buttonsSizer = this.getButtonsSizer(groupName);
      return buttonsSizer ? buttonsSizer.getButton(index) : undefined;
    },
    setButtonEnable: function setButtonEnable(groupName, index, enabled) {
      this.getButtonsSizer(groupName).setButtonEnable(index, enabled);
      return this;
    },
    setLeftButtonEnable: function setLeftButtonEnable(index, enabled) {
      this.childrenMap.leftButtonsSizer.setButtonEnable(index, enabled);
      return this;
    },
    setRightButtonEnable: function setRightButtonEnable(index, enabled) {
      this.childrenMap.rightButtonsSizer.setButtonEnable(index, enabled);
      return this;
    },
    setTopButtonEnable: function setTopButtonEnable(index, enabled) {
      this.childrenMap.topButtonsSizer.setButtonEnable(index, enabled);
      return this;
    },
    setBottomButtonEnable: function setBottomButtonEnable(index, enabled) {
      this.childrenMap.bottomButtonsSizer.setButtonEnable(index, enabled);
      return this;
    },
    toggleButtonEnable: function toggleButtonEnable(groupName, index) {
      this.getButtonsSizer(groupName).toggleButtonEnable(index);
      return this;
    },
    toggleLeftButtonEnable: function toggleLeftButtonEnable(index) {
      this.childrenMap.leftButtonsSizer.toggleButtonEnable(index);
      return this;
    },
    toggleRightButtonEnable: function toggleRightButtonEnable(index) {
      this.childrenMap.rightButtonsSizer.toggleButtonEnable(index);
      return this;
    },
    toggleTopButtonEnable: function toggleTopButtonEnable(index) {
      this.childrenMap.topButtonsSizer.toggleButtonEnable(index);
      return this;
    },
    toggleBottomButtonEnable: function toggleBottomButtonEnable(index) {
      this.childrenMap.bottomButtonsSizer.toggleButtonEnable(index);
      return this;
    },
    getButtonEnable: function getButtonEnable(groupName, index) {
      return this.getButtonsSizer(groupName).getButtonEnable(index);
    },
    getLeftButtonEnable: function getLeftButtonEnable(index) {
      return this.childrenMap.leftButtonsSizer.getButtonEnable(index);
    },
    getRightButtonEnable: function getRightButtonEnable(index) {
      return this.childrenMap.rightButtonsSizer.getButtonEnable(index);
    },
    getTopButtonEnable: function getTopButtonEnable(index) {
      return this.childrenMap.topButtonsSizer.getButtonEnable(index);
    },
    getBottomButtonEnable: function getBottomButtonEnable(index) {
      return this.childrenMap.bottomButtonsSizer.getButtonEnable(index);
    },
    emitButtonClick: function emitButtonClick(groupName, index) {
      var buttonsSizer = this.getButtonsSizer(groupName);

      if (!buttonsSizer) {
        return this;
      }

      buttonsSizer.emitButtonClick(index);
      return this;
    },
    emitLeftButtonClick: function emitLeftButtonClick(index) {
      this.childrenMap.leftButtonsSizer.emitButtonClick(index);
      return this;
    },
    emitRightButtonClick: function emitRightButtonClick(index) {
      this.childrenMap.rightButtonsSizer.emitButtonClick(index);
      return this;
    },
    emitTopButtonClick: function emitTopButtonClick(index) {
      this.childrenMap.topButtonsSizer.emitButtonClick(index);
      return this;
    },
    emitBottomButtonClick: function emitBottomButtonClick(index) {
      this.childrenMap.bottomButtonsSizer.emitButtonClick(index);
      return this;
    },
    getLeftButton: function getLeftButton(index) {
      return this.childrenMap.leftButtonsSizer.getButton(index);
    },
    getRightButton: function getRightButton(index) {
      return this.childrenMap.rightButtonsSizer.getButton(index);
    },
    getTopButton: function getTopButton(index) {
      return this.childrenMap.topButtonsSizer.getButton(index);
    },
    getBottomButton: function getBottomButton(index) {
      return this.childrenMap.bottomButtonsSizer.getButton(index);
    },
    showButton: function showButton(groupName, index) {
      Show(this.getButton(groupName, index));
      return this;
    },
    showLeftButton: function showLeftButton(index) {
      Show(this.getLeftButton(index));
      return this;
    },
    showRightButton: function showRightButton(index) {
      Show(this.getRightButton(index));
      return this;
    },
    showTopButton: function showTopButton(index) {
      Show(this.getTopButton(index));
      return this;
    },
    showBottomButton: function showBottomButton(index) {
      Show(this.getBottomButton(index));
      return this;
    },
    hideButton: function hideButton(groupName, index) {
      Hide(this.getButton(groupName, index));
      return this;
    },
    hideLeftButton: function hideLeftButton(index) {
      Hide(this.getLeftButton(index));
      return this;
    },
    hideRightButton: function hideRightButton(index) {
      Hide(this.getRightButton(index));
      return this;
    },
    hideTopButton: function hideTopButton(index) {
      Hide(this.getTopButton(index));
      return this;
    },
    hideBottomButton: function hideBottomButton(index) {
      Hide(this.getBottomButton(index));
      return this;
    },
    addButton: function addButton(groupName, gameObject) {
      this.getButtonsSizer(groupName).addButton(gameObject);
      return this;
    },
    addLeftButton: function addLeftButton(gameObject) {
      this.addButton('left', gameObject);
      return this;
    },
    addRightButton: function addRightButton(gameObject) {
      this.addButton('right', gameObject);
      return this;
    },
    addTopButton: function addTopButton(gameObject) {
      this.addButton('top', gameObject);
      return this;
    },
    removeButton: function removeButton(groupName, index, destroyChild) {
      this.getButtonsSizer(groupName).removeButton(index, destroyChild);
      return this;
    },
    removeLeftButton: function removeLeftButton(index, destroyChild) {
      this.removeButton('left', index, destroyChild);
      return this;
    },
    removeRightButton: function removeRightButton(index, destroyChild) {
      this.removeButton('right', index, destroyChild);
      return this;
    },
    removeTopButton: function removeTopButton(index, destroyChild) {
      this.removeButton('top', index, destroyChild);
      return this;
    },
    removeBottomButton: function removeBottomButton(index, destroyChild) {
      this.removeButton('bottom', index, destroyChild);
      return this;
    },
    clearButtons: function clearButtons(groupName, destroyChild) {
      this.getButtonsSizer(groupName).clearButtons(destroyChild);
      return this;
    },
    clearLeftButtons: function clearLeftButtons(destroyChild) {
      this.clearButtons('left', destroyChild);
      return this;
    },
    clearRightButtons: function clearRightButtons(destroyChild) {
      this.clearButtons('right', destroyChild);
      return this;
    },
    clearTopButtons: function clearTopButtons(destroyChild) {
      this.clearButtons('top', destroyChild);
      return this;
    },
    clearBottomButtonss: function clearBottomButtonss(destroyChild) {
      this.clearButtons('bottom', destroyChild);
      return this;
    },
    forEachButton: function forEachButton(groupName, callback, scope) {
      this.getButtonsSizer(groupName).forEachButtton(callback, scope);
      return this;
    },
    forEachLeftButton: function forEachLeftButton(callback, scope) {
      this.childrenMap.leftButtonsSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachRightButton: function forEachRightButton(callback, scope) {
      this.childrenMap.rightButtonsSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachTopButton: function forEachTopButton(callback, scope) {
      this.childrenMap.topButtonsSizer.forEachButtton(callback, scope);
      return this;
    },
    forEachBottomButton: function forEachBottomButton(callback, scope) {
      this.childrenMap.bottomButtonsSizer.forEachButtton(callback, scope);
      return this;
    }
  };

  var GetValue$H = Phaser.Utils.Objects.GetValue;

  var Tabs = /*#__PURE__*/function (_GridSizer) {
    _inherits(Tabs, _GridSizer);

    var _super = _createSuper(Tabs);

    function Tabs(scene, config) {
      var _this;

      _classCallCheck(this, Tabs);

      if (config === undefined) {
        config = {};
      } // Create sizer


      config.column = 3;
      config.row = 3;
      _this = _super.call(this, scene, config);
      _this.type = 'rexTabs';
      _this.eventEmitter = GetValue$H(config, 'eventEmitter', _assertThisInitialized(_this)); // Add elements

      var background = GetValue$H(config, 'background', undefined);
      var panel = GetValue$H(config, 'panel', undefined);
      var leftButtons = GetValue$H(config, 'leftButtons', undefined);
      var leftButtonsBackground = GetValue$H(config, 'leftButtonsBackground', undefined);
      var leftButtonsSizer;
      var rightButtons = GetValue$H(config, 'rightButtons', undefined);
      var rightButtonsBackground = GetValue$H(config, 'rightButtonsBackground', undefined);
      var rightButtonsSizer;
      var topButtons = GetValue$H(config, 'topButtons', undefined);
      var topButtonsBackground = GetValue$H(config, 'topButtonsBackground', undefined);
      var topButtonsSizer;
      var bottomButtons = GetValue$H(config, 'bottomButtons', undefined);
      var bottomButtonsBackground = GetValue$H(config, 'bottomButtonsBackground', undefined);
      var bottomButtonsSizer;
      var clickConfig = GetValue$H(config, 'click', undefined);

      if (background) {
        _this.addBackground(background);
      }

      if (panel) {
        _this.add(panel, 1, 1, 'center', 0, true);
      }

      if (leftButtons) {
        var leftButtonsOffset = GetValue$H(config, 'space.leftButtonsOffset', 0);
        var leftButtonSpace = GetValue$H(config, 'space.leftButton', 0);
        leftButtonsSizer = new Buttons$1(scene, {
          groupName: 'left',
          background: leftButtonsBackground,
          buttons: leftButtons,
          orientation: 1,
          // Top-Bottom
          space: {
            item: leftButtonSpace
          },
          align: GetValue$H(config, 'align.leftButtons', undefined),
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        var padding = {
          top: leftButtonsOffset
        };

        _this.add(leftButtonsSizer, 0, 1, 'top', padding, false);
      }

      if (rightButtons) {
        var rightButtonsOffset = GetValue$H(config, 'space.rightButtonsOffset', 0);
        var rightButtonSpace = GetValue$H(config, 'space.rightButton', 0);
        rightButtonsSizer = new Buttons$1(scene, {
          groupName: 'right',
          background: rightButtonsBackground,
          buttons: rightButtons,
          orientation: 1,
          // Top-Bottom
          space: {
            item: rightButtonSpace
          },
          align: GetValue$H(config, 'align.rightButtons', undefined),
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        var padding = {
          top: rightButtonsOffset
        };

        _this.add(rightButtonsSizer, 2, 1, 'top', padding, false);
      }

      if (topButtons) {
        var toptButtonsOffset = GetValue$H(config, 'space.topButtonsOffset', 0);
        var topButtonSpace = GetValue$H(config, 'space.topButton', 0);
        topButtonsSizer = new Buttons$1(scene, {
          groupName: 'top',
          background: topButtonsBackground,
          buttons: topButtons,
          orientation: 0,
          // Left-Right
          space: {
            item: topButtonSpace
          },
          align: GetValue$H(config, 'align.topButtons', undefined),
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        var padding = {
          left: toptButtonsOffset
        };

        _this.add(topButtonsSizer, 1, 0, 'left', padding, false);
      }

      if (bottomButtons) {
        var bottomButtonsOffset = GetValue$H(config, 'space.bottomButtonsOffset', 0);
        var bottomButtonSpace = GetValue$H(config, 'space.bottomButton', 0);
        bottomButtonsSizer = new Buttons$1(scene, {
          groupName: 'bottom',
          background: bottomButtonsBackground,
          buttons: bottomButtons,
          orientation: 0,
          // Left-Right
          space: {
            item: bottomButtonSpace
          },
          align: GetValue$H(config, 'align.bottomButtons', undefined),
          click: clickConfig,
          eventEmitter: _this.eventEmitter
        });
        var padding = {
          left: bottomButtonsOffset
        };

        _this.add(bottomButtonsSizer, 1, 2, 'left', padding, false);
      }

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('panel', panel);

      _this.addChildrenMap('leftButtons', leftButtons);

      _this.addChildrenMap('rightButtons', rightButtons);

      _this.addChildrenMap('topButtons', topButtons);

      _this.addChildrenMap('bottomButtons', bottomButtons);

      _this.addChildrenMap('leftButtonsSizer', leftButtonsSizer);

      _this.addChildrenMap('rightButtonsSizer', rightButtonsSizer);

      _this.addChildrenMap('topButtonsSizer', topButtonsSizer);

      _this.addChildrenMap('bottomButtonsSizer', bottomButtonsSizer);

      return _this;
    }

    return _createClass(Tabs);
  }(GridSizer);

  Object.assign(Tabs.prototype, ButtonMethods);

  ObjectFactory.register('tabs', function (config) {
    var gameObject = new Tabs(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Tabs', Tabs);

  var Percent$1 = Phaser.Math.Percent;

  var PositionToPercent = function PositionToPercent(startPoint, endPoint, currentPoint) {
    var min, max, value;

    if (startPoint.y === endPoint.y) {
      min = Math.min(startPoint.x, endPoint.x);
      max = Math.max(startPoint.x, endPoint.x);
      value = Percent$1(currentPoint.x, min, max);
    } else if (startPoint.x === endPoint.x) {
      min = Math.min(startPoint.y, endPoint.y);
      max = Math.max(startPoint.y, endPoint.y);
      value = Percent$1(currentPoint.y, min, max);
    }

    return value;
  };

  var OnDragThumb = function OnDragThumb(pointer, dragX, dragY) {
    if (!this.enable) {
      return;
    }

    tmpPoint$4.x = dragX;
    tmpPoint$4.y = dragY;
    this.value = PositionToPercent(this.getStartPoint(), this.getEndPoint(), tmpPoint$4);
  };

  var tmpPoint$4 = {};

  var OnTouchTrack = function OnTouchTrack(pointer, localX, localY) {
    if (!this.enable) {
      return;
    }

    if (!pointer.isDown) {
      return;
    }

    tmpPoint$3.x = pointer.worldX;
    tmpPoint$3.y = pointer.worldY;
    var value = PositionToPercent(this.getStartPoint(), this.getEndPoint(), tmpPoint$3);
    this.stopEaseValue();

    if (this.easeValueDuration === 0 || Math.abs(this.value - value) < 0.1) {
      this.value = value;
    } else {
      this.easeValueTo(value);
    }
  };

  var tmpPoint$3 = {};

  var GetThumbAlignPoint = function GetThumbAlignPoint(align, out) {
    if (out === undefined) {
      out = tmpPoint$2;
    }

    var thumb = this.childrenMap.thumb;
    var currentX = thumb.x;
    var currentY = thumb.y;
    AlignIn(thumb, this.innerLeft, this.innerTop, this.innerWidth, this.innerHeight, align);
    out.x = thumb.x;
    out.y = thumb.y;
    thumb.x = currentX;
    thumb.y = currentY;
    return out;
  };

  var tmpPoint$2 = {};

  var AlignLeft$1 = Phaser.Display.Align.LEFT_CENTER;
  var AlignTop$1 = Phaser.Display.Align.TOP_CENTER;

  var GetStartPoint = function GetStartPoint(out) {
    if (out === undefined) {
      out = tmpPoint$1;
    }

    if (this.childrenMap.thumb) {
      var align = this.orientation === 0 ? AlignLeft$1 : AlignTop$1;
      GetThumbAlignPoint.call(this, align, out);
    } else {
      if (this.orientation === 0) {
        out.x = this.innerLeft + 1; // Add 1 pixel margin

        out.y = this.centerY;
      } else {
        out.x = this.centerX;
        out.y = this.innerTop + 1; // Add 1 pixel margin
      }
    }

    return out;
  };

  var tmpPoint$1 = {};

  var AlignRight = Phaser.Display.Align.RIGHT_CENTER;
  var AlignBottom = Phaser.Display.Align.BOTTOM_CENTER;

  var GetEndoint = function GetEndoint(out) {
    if (out === undefined) {
      out = tmpPoint;
    }

    if (this.childrenMap.thumb) {
      var align = this.orientation === 0 ? AlignRight : AlignBottom;
      GetThumbAlignPoint.call(this, align, out);
    } else {
      if (this.orientation === 0) {
        out.x = this.innerRight - 1; // Add 1 pixel margin

        out.y = this.centerY;
      } else {
        out.x = this.centerX;
        out.y = this.innerBottom - 1; // Add 1 pixel margin
      }
    }

    return out;
  };

  var tmpPoint = {};

  var Linear$2 = Phaser.Math.Linear;

  var PercentToPosition = function PercentToPosition(t, startPoint, endPoint, out) {
    if (out === undefined) {
      out = tmpOut;
    }

    out.x = Linear$2(startPoint.x, endPoint.x, t);
    out.y = Linear$2(startPoint.y, endPoint.y, t);
    return out;
  };

  var tmpOut = {};

  var UpdateThumb = function UpdateThumb(t) {
    var thumb = this.childrenMap.thumb;

    if (thumb === undefined) {
      return this;
    }

    if (t === undefined) {
      t = this.value;
    }

    PercentToPosition(t, this.getStartPoint(), this.getEndPoint(), thumb);
    this.resetChildPositionState(thumb);
    return this;
  };

  var AlignLeft = Phaser.Display.Align.LEFT_CENTER;
  var AlignTop = Phaser.Display.Align.TOP_CENTER;

  var UpdateIndicator = function UpdateIndicator(t) {
    var indicator = this.childrenMap.indicator;

    if (indicator === undefined) {
      return this;
    }

    if (t === undefined) {
      t = this.value;
    }

    var newWidth, newHeight;
    var thumb = this.childrenMap.thumb;

    if (thumb) {
      if (this.orientation === 0) {
        // x, extend width
        var thumbWidth = GetDisplayWidth(thumb);
        var thumbRight = thumb.x - thumbWidth * thumb.originX + thumbWidth;
        newWidth = thumbRight - this.left;
      } else {
        // y, extend height
        var thumbHeight = GetDisplayHeight(thumb);
        var thumbBottom = thumb.y - thumbHeight * thumb.originY + thumbHeight;
        newHeight = thumbBottom - this.top;
      }
    } else {
      if (this.orientation === 0) {
        // x, extend width
        newWidth = this.width * t;
      } else {
        // y, extend eight
        newHeight = this.height * t;
      }
    }

    ResizeGameObject(indicator, newWidth, newHeight);
    var align = this.orientation === 0 ? AlignLeft : AlignTop;
    QuickSet(indicator, this, align);
    this.resetChildPositionState(indicator);
  };

  var GetValue$G = Phaser.Utils.Objects.GetValue;
  var Clamp$5 = Phaser.Math.Clamp;
  var Linear$1 = Phaser.Math.Linear;
  var Percent = Phaser.Math.Percent;
  var SnapTo = Phaser.Math.Snap.To;

  var Slider$1 = /*#__PURE__*/function (_Sizer) {
    _inherits(Slider, _Sizer);

    var _super = _createSuper(Slider);

    function Slider(scene, config) {
      var _this;

      _classCallCheck(this, Slider);

      // Create sizer
      _this = _super.call(this, scene, config);
      _this.type = 'rexSlider';
      _this.eventEmitter = GetValue$G(config, 'eventEmitter', _assertThisInitialized(_this)); // Add elements

      var background = GetValue$G(config, 'background', undefined);
      var track = GetValue$G(config, 'track', undefined);
      var indicator = GetValue$G(config, 'indicator', undefined);
      var thumb = GetValue$G(config, 'thumb', undefined);

      if (background) {
        _this.addBackground(background);
      }

      if (track) {
        _this.add(track, {
          proportion: 1,
          expand: true,
          minWidth: 0,
          minHeight: 0
        });
      }

      if (indicator) {
        _this.pin(indicator); // Put into container but not layout it

      }

      if (thumb) {
        _this.pin(thumb); // Put into container but not layout it

      } // Input


      var inputMode = GetValue$G(config, 'input', 0);

      if (typeof inputMode === 'string') {
        inputMode = INPUTMODE[inputMode];
      }

      switch (inputMode) {
        case 0:
          // 'drag'
          if (thumb) {
            thumb.setInteractive();

            _this.scene.input.setDraggable(thumb);

            thumb.on('drag', OnDragThumb, _assertThisInitialized(_this)).on('dragstart', function (pointer) {
              this.eventEmitter.emit('inputstart', pointer);
            }, _assertThisInitialized(_this)).on('dragend', function (pointer) {
              this.eventEmitter.emit('inputend', pointer);
            }, _assertThisInitialized(_this));
          }

          break;

        case 1:
          // 'click'
          _this.setInteractive().on('pointerdown', OnTouchTrack, _assertThisInitialized(_this)).on('pointermove', OnTouchTrack, _assertThisInitialized(_this)).on('pointerdown', function (pointer) {
            this.eventEmitter.emit('inputstart', pointer);
          }, _assertThisInitialized(_this)).on('pointerup', function (pointer) {
            this.eventEmitter.emit('inputend', pointer);
          }, _assertThisInitialized(_this)).on('pointerover', function (pointer) {
            if (pointer.isDown) {
              this.eventEmitter.emit('inputstart', pointer);
            }
          }, _assertThisInitialized(_this)).on('pointerout', function (pointer) {
            if (pointer.isDown) {
              this.eventEmitter.emit('inputend', pointer);
            }
          }, _assertThisInitialized(_this));

          break;
      }

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('track', track);

      _this.addChildrenMap('indicator', indicator);

      _this.addChildrenMap('thumb', thumb);

      var callback = GetValue$G(config, 'valuechangeCallback', null);

      if (callback !== null) {
        var scope = GetValue$G(config, 'valuechangeCallbackScope', undefined);

        _this.eventEmitter.on('valuechange', callback, scope);
      }

      _this.setEnable(GetValue$G(config, 'enable', undefined));

      _this.setGap(GetValue$G(config, 'gap', undefined));

      _this.setValue(GetValue$G(config, 'value', 0), GetValue$G(config, 'min', undefined), GetValue$G(config, 'max', undefined));

      _this.setEaseValuePropName('value').setEaseValueDuration(GetValue$G(config, 'easeValue.duration', 0)).setEaseValueFunction(GetValue$G(config, 'easeValue.ease', 'Linear'));

      return _this;
    }

    _createClass(Slider, [{
      key: "setEnable",
      value: function setEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }

        this.enable = enable;
        return this;
      }
    }, {
      key: "setGap",
      value: function setGap(gap) {
        this.gap = gap;
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        if (this.gap !== undefined) {
          value = SnapTo(value, this.gap);
        }

        var oldValue = this._value;
        this._value = Clamp$5(value, 0, 1);

        if (oldValue !== this._value) {
          this.updateThumb(this._value);
          this.updateIndicator(this._value);
          this.eventEmitter.emit('valuechange', this._value, oldValue, this.eventEmitter);
        }
      }
    }, {
      key: "setValue",
      value: function setValue(value, min, max) {
        if (value === undefined || value === null) {
          return this;
        }

        if (min !== undefined) {
          value = Percent(value, min, max);
        }

        this.value = value;
        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, min, max) {
        if (min !== undefined) {
          inc = Percent(inc, min, max);
        }

        this.value += inc;
        return this;
      }
    }, {
      key: "getValue",
      value: function getValue(min, max) {
        var value = this.value;

        if (min !== undefined) {
          value = Linear$1(min, max, value);
        }

        return value;
      }
    }, {
      key: "runLayout",
      value: function runLayout(parent, newWidth, newHeight) {
        // Skip hidden or !dirty sizer
        if (this.ignoreLayout) {
          return this;
        }

        _get(_getPrototypeOf(Slider.prototype), "runLayout", this).call(this, parent, newWidth, newHeight);

        this.updateThumb();
        this.updateIndicator();
        return this;
      }
    }]);

    return Slider;
  }(Sizer);

  var INPUTMODE = {
    pan: 0,
    drag: 0,
    click: 1,
    none: -1
  };
  var methods$8 = {
    getStartPoint: GetStartPoint,
    getEndPoint: GetEndoint,
    updateThumb: UpdateThumb,
    updateIndicator: UpdateIndicator
  };
  Object.assign(Slider$1.prototype, methods$8, EaseValueMethods);

  ObjectFactory.register('slider', function (config) {
    var gameObject = new Slider$1(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Slider', Slider$1);

  var SCROLLMODE$1 = {
    v: 0,
    vertical: 0,
    h: 1,
    horizontal: 1
  };

  var GetValue$F = Phaser.Utils.Objects.GetValue;

  var GetScrollMode = function GetScrollMode(config, key) {
    var scrollMode = GetValue$F(config, 'scrollMode', 0); // Vertical

    if (typeof scrollMode === 'string') {
      scrollMode = SCROLLMODE$1[scrollMode];
    }

    return scrollMode;
  };

  var GetValue$E = Phaser.Utils.Objects.GetValue;

  var ScrollBar = /*#__PURE__*/function (_Sizer) {
    _inherits(ScrollBar, _Sizer);

    var _super = _createSuper(ScrollBar);

    function ScrollBar(scene, config) {
      var _this;

      _classCallCheck(this, ScrollBar);

      // Create sizer
      _this = _super.call(this, scene, config);
      _this.type = 'rexScrollBar'; // Add elements

      var background = GetValue$E(config, 'background', undefined);
      var buttonsConfig = GetValue$E(config, 'buttons', undefined);
      var button0 = GetValue$E(buttonsConfig, 'top', GetValue$E(buttonsConfig, 'left', undefined));
      var button1 = GetValue$E(buttonsConfig, 'bottom', GetValue$E(buttonsConfig, 'right', undefined));
      var slider,
          sliderConfig = GetValue$E(config, 'slider', undefined);

      if (background) {
        _this.addBackground(background);
      }

      if (button0) {
        _this.add(button0);

        var inTouching = new InTouching(button0);
        inTouching.on('intouch', function () {
          if (!this.enable) {
            return;
          }

          this.value -= this.scrollStep;
        }, _assertThisInitialized(_this));
      }

      if (sliderConfig) {
        sliderConfig.orientation = _this.orientation;
        sliderConfig.eventEmitter = _assertThisInitialized(_this);
        sliderConfig.value = null;
        var proportion;

        if (_this.orientation === 0) {
          var sliderWidth = GetValue$E(sliderConfig, 'width', undefined);
          proportion = sliderWidth === undefined ? 1 : 0;
        } else {
          var sliderHeight = GetValue$E(sliderConfig, 'height', undefined);
          proportion = sliderHeight === undefined ? 1 : 0;
        }

        slider = new Slider$1(scene, sliderConfig);
        scene.add.existing(slider);

        _this.add(slider, {
          proportion: proportion
        });
      }

      if (button1) {
        _this.add(button1);

        var inTouching = new InTouching(button1);
        inTouching.on('intouch', function () {
          if (!this.enable) {
            return;
          }

          this.value += this.scrollStep;
        }, _assertThisInitialized(_this));
      }

      var buttons = [button0, button1];

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('slider', slider);

      _this.addChildrenMap('buttons', buttons);

      var callback = GetValue$E(config, 'valuechangeCallback', null);

      if (callback !== null) {
        var scope = GetValue$E(config, 'valuechangeCallbackScope', undefined);

        _this.on('valuechange', callback, scope);
      }

      _this.setEnable(GetValue$E(config, 'enable', undefined));

      _this.setValue(GetValue$E(config, 'value', 0));

      _this.setScrollStep(GetValue$E(buttonsConfig, 'step', 0.01));

      return _this;
    }

    _createClass(ScrollBar, [{
      key: "setScrollStep",
      value: function setScrollStep(value) {
        this.scrollStep = value;
        return this;
      }
    }, {
      key: "enable",
      get: function get() {
        if (this.childrenMap.slider) {
          return this.childrenMap.slider.enable;
        } else {
          return false;
        }
      },
      set: function set(value) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setEnable(value);
        }
      }
    }, {
      key: "setEnable",
      value: function setEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }

        this.enable = enable;
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        if (this.childrenMap.slider) {
          return this.childrenMap.slider.value;
        } else {
          return 0;
        }
      },
      set: function set(value) {
        if (!this.childrenMap.slider) {
          return;
        }

        this.childrenMap.slider.value = value;
      }
    }, {
      key: "setValue",
      value: function setValue(value, min, max) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setValue(value, min, max);
        }

        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, min, max) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.addValue(inc, min, max);
        }

        return this;
      }
    }, {
      key: "getValue",
      value: function getValue(min, max) {
        if (this.childrenMap.slider) {
          return this.childrenMap.slider.getValue(min, max);
        } else {
          return 0;
        }
      }
    }, {
      key: "easeValueTo",
      value: function easeValueTo(value, min, max) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.easeValueTo(value, min, max);
        }

        return this;
      }
    }, {
      key: "stopEaseValue",
      value: function stopEaseValue() {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.stopEaseValue();
        }

        return this;
      }
    }, {
      key: "setEaseValueDuration",
      value: function setEaseValueDuration(duration) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setEaseValueDuration(duration);
        }

        return this;
      }
    }, {
      key: "setEaseValueFunction",
      value: function setEaseValueFunction(ease) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setEaseValueFunction(ease);
        }

        return this;
      }
    }]);

    return ScrollBar;
  }(Sizer);

  var Slider = /*#__PURE__*/function (_Base) {
    _inherits(Slider, _Base);

    var _super = _createSuper(Slider);

    function Slider(scene, config) {
      var _this;

      _classCallCheck(this, Slider);

      if (config === undefined) {
        config = {};
      }

      var sliderConfig = Clone(config);
      config = {
        slider: sliderConfig
      }; // Move orientation parameter from sliderConfig to config

      config.orientation = sliderConfig.orientation;
      delete sliderConfig.orientation; // Move background parameter from sliderConfig to config

      config.background = sliderConfig.background;
      delete sliderConfig.background; // Move buttons parameter from sliderConfig to config

      config.buttons = sliderConfig.buttons;
      delete sliderConfig.buttons;
      _this = _super.call(this, scene, config);
      var slider = _this.childrenMap.slider;

      _this.addChildrenMap('track', slider.childrenMap.track);

      _this.addChildrenMap('indicator', slider.childrenMap.indicator);

      _this.addChildrenMap('thumb', slider.childrenMap.thumb);

      return _this;
    }

    return _createClass(Slider);
  }(ScrollBar);

  var State$3 = /*#__PURE__*/function (_FSM) {
    _inherits(State, _FSM);

    var _super = _createSuper(State);

    function State(parent, config) {
      var _this;

      _classCallCheck(this, State);

      _this = _super.call(this, config);
      _this.parent = parent;

      _this.init();

      return _this;
    }

    _createClass(State, [{
      key: "init",
      value: function init() {
        this.start('IDLE');
      } // IDLE -> DRAGBEGIN|DRAG

    }, {
      key: "next_IDLE",
      value: function next_IDLE() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;

        if (dragState.isDown) {
          nextState = parent.dragThreshold === 0 ? 'DRAG' : 'DRAGBEGIN';
        }

        return nextState;
      }
    }, {
      key: "update_IDLE",
      value: function update_IDLE(time, delta) {
        this.next();
      } // IDLE
      // DRAGBEGIN -> DRAG|IDLE

    }, {
      key: "next_DRAGBEGIN",
      value: function next_DRAGBEGIN() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;

        if (dragState.isDown) {
          nextState = dragState.pointer.getDistance() >= parent.dragThreshold ? 'DRAG' : 'DRAGBEGIN';
        } else {
          // dragState.isUp
          nextState = 'IDLE';
        }

        return nextState;
      }
    }, {
      key: "update_DRAGBEGIN",
      value: function update_DRAGBEGIN(time, delta) {
        this.next();
      } // DRAGBEGIN
      // DRAG -> BACK|SLIDE|IDLE

    }, {
      key: "next_DRAG",
      value: function next_DRAG() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;

        if (dragState.isUp) {
          if (parent.outOfBounds) {
            nextState = 'BACK';
          } else if (parent.slidingEnable) {
            nextState = 'SLIDE';
          } else {
            nextState = 'IDLE';
          }
        }

        return nextState;
      }
    }, {
      key: "update_DRAG",
      value: function update_DRAG(time, delta) {
        var parent = this.parent,
            dragState = parent.dragState;

        if (dragState.justMoved) {
          parent.dragging();
        }

        this.next();
      }
    }, {
      key: "enter_DRAG",
      value: function enter_DRAG() {
        this.parent.onDragStart();
      }
    }, {
      key: "exit_DRAG",
      value: function exit_DRAG() {
        this.parent.onDragEnd();
      } // DRAG    
      // SLIDE -> DRAG|IDLE

    }, {
      key: "next_SLIDE",
      value: function next_SLIDE() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;

        if (dragState.isDown) {
          nextState = 'DRAG';
        } else if (!parent.isSliding) {
          nextState = 'IDLE';
        }

        return nextState;
      }
    }, {
      key: "enter_SLIDE",
      value: function enter_SLIDE() {
        this.parent.onSliding();
      }
    }, {
      key: "exit_SLIDE",
      value: function exit_SLIDE() {
        this.parent.stop();
      }
    }, {
      key: "update_SLIDE",
      value: function update_SLIDE(time, delta) {
        this.parent.sliding(time, delta);
        this.next();
      } // SLIDE    
      // BACK -> DRAG|IDLE

    }, {
      key: "next_BACK",
      value: function next_BACK() {
        var nextState,
            parent = this.parent,
            dragState = parent.dragState;

        if (dragState.isDown) {
          nextState = 'DRAG';
        } else if (!parent.isPullBack) {
          nextState = 'IDLE';
        }

        return nextState;
      }
    }, {
      key: "enter_BACK",
      value: function enter_BACK() {
        this.parent.onPullBack();
      }
    }, {
      key: "exit_BACK",
      value: function exit_BACK() {
        this.parent.stop();
      }
    }, {
      key: "update_BACK",
      value: function update_BACK(time, delta) {
        this.parent.pullBack(time, delta);
        this.next();
      } // BACK

    }]);

    return State;
  }(FSM);

  var GetValue$D = Phaser.Utils.Objects.GetValue;
  var DistanceBetween$1 = Phaser.Math.Distance.Between;

  var DragSpeed = /*#__PURE__*/function (_ComponentBase) {
    _inherits(DragSpeed, _ComponentBase);

    var _super = _createSuper(DragSpeed);

    function DragSpeed(gameObject, config) {
      var _this;

      _classCallCheck(this, DragSpeed);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;

      _this._enable = undefined;
      gameObject.setInteractive(GetValue$D(config, "inputConfig", undefined));

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(DragSpeed, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.pointer = undefined;
        this.isInTouched = false;
        this.holdStartTime = undefined;
        this.x = undefined;
        this.y = undefined;
        this.preX = undefined;
        this.preY = undefined;
        this.localX = undefined;
        this.localY = undefined;
        this.justMoved = false;
        this.setEnable(GetValue$D(o, 'enable', true));
        this.holdThreshold = GetValue$D(o, 'holdThreshold', 50); // ms

        this.pointerOutReleaseEnable = GetValue$D(o, 'pointerOutRelease', true);
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        // Drag start only when pointer down
        this.parent.on('pointerdown', this.onPointIn, this); // this.parent.on('pointerover', this.onPointIn, this);

        this.parent.on('pointerup', this.onPointOut, this);

        if (this.pointerOutReleaseEnable) {
          this.parent.on('pointerout', this.onPointOut, this);
        }

        this.parent.on('pointermove', this.onPointerMove, this);
        this.scene.sys.events.on('preupdate', this.preupdate, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        } // GameObject events will be removed when this gameObject destroyed 
        // this.parent.off('pointerdown', this.onPointIn, this);
        // this.parent.off('pointerup', this.onPointOut, this);
        // this.parent.off('pointerout', this.onPointOut, this);
        // this.parent.off('pointermove', this.onPointerMove, this);


        this.scene.sys.events.off('preupdate', this.preupdate, this);
        this.pointer = undefined;

        _get(_getPrototypeOf(DragSpeed.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }

        if (!e) {
          this.isInTouched = false;
          this.pointer = undefined;
        }

        this._enable = e;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "setPointerOutReleaseEnable",
      value: function setPointerOutReleaseEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }

        this.pointerOutReleaseEnable = enable;
        return this;
      }
    }, {
      key: "isDown",
      get: function get() {
        return this.pointer && this.pointer.isDown;
      }
    }, {
      key: "isUp",
      get: function get() {
        return !this.isDown;
      }
    }, {
      key: "dx",
      get: function get() {
        return this.x - this.preX;
      }
    }, {
      key: "dy",
      get: function get() {
        return this.y - this.preY;
      }
    }, {
      key: "dt",
      get: function get() {
        var game = this.scene.sys.game;
        var delta = game.loop.delta;
        return delta;
      }
    }, {
      key: "speed",
      get: function get() {
        if (this.x === this.preX && this.y === this.preY) {
          return 0;
        }

        var d = DistanceBetween$1(this.preX, this.preY, this.x, this.y);
        var speed = d / (this.dt * 0.001);
        return speed;
      }
    }, {
      key: "speedX",
      get: function get() {
        return this.dx / (this.dt * 0.001);
      }
    }, {
      key: "speedY",
      get: function get() {
        return this.dy / (this.dt * 0.001);
      } // internal

    }, {
      key: "onPointIn",
      value: function onPointIn(pointer, localX, localY) {
        if (!this.enable || !pointer.isDown || this.pointer !== undefined) {
          return;
        }

        this.pointer = pointer;
        this.localX = localX;
        this.localY = localY;
      }
    }, {
      key: "onPointOut",
      value: function onPointOut(pointer) {
        if (!this.enable || this.pointer !== pointer) {
          return;
        }

        this.pointer = undefined;
      }
    }, {
      key: "onPointerMove",
      value: function onPointerMove(pointer, localX, localY) {
        if (!this.enable || !pointer.isDown || this.pointer !== pointer) {
          return;
        }

        this.localX = localX;
        this.localY = localY;
      }
    }, {
      key: "preupdate",
      value: function preupdate(time, delta) {
        if (!this.enable) {
          return;
        }

        var pointer = this.pointer;
        this.justMoved = false;

        if (pointer && !this.isInTouched) {
          // Touch start
          this.x = pointer.worldX;
          this.y = pointer.worldY;
          this.preX = pointer.worldX;
          this.preY = pointer.worldY;
          this.isInTouched = true;
          this.holdStartTime = undefined;
          this.emit('touchstart', pointer, this.localX, this.localY);
        } else if (pointer && this.isInTouched) {
          // In touch
          if (this.x === pointer.x && this.y === pointer.y) {
            // Hold
            if (this.holdStartTime === undefined) {
              this.holdStartTime = time;
            } else if (time - this.holdStartTime > this.holdThreshold) {
              this.preX = this.x;
              this.preY = this.y;
            }
          } else {
            // Move
            this.preX = this.x;
            this.preY = this.y;
            this.x = pointer.worldX;
            this.y = pointer.worldY;
            this.holdStartTime = undefined;
            this.justMoved = true;
            this.emit('touchmove', pointer, this.localX, this.localY);
          }
        } else if (!pointer && this.isInTouched) {
          // Touch end
          this.isInTouched = false;
          this.holdStartTime = undefined;
          this.emit('touchend', pointer);
        }
      }
    }]);

    return DragSpeed;
  }(ComponentBase);

  var GetValue$C = Phaser.Utils.Objects.GetValue;

  var Movement = /*#__PURE__*/function () {
    function Movement(config) {
      _classCallCheck(this, Movement);

      this.resetFromJSON(config);
    }

    _createClass(Movement, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setValue(GetValue$C(o, 'value', 0));
        this.setSpeed(GetValue$C(o, 'speed', 0));
        this.setAcceleration(GetValue$C(o, 'acceleration', 0));
        return this;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.setValue(0);
        this.setSpeed(0);
        this.setAcceleration(0);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
        return this;
      }
    }, {
      key: "setSpeed",
      value: function setSpeed(speed) {
        // speed == 0 : stop
        // speed  > 0 : move
        this.speed = speed;
        return this;
      }
    }, {
      key: "setAcceleration",
      value: function setAcceleration(acc) {
        // acc == 0 : constant speed
        // acc  > 0 : acceleration
        // acc  < 0 : deceleration
        this.acceleration = acc;
        return this;
      }
    }, {
      key: "updateSpeed",
      value: function updateSpeed(delta) {
        // delta in sec
        if (this.acceleration !== 0) {
          this.speed += this.acceleration * delta;

          if (this.speed < 0) {
            this.speed = 0;
          }
        }

        return this;
      }
    }, {
      key: "getDeltaValue",
      value: function getDeltaValue(delta) {
        // delta in sec
        this.updateSpeed(delta);

        if (this.speed <= 0) {
          return 0;
        }

        return this.speed * delta;
      }
    }, {
      key: "update",
      value: function update(delta) {
        // delta in sec
        this.updateSpeed(delta);

        if (this.speed > 0) {
          this.value += this.getDeltaValue(delta);
        }

        return this;
      }
    }, {
      key: "isMoving",
      get: function get() {
        return this.speed > 0;
      }
    }]);

    return Movement;
  }();

  var SlowDown = /*#__PURE__*/function () {
    function SlowDown() {
      _classCallCheck(this, SlowDown);

      this.value;
      this.dir; // true:+, false:-

      this.movement = new Movement();
    }

    _createClass(SlowDown, [{
      key: "init",
      value: function init(start, dir, speed, dec, end) {
        this.value = start;
        this.end = end;

        if (end !== undefined) {
          this.dir = start < end;
        } else {
          this.dir = dir;
        }

        this.movement.setSpeed(speed).setAcceleration(-dec);
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.movement.reset();
      }
    }, {
      key: "update",
      value: function update(delta) {
        // delta in sec
        var d = this.movement.getDeltaValue(delta);

        if (!this.dir) {
          d = -d;
        }

        if (this.end === undefined) {
          this.value += d;
        } else {
          if (d === 0) {
            this.value = this.end;
          } else {
            this.value += d;

            if (this.dir) {
              // +
              if (this.value > this.end) {
                this.value = this.end;
              }
            } else {
              // -
              if (this.value < this.end) {
                this.value = this.end;
              }
            }
          }
        }

        return this;
      }
    }, {
      key: "isMoving",
      get: function get() {
        return this.movement.isMoving;
      }
    }]);

    return SlowDown;
  }();

  var GetValue$B = Phaser.Utils.Objects.GetValue;
  var Clamp$4 = Phaser.Math.Clamp;

  var Scroller = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Scroller, _ComponentBase);

    var _super = _createSuper(Scroller);

    function Scroller(gameObject, config) {
      var _this;

      _classCallCheck(this, Scroller);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;

      var enable = GetValue$B(config, 'enable', true);
      _this._state = new State$3(_assertThisInitialized(_this), {
        enable: enable,
        eventEmitter: false
      });
      var drapSpeedConfig = {
        inputConfig: GetValue$B(config, 'inputConfig', undefined),
        enable: enable,
        pointerOutRelease: GetValue$B(config, 'pointerOutRelease', true),
        eventEmitter: false
      };
      _this.dragState = new DragSpeed(gameObject, drapSpeedConfig);
      _this._enable = undefined;
      _this._value = undefined;
      _this._slowDown = new SlowDown();
      var callback = GetValue$B(config, 'valuechangeCallback', null);

      if (callback !== null) {
        var scope = GetValue$B(config, 'valuechangeCallbackScope', undefined);

        _this.on('valuechange', callback, scope);
      }

      callback = GetValue$B(config, 'overmaxCallback', null);

      if (callback !== null) {
        var scope = GetValue$B(config, 'overmaxCallbackScope', undefined);

        _this.on('overmax', callback, scope);
      }

      callback = GetValue$B(config, 'overminCallback', null);

      if (callback !== null) {
        var scope = GetValue$B(config, 'overminCallbackScope', undefined);

        _this.on('overmin', callback, scope);
      }

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(Scroller, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setOrientationMode(GetValue$B(o, 'orientation', 0));
        this.setDragThreshold(GetValue$B(o, 'threshold', 10));
        this.setSlidingDeceleration(GetValue$B(o, 'slidingDeceleration', 5000));
        this.setBackDeceleration(GetValue$B(o, 'backDeceleration', 2000));
        var bounds = GetValue$B(o, 'bounds', undefined);

        if (bounds) {
          this.setBounds(bounds);
        } else {
          this.setBounds(GetValue$B(o, 'max', 0), GetValue$B(o, 'min', 0));
        }

        this.setValue(GetValue$B(o, 'value', this.maxValue || 0));
        this.setEnable(GetValue$B(o, "enable", true));
        return this;
      }
    }, {
      key: "boot",
      value: function boot() {
        this.scene.sys.events.on('preupdate', this._state.update, this._state);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        this.scene.sys.events.off('preupdate', this._state.update, this._state);

        this._state.destroy(fromScene);

        this.dragState.destroy(fromScene);
        this._state = undefined;
        this.dragState = undefined;

        _get(_getPrototypeOf(Scroller.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }

        this._enable = e;

        this._state.setEnable(e);

        this.dragState.setEnable(e);
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "setOrientationMode",
      value: function setOrientationMode(m) {
        if (typeof m === 'string') {
          m = ORIENTATIONMODE$1[m];
        }

        this.orientationMode = m;
        return this;
      }
    }, {
      key: "setDragThreshold",
      value: function setDragThreshold(distance) {
        this.dragThreshold = distance;
        return this;
      }
    }, {
      key: "setSlidingDeceleration",
      value: function setSlidingDeceleration(dec) {
        this.slidingDeceleration = dec;
        return this;
      }
    }, {
      key: "setBackDeceleration",
      value: function setBackDeceleration(dec) {
        this.backDeceleration = dec;
        return this;
      }
    }, {
      key: "setBounds",
      value: function setBounds(value0, value1) {
        if (Array.isArray(value0)) {
          var bounds = value0;
          value0 = bounds[0];
          value1 = bounds[1];
        }

        if (value0 < value1) {
          this.minValue = value0;
          this.maxValue = value1;
        } else {
          this.minValue = value1;
          this.maxValue = value0;
        }

        return this;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        if (value === this._value) {
          return;
        }

        var oldValue = this._value;
        var isOverMax = this.overMax(value);
        var isOverMin = this.overMin(value);

        if (isOverMax) {
          this.emit('overmax', value, oldValue);
        }

        if (isOverMin) {
          this.emit('overmin', value, oldValue);
        }

        if (!this.backEnable) {
          if (isOverMax) {
            value = this.maxValue;
          }

          if (isOverMin) {
            value = this.minValue;
          }
        }

        this._value = value;
        this.emit('valuechange', value, oldValue);
      }
    }, {
      key: "setValue",
      value: function setValue(value, clamp) {
        if (clamp === undefined) {
          clamp = false;
        }

        if (clamp) {
          value = Clamp$4(value, this.minValue, this.maxValue);
        }

        this.value = value;
        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, clamp) {
        this.setValue(this.value + inc, clamp);
        return this;
      }
    }, {
      key: "state",
      get: function get() {
        return this._state.state;
      }
    }, {
      key: "isDragging",
      get: function get() {
        return this.dragState.isInTouched;
      }
    }, {
      key: "outOfMaxBound",
      get: function get() {
        return this.overMax(this.value);
      }
    }, {
      key: "outOfMinBound",
      get: function get() {
        return this.overMin(this.value);
      }
    }, {
      key: "outOfBounds",
      get: function get() {
        return this.outOfMinBound || this.outOfMaxBound;
      } // internal

    }, {
      key: "overMax",
      value: function overMax(value) {
        return this.maxValue != null && value > this.maxValue;
      }
    }, {
      key: "overMin",
      value: function overMin(value) {
        return this.minValue != null && value < this.minValue;
      }
    }, {
      key: "backEnable",
      get: function get() {
        return typeof this.backDeceleration === 'number';
      }
    }, {
      key: "isPullBack",
      get: function get() {
        return this._slowDown.isMoving;
      }
    }, {
      key: "slidingEnable",
      get: function get() {
        return typeof this.slidingDeceleration === 'number';
      }
    }, {
      key: "isSliding",
      get: function get() {
        return this._slowDown.isMoving;
      }
    }, {
      key: "dragDelta",
      get: function get() {
        if (this.orientationMode === 0) {
          // y
          return this.dragState.dy;
        } else if (this.orientationMode === 1) {
          // x
          return this.dragState.dx;
        } else {
          return 0;
        }
      }
    }, {
      key: "dragSpeed",
      get: function get() {
        if (this.orientationMode === 0) {
          // y
          return this.dragState.speedY;
        } else if (this.orientationMode === 1) {
          // x
          return this.dragState.speedX;
        } else {
          return 0;
        }
      } // enter_DRAG

    }, {
      key: "onDragStart",
      value: function onDragStart() {
        this.emit('dragstart');
      } // exit_DRAG

    }, {
      key: "onDragEnd",
      value: function onDragEnd() {
        this.emit('dragend');
      } // everyTick_DRAG

    }, {
      key: "dragging",
      value: function dragging() {
        this.value += this.dragDelta;
      } // enter_SLIDE 

    }, {
      key: "onSliding",
      value: function onSliding() {
        var start = this.value;
        var speed = this.dragSpeed;

        if (speed === 0) {
          this._slowDown.stop();

          this._state.next();

          return;
        }

        var dec = this.slidingDeceleration;

        this._slowDown.init(start, speed > 0, Math.abs(speed), dec);
      } // everyTick_SLIDE

    }, {
      key: "sliding",
      value: function sliding(time, delta) {
        delta *= 0.001;

        var newValue = this._slowDown.update(delta).value;

        if (this.overMax(newValue)) {
          this.value = this.maxValue;

          this._slowDown.stop();
        } else if (this.overMin(newValue)) {
          this.value = this.minValue;

          this._slowDown.stop();
        } else {
          this.value = newValue;
        }
      } // enter_BACK

    }, {
      key: "onPullBack",
      value: function onPullBack() {
        var start = this.value;
        var end = this.outOfMinBound ? this.minValue : this.maxValue;
        var dist = Math.abs(end - start);
        var dec = this.backDeceleration;
        var speed = Math.sqrt(2 * dec * dist);

        this._slowDown.init(start, undefined, speed, dec, end);
      } // everyTick_BACK

    }, {
      key: "pullBack",
      value: function pullBack(time, delta) {
        delta *= 0.001;
        this.value = this._slowDown.update(delta).value;

        if (!this._slowDown.isMoving) {
          this._state.next();
        }
      } // exit_SLIDE, exit_BACK

    }, {
      key: "stop",
      value: function stop() {
        this._slowDown.stop();
      }
    }]);

    return Scroller;
  }(ComponentBase);

  var ORIENTATIONMODE$1 = {
    y: 0,
    v: 0,
    vertical: 0,
    x: 1,
    h: 1,
    horizontal: 1
  };

  var GetValue$A = Phaser.Utils.Objects.GetValue;

  var MouseWheelScroller = /*#__PURE__*/function (_ComponentBase) {
    _inherits(MouseWheelScroller, _ComponentBase);

    var _super = _createSuper(MouseWheelScroller);

    function MouseWheelScroller(gameObject, config) {
      var _this;

      _classCallCheck(this, MouseWheelScroller);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;

      if (_this.parent !== _this.scene) {
        _this.focusMode = GetValue$A(config, 'focus', false);
      } else {
        _this.focusMode = false;
      }

      _this.setSpeed(GetValue$A(config, 'speed', 0.1));

      _this.setEnable(GetValue$A(config, 'enable', true));

      if (!_this.focusMode) {
        // Register on scene
        _this.scene.input.on('wheel', _this.onSceneScroll, _assertThisInitialized(_this));
      } else {
        var gameObject = _this.parent;
        gameObject.setInteractive(GetValue$A(config, "inputConfig", undefined)).on('wheel', function (pointer, dx, dy, dz, event) {
          if (!this.enable) {
            return;
          }

          this.scroll(dy);
        }, _assertThisInitialized(_this));
      }

      return _this;
    }

    _createClass(MouseWheelScroller, [{
      key: "destroy",
      value: function destroy() {
        if (!this.focusMode) {
          this.scene.input.off('wheel', this.onSceneScroll, this);
        }
      }
    }, {
      key: "onSceneScroll",
      value: function onSceneScroll(pointer, currentlyOver, dx, dy, dz, event) {
        if (!this.enable) {
          return;
        }

        this.scroll(dy);
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "setSpeed",
      value: function setSpeed(speed) {
        this.speed = speed;
        return this;
      }
    }, {
      key: "scroll",
      value: function scroll(dy) {
        dy *= this.speed;
        this.emit('scroll', dy, this.parent, this);
      }
    }]);

    return MouseWheelScroller;
  }(ComponentBase);

  var GetValue$z = Phaser.Utils.Objects.GetValue;

  var CreateScrollableSizer = function CreateScrollableSizer(parent, config) {
    var scene = parent.scene;
    var scrollMode = GetScrollMode(config);
    var scrollableSizer = new Sizer(scene, {
      orientation: scrollMode
    }); // A child which not put into scene

    var child = GetValue$z(config, 'child.gameObject', undefined);
    var sliderConfig = GetValue$z(config, 'slider', undefined),
        slider;
    var sliderPosition = GetValue$z(sliderConfig, 'position', 0);

    if (typeof sliderPosition === 'string') {
      sliderPosition = SLIDER_POSITION_MAP[sliderPosition];
    }

    var isRightSlider = sliderPosition === 0; // Right/bottom slider

    var scrollerConfig = GetValue$z(config, 'scroller', true),
        scroller;
    var mouseWheelScrollerConfig = GetValue$z(config, 'mouseWheelScroller', false),
        mouseWheelScroller; // Child, slider, scroller, mouseWheelScroller

    if (child) {
      var childSpace = GetValue$z(config, 'space.child', 0);
      var childPadding = {};
      parent.childMargin = {};

      if (typeof childSpace !== 'number') {
        var paddingConfig = childSpace;

        if (scrollMode === 0) {
          childPadding.left = GetValue$z(paddingConfig, 'left', 0);
          childPadding.right = GetValue$z(paddingConfig, 'right', 0);
          parent.childMargin.top = GetValue$z(paddingConfig, 'top', 0);
          parent.childMargin.bottom = GetValue$z(paddingConfig, 'bottom', 0);
        } else {
          childPadding.top = GetValue$z(paddingConfig, 'top', 0);
          childPadding.bottom = GetValue$z(paddingConfig, 'bottom', 0);
          parent.childMargin.top = GetValue$z(paddingConfig, 'left', 0);
          parent.childMargin.bottom = GetValue$z(paddingConfig, 'right', 0);
        }
      } else {
        if (sliderConfig) {
          // Has slider
          if (scrollMode === 0) {
            childPadding = isRightSlider ? {
              right: childSpace
            } : {
              left: childSpace
            };
          } else {
            childPadding = isRightSlider ? {
              bottom: childSpace
            } : {
              top: childSpace
            };
          }
        }

        parent.childMargin.top = 0;
        parent.childMargin.bottom = 0;
      }

      if (sliderConfig) {
        if (sliderConfig === true) {
          sliderConfig = {};
        } // Vertical slider(orientation=1) for left-right scrollableSizer(orientation=0)
        // Horizontal slider(orientation=0) for top-bottom scrollableSizer(orientation=1)


        sliderConfig.orientation = scrollableSizer.orientation === 0 ? 1 : 0;
        slider = new Slider(scene, sliderConfig);
        parent.adaptThumbSizeMode = GetValue$z(sliderConfig, 'adaptThumbSize', false);
        parent.minThumbSize = GetValue$z(sliderConfig, 'minThumbSize', undefined);
      } else {
        parent.adaptThumbSizeMode = false;
        parent.minThumbSize = undefined;
      }

      if (scrollerConfig) {
        if (scrollerConfig === true) {
          scrollerConfig = {};
        }

        scrollerConfig.orientation = scrollMode;
        scroller = new Scroller(child, scrollerConfig);
      }

      if (mouseWheelScrollerConfig) {
        mouseWheelScroller = new MouseWheelScroller(child, mouseWheelScrollerConfig);
      } // Add slider to parent sizer at left/top side


      if (slider && !isRightSlider) {
        scrollableSizer.add(slider, {
          proportion: 0,
          align: 'center',
          expand: true
        });
      } // Add child to parent sizer


      var proportion = GetValue$z(config, 'child.proportion', 1);
      var expand = GetValue$z(config, 'child.expand', true);
      scrollableSizer.add(child, {
        proportion: proportion,
        align: 'center',
        padding: childPadding,
        expand: expand
      }); // Add slider to parent sizer at right/bottom side

      if (slider && isRightSlider) {
        scrollableSizer.add(slider, {
          proportion: 0,
          align: 'center',
          expand: true
        });
      }
    } // Control


    if (slider) {
      slider.on('valuechange', function (newValue) {
        parent.t = newValue;
        parent.emit('scroll', parent);
      });
    }

    if (scroller) {
      scroller.on('valuechange', function (newValue) {
        parent.childOY = newValue;
        parent.emit('scroll', parent);
      });
    }

    if (mouseWheelScroller) {
      mouseWheelScroller.on('scroll', function (incValue) {
        parent.addChildOY(-incValue, true);
      });
    }

    parent.addChildrenMap('child', child);
    parent.addChildrenMap('slider', slider);
    parent.addChildrenMap('scroller', scroller);
    parent.addChildrenMap('mouseWheelScroller', mouseWheelScroller);
    return scrollableSizer;
  };

  var SLIDER_POSITION_MAP = {
    right: 0,
    left: 1,
    bottom: 0,
    top: 1
  };

  Sizer.prototype.runLayout;

  var ResizeController = function ResizeController() {
    var topChildOY = this.topChildOY;
    var bottomChildOY = this.bottomChildOY;
    var scroller = this.childrenMap.scroller;
    var slider = this.childrenMap.slider;

    if (scroller) {
      scroller.setBounds(bottomChildOY, topChildOY);
    }

    if (slider) {
      slider.setEnable(bottomChildOY !== topChildOY);
    }

    this.updateController();

    if (this.adaptThumbSizeMode) {
      AdaptThumbSize.call(this);
    }

    return this;
  };

  var AdaptThumbSize = function AdaptThumbSize() {
    // Change slider size according to visible ratio
    var ratio = Math.min(this.childVisibleHeight / this.childHeight, 1);
    var slider = this.childrenMap.slider;
    var track = slider.childrenMap.track;
    var thumb = slider.childrenMap.thumb;
    var minThumbSize = this.minThumbSize;

    if (this.scrollMode === 0) {
      var newHeight = track.displayHeight * ratio;

      if (minThumbSize !== undefined && newHeight < minThumbSize) {
        newHeight = minThumbSize;
      }

      ResizeGameObject(thumb, undefined, newHeight);
    } else {
      var newWidth = track.displayWidth * ratio;

      if (minThumbSize !== undefined && newWidth < minThumbSize) {
        newWidth = minThumbSize;
      }

      ResizeGameObject(thumb, newWidth, undefined);
    }

    LayoutSlider.call(this);
  };

  var LayoutSlider = function LayoutSlider() {
    var slider = this.childrenMap.slider; // Save minSize

    var minWidthSave = slider.minWidth;
    var minHeightSave = slider.minHeight; // Set minSize to current size

    slider.minWidth = slider.width;
    slider.minHeight = slider.height; // Layout slider

    slider.layout(); // Restore minSize

    slider.minWidth = minWidthSave;
    slider.minHeight = minHeightSave;
  };

  var UpdateController = function UpdateController() {
    var scroller = this.childrenMap.scroller;
    var slider = this.childrenMap.slider;

    if (scroller) {
      scroller.setValue(this.childOY);
    }

    if (slider) {
      slider.setValue(this.t);
    }
  };

  var GetValue$y = Phaser.Utils.Objects.GetValue;
  var Clamp$3 = Phaser.Math.Clamp;

  var Scrollable = /*#__PURE__*/function (_Sizer) {
    _inherits(Scrollable, _Sizer);

    var _super = _createSuper(Scrollable);

    function Scrollable(scene, config) {
      var _this;

      _classCallCheck(this, Scrollable);

      if (config === undefined) {
        config = {};
      }

      var scrollMode = GetScrollMode(config); // Left-to-right, or top-to-bottom
      // Create sizer

      config.orientation = scrollMode === 0 ? 1 : 0;
      _this = _super.call(this, scene, config);
      _this.type = GetValue$y(config, 'type', 'rexScrollable'); // Add elements

      var background = GetValue$y(config, 'background', undefined);
      var scrollableSizer = CreateScrollableSizer(_assertThisInitialized(_this), config);
      var header = GetValue$y(config, 'header', undefined);
      var footer = GetValue$y(config, 'footer', undefined); // Background

      if (background) {
        _this.addBackground(background);
      }

      if (header) {
        var align = GetValue$y(config, 'align.header', 'center');
        var headerSpace = GetValue$y(config, 'space.header', 0);
        var padding;

        if (scrollMode === 0) {
          padding = {
            bottom: headerSpace
          };
        } else {
          padding = {
            right: headerSpace
          };
        }

        var expand = GetValue$y(config, 'expand.header', true);

        _this.add(header, {
          proportion: 0,
          align: align,
          padding: padding,
          expand: expand
        });
      }

      if (scrollableSizer) {
        _this.add(scrollableSizer, {
          proportion: 1,
          align: 'center',
          padding: 0,
          expand: true
        });
      }

      if (footer) {
        var align = GetValue$y(config, 'align.footer', 'center');
        var footerSpace = GetValue$y(config, 'space.footer', 0);
        var padding;

        if (scrollMode === 0) {
          padding = {
            top: footerSpace
          };
        } else {
          padding = {
            left: footerSpace
          };
        }

        var expand = GetValue$y(config, 'expand.footer', true);

        _this.add(footer, {
          proportion: 0,
          align: align,
          padding: padding,
          expand: expand
        });
      }

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('header', header);

      _this.addChildrenMap('footer', footer);

      _this.runLayoutFlag = false;
      /* Necessary properties of child object
      - child.t (RW), 
      - child.childOY (RW)
      - child.topChildOY (R)
      - child.bottomChildOY (R)
      - child.childVisibleHeight (R)
      - child.childHeight (R)
      */

      return _this;
    }

    _createClass(Scrollable, [{
      key: "runLayout",
      value: function runLayout(parent, newWidth, newHeight) {
        // Skip hidden or !dirty sizer
        if (this.ignoreLayout) {
          return this;
        }

        _get(_getPrototypeOf(Scrollable.prototype), "runLayout", this).call(this, parent, newWidth, newHeight);

        this.resizeController(); // Set `t` to 0 at first runLayout()

        if (!this.runLayoutFlag) {
          this.runLayoutFlag = true;
          this.setT(0);
        }

        return this;
      }
    }, {
      key: "t",
      get: function get() {
        var t = this.childrenMap.child.t; // Get outer childT

        var childMargin = this.childMargin;

        if (childMargin.top !== 0 || childMargin.bottom !== 0) {
          var child = this.childrenMap.child;
          var innerHeight = child.topChildOY - child.bottomChildOY;
          var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
          var outerChildOY = innerHeight * t + childMargin.top;
          t = outerChildOY / outerHeight;
        }

        return t;
      },
      set: function set(t) {
        // Get inner childT
        var childMargin = this.childMargin;

        if (childMargin.top !== 0 || childMargin.bottom !== 0) {
          var child = this.childrenMap.child;
          var innerHeight = child.topChildOY - child.bottomChildOY;
          var outerHeight = innerHeight + childMargin.top + childMargin.bottom;
          var innerChildOY = outerHeight * t - childMargin.top;
          t = innerChildOY / innerHeight;
        }

        this.childrenMap.child.t = t;
        this.updateController();
      }
    }, {
      key: "childOY",
      get: function get() {
        return this.childrenMap.child.childOY;
      },
      set: function set(value) {
        this.childrenMap.child.childOY = value;
        this.updateController();
      }
    }, {
      key: "topChildOY",
      get: function get() {
        return this.childrenMap.child.topChildOY + this.childMargin.top;
      }
    }, {
      key: "bottomChildOY",
      get: function get() {
        return this.childrenMap.child.bottomChildOY - this.childMargin.bottom;
      }
    }, {
      key: "childVisibleHeight",
      get: function get() {
        return this.childrenMap.child.childVisibleHeight;
      }
    }, {
      key: "childHeight",
      get: function get() {
        return this.childrenMap.child.childHeight;
      }
    }, {
      key: "isOverflow",
      get: function get() {
        var child = this.childrenMap.child;
        return child.topChildOY !== child.bottomChildOY;
      }
    }, {
      key: "scrollMode",
      get: function get() {
        return this.orientation === 0 ? 1 : 0;
      }
    }, {
      key: "setChildOY",
      value: function setChildOY(value, clamp) {
        if (clamp === undefined) {
          clamp = false;
        }

        if (clamp) {
          value = Clamp$3(value, this.bottomChildOY, this.topChildOY);
        }

        this.childOY = value;
        return this;
      }
    }, {
      key: "addChildOY",
      value: function addChildOY(inc, clamp) {
        this.setChildOY(this.childOY + inc, clamp);
        return this;
      }
    }, {
      key: "setT",
      value: function setT(value, clamp) {
        if (clamp === undefined) {
          clamp = false;
        }

        if (clamp) {
          value = Clamp$3(value, 0, 1);
        }

        this.t = value;
        return this;
      }
    }, {
      key: "addT",
      value: function addT(inc, clamp) {
        this.setT(this.t + inc, clamp);
        return this;
      }
    }, {
      key: "scrollToTop",
      value: function scrollToTop() {
        this.t = 0;
        return this;
      }
    }, {
      key: "scrollToBottom",
      value: function scrollToBottom() {
        this.t = 1;
        return this;
      }
    }, {
      key: "sliderEnable",
      get: function get() {
        var slider = this.childrenMap.slider;

        if (!slider) {
          return false;
        }

        return slider.enable;
      },
      set: function set(value) {
        var slider = this.childrenMap.slider;

        if (!slider) {
          return;
        }

        slider.setEnable(value);
      }
    }, {
      key: "setSliderEnable",
      value: function setSliderEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }

        this.sliderEnable = enabled;
        return this;
      }
    }, {
      key: "scrollerEnable",
      get: function get() {
        var scroller = this.childrenMap.scroller;

        if (!scroller) {
          return false;
        }

        return scroller.enable;
      },
      set: function set(value) {
        var scroller = this.childrenMap.scroller;

        if (!scroller) {
          return;
        }

        scroller.setEnable(value);
      }
    }, {
      key: "setScrollerEnable",
      value: function setScrollerEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }

        this.scrollerEnable = enabled;
        return this;
      }
    }, {
      key: "mouseWheelScrollerEnable",
      get: function get() {
        var mouseWheelScroller = this.childrenMap.mouseWheelScroller;

        if (!mouseWheelScroller) {
          return false;
        }

        return mouseWheelScroller.enable;
      },
      set: function set(value) {
        var mouseWheelScroller = this.childrenMap.mouseWheelScrollerEnable;

        if (!mouseWheelScroller) {
          return;
        }

        mouseWheelScroller.setEnable(value);
      }
    }, {
      key: "setMouseWheelScrollerEnable",
      value: function setMouseWheelScrollerEnable(enabled) {
        if (enabled === undefined) {
          enabled = true;
        }

        this.mouseWheelScrollerEnable = enabled;
        return this;
      }
    }, {
      key: "setDropZoneEnable",
      value: function setDropZoneEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }

        var child = this.childrenMap.child;
        child.setInteractive();
        child.input.dropZone = enable;
        return this;
      }
    }]);

    return Scrollable;
  }(Sizer);

  var Methods$4 = {
    resizeController: ResizeController,
    updateController: UpdateController
  }; // mixin

  Object.assign(Scrollable.prototype, Methods$4);

  var Cell = /*#__PURE__*/function () {
    function Cell(parent, config) {
      _classCallCheck(this, Cell);

      this.container = null;
      this._deltaHeight = 0;
      this.setParent(parent); // this.resetFromJSON(config);
    }

    _createClass(Cell, [{
      key: "setParent",
      value: function setParent(parent) {
        this.parent = parent; // parent: table

        this.parentContainer = parent.getParentContainer();
      } // resetFromJSON(o) {
      //     return this;
      // }

    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        if (fromScene === undefined) {
          fromScene = false;
        }

        if (!fromScene) {
          this.destroyContainer();
        }

        this.deltaHeight = 0;
        this.data = undefined;
        this.container = null;
        this.parent = undefined;
        this.parentContainer = undefined;
      }
    }, {
      key: "table",
      get: function get() {
        return this.parent;
      }
    }, {
      key: "scrollMode",
      get: function get() {
        return this.parentContainer.scrollMode;
      }
    }, {
      key: "colIndx",
      get: function get() {
        return this.parent.cellIndxeToColIndex(this.index);
      }
    }, {
      key: "rowIndx",
      get: function get() {
        return this.parent.cellIndxeToRowIndex(this.index);
      }
    }, {
      key: "getContainer",
      value: function getContainer() {
        return this.container;
      }
    }, {
      key: "setContainer",
      value: function setContainer(container) {
        if (!container) {
          this.destroyContainer();
          return this;
        }

        if (this.container) {
          this.container.destroy();
        }

        this.container = container;
        this.parentContainer.add(container);
        return this;
      }
    }, {
      key: "destroyContainer",
      value: function destroyContainer() {
        if (this.container) {
          this.container.destroy();
          this.container = null;
        }

        return this;
      }
    }, {
      key: "popContainer",
      value: function popContainer() {
        if (this.container) {
          var container = this.container;
          this.container = null;
          this.parentContainer.remove(container);
          return container;
        } else {
          return null;
        }
      }
    }, {
      key: "setXY",
      value: function setXY(x, y) {
        if (this.container) {
          this.parentContainer.setChildLocalPosition(this.container, x, y);
        }

        return this;
      }
    }, {
      key: "deltaHeight",
      get: function get() {
        return this._deltaHeight;
      },
      set: function set(deltaHeight) {
        if (deltaHeight == null) {
          deltaHeight = 0;
        }

        var table = this.parent;

        if (this._deltaHeight === 0 && deltaHeight !== 0) {
          table.nonZeroDeltaHeightCount++;
        } else if (this._deltaHeight !== 0 && deltaHeight === 0) {
          table.nonZeroDeltaHeightCount--;
        }

        var isTableHeightChanged = this._deltaHeight !== deltaHeight;
        this._deltaHeight = deltaHeight;

        if (isTableHeightChanged) {
          table.resetTotalRowsHeight();
          var eventName = this.scrollMode === 0 ? 'cellheightchange' : 'cellwidthchange';
          this.parentContainer.emit(eventName, this, this.container, this.parentContainer);
        }
      }
    }, {
      key: "deltaWidth",
      get: function get() {
        return this.deltaHeight;
      },
      set: function set(deltaWidth) {
        this.deltaHeight = deltaWidth;
      }
    }, {
      key: "setDeltaHeight",
      value: function setDeltaHeight(deltaHeight) {
        this.deltaHeight = deltaHeight;
        return this;
      }
    }, {
      key: "setDeltaWidth",
      value: function setDeltaWidth(deltaWidth) {
        this.deltaHeight = deltaWidth;
        return this;
      }
    }, {
      key: "height",
      get: function get() {
        if (this.scrollMode === 0) {
          return this.deltaHeight + this.parent.defaultCellHeight;
        } else {
          return this.parent.defaultCellWidth;
        }
      },
      set: function set(height) {
        // Only worked when scrollMode is 0
        if (this.scrollMode === 1) {
          return;
        }

        this.setDeltaHeight(height - this.parent.defaultCellHeight);
      }
    }, {
      key: "setHeight",
      value: function setHeight(height) {
        // Only worked when scrollMode is 0
        this.height = height;
        return this;
      }
    }, {
      key: "width",
      get: function get() {
        if (this.scrollMode === 0) {
          return this.parent.defaultCellWidth;
        } else {
          return this.deltaHeight + this.parent.defaultCellHeight;
        }
      },
      set: function set(width) {
        // Only worked when scrollMode is 1
        if (this.scrollMode === 0) {
          return;
        }

        this.setDeltaHeight(width - this.parent.defaultCellHeight);
      }
    }, {
      key: "setWidth",
      value: function setWidth(width) {
        this.width = width;
        return this;
      }
    }, {
      key: "scene",
      get: function get() {
        return this.parentContainer.scene;
      }
    }]);

    return Cell;
  }();
  Object.assign(Cell.prototype, DataMethods);

  var GetValue$x = Phaser.Utils.Objects.GetValue;
  var SpliceOne = Phaser.Utils.Array.SpliceOne;

  var Table = /*#__PURE__*/function () {
    function Table(parent, config) {
      _classCallCheck(this, Table);

      this.parent = parent; // parent: GridTable game object (Container)

      this.cells = [];
      this.cellPool = new Stack();
      this.resetFromJSON(config);
    }

    _createClass(Table, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.colCount = undefined;
        this.nonZeroDeltaHeightCount = 0;
        this.resetTotalRowsHeight();
        this.setDefaultCellHeight(GetValue$x(o, 'cellHeight', 30));
        this.setDefaultCellWidth(GetValue$x(o, 'cellWidth', 30));
        this.initCells(GetValue$x(o, 'cellsCount', 0));
        this.setColumnCount(GetValue$x(o, 'columns', 1));
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        // GridTable is destroyed, all cell containers will also be destroyed too
        // Don't have to freeCell
        this.cellPool.destroy();
        this.cells = undefined;
        this.parent = undefined;
      }
    }, {
      key: "defaultCellHeightMode",
      get: function get() {
        return this.nonZeroDeltaHeightCount === 0;
      }
    }, {
      key: "setDefaultCellHeight",
      value: function setDefaultCellHeight(height) {
        this.defaultCellHeight = height;
        return this;
      }
    }, {
      key: "setDefaultCellWidth",
      value: function setDefaultCellWidth(width) {
        this.defaultCellWidth = width;
        return this;
      }
    }, {
      key: "initCells",
      value: function initCells(size) {
        var cells = this.cells;
        cells.length = size;

        for (var i = 0; i < size; i++) {
          cells[i] = null;
        }

        return this;
      }
    }, {
      key: "insertNewCells",
      value: function insertNewCells(cellIdx, count) {
        var cells = this.cells;

        if (cellIdx === cells.length) {
          // append at end of array
          var endIdx = cellIdx + count;
          cells.legth = endIdx;

          for (var i = cellIdx; i < endIdx; i++) {
            cells[i] = null;
          }
        } else {
          var _this$cells;

          var newCells = [];
          newCells.length = count;

          for (var i = 0; i < count; i++) {
            newCells[i] = null;
          }

          (_this$cells = this.cells).splice.apply(_this$cells, [cellIdx, 0].concat(newCells));
        }

        this.resetTotalRowsHeight();
        return this;
      }
    }, {
      key: "removeCells",
      value: function removeCells(cellIdx, count) {
        var endIdx = cellIdx + count;

        for (var i = cellIdx; i < endIdx; i++) {
          this.freeCell(i);
        }

        if (endIdx === this.cells.length) {
          // remove until end of array
          this.cells.length = cellIdx;
        } else {
          if (count === 1) {
            SpliceOne(this.cells, cellIdx);
          } else {
            this.cells.splice(cellIdx, count);
          }

          this.buildCellIndex(cellIdx);
        }

        this.resetTotalRowsHeight();
        return this;
      }
    }, {
      key: "setColumnCount",
      value: function setColumnCount(cnt) {
        this.colCount = cnt;
        this.resetTotalRowsHeight();
        return this;
      }
    }, {
      key: "rowCount",
      get: function get() {
        return Math.ceil(this.cells.length / this.colCount);
      }
    }, {
      key: "cellsCount",
      get: function get() {
        return this.cells.length;
      }
    }, {
      key: "isValidCellIdx",
      value: function isValidCellIdx(idx) {
        return idx >= 0 && idx < this.cells.length;
      }
    }, {
      key: "heightToRowIndex",
      value: function heightToRowIndex(height, isCeil) {
        // defaultCellHeightMode
        if (this.defaultCellHeightMode) {
          var rowIdx = height / this.defaultCellHeight;

          if (isCeil) {
            rowIdx = Math.ceil(rowIdx);
          } else {
            rowIdx = Math.floor(rowIdx);
          }

          return rowIdx;
        } // count cell height one by one


        var rowCount = this.rowCount;
        var remainder = height,
            isValidIdx;
        var rowHeight,
            rowIdx = 0;

        while (1) {
          rowHeight = this.getRowHeight(rowIdx);
          remainder -= rowHeight;
          isValidIdx = rowIdx >= 0 && rowIdx < rowCount;

          if (remainder > 0 && isValidIdx) {
            rowIdx += 1;
          } else if (remainder === 0) {
            return rowIdx;
          } else {
            if (isCeil) {
              var preRowIdx = rowIdx;
              rowIdx += 1;
              isValidIdx = rowIdx >= 0 && rowIdx < rowCount;
              if (!isValidIdx) rowIdx = preRowIdx;
            }

            return rowIdx;
          }
        }
      }
    }, {
      key: "widthToColIndex",
      value: function widthToColIndex(width, isCeil) {
        var colIdx = width / this.defaultCellWidth;

        if (isCeil) {
          colIdx = Math.ceil(colIdx);
        } else {
          colIdx = Math.floor(colIdx);
        }

        return colIdx;
      }
    }, {
      key: "colRowToCellIndex",
      value: function colRowToCellIndex(colIdx, rowIdx) {
        if (colIdx >= this.colCount) {
          return null;
        }

        return rowIdx * this.colCount + colIdx;
      }
    }, {
      key: "rowIndexToHeight",
      value: function rowIndexToHeight(start, end) {
        // defaultCellHeightMode
        if (this.defaultCellHeightMode) {
          return (end - start + 1) * this.defaultCellHeight;
        }

        var h,
            sum = 0;

        for (var i = start; i <= end; i++) {
          h = this.getRowHeight(i);
          sum += h;
        }

        return sum;
      }
    }, {
      key: "colIndexToWidth",
      value: function colIndexToWidth(start, end) {
        return (end - start + 1) * this.defaultCellWidth;
      }
    }, {
      key: "getRowHeight",
      value: function getRowHeight(rowIdx) {
        var cnt = this.colCount; // single column

        if (cnt <= 1) {
          return this.getCellHeight(this.colRowToCellIndex(0, rowIdx));
        } // multiple columns, get the maximum height


        var maxHeight = 0,
            cellHeight;

        for (var i = 0; i < cnt; i++) {
          cellHeight = this.getCellHeight(this.colRowToCellIndex(i, rowIdx));
          if (maxHeight < cellHeight) maxHeight = cellHeight;
        }

        return maxHeight;
      }
    }, {
      key: "getColWidth",
      value: function getColWidth(idx) {
        return this.defaultCellWidth;
      }
    }, {
      key: "getCellHeight",
      value: function getCellHeight(cellIdx) {
        if (!this.isValidCellIdx(cellIdx)) {
          return 0;
        }

        var cellHeight;
        if (this.defaultCellHeightMode) cellHeight = this.defaultCellHeight;else {
          var cell = this.getCell(cellIdx, false);
          var deltaHeight = cell ? cell.deltaHeight : 0;
          cellHeight = this.defaultCellHeight + deltaHeight;
        }
        return cellHeight;
      }
    }, {
      key: "resetTotalRowsHeight",
      value: function resetTotalRowsHeight() {
        this._totalRowsHeight = null;
      }
    }, {
      key: "totalRowsHeight",
      get: function get() {
        if (this._totalRowsHeight === null) {
          this._totalRowsHeight = this.rowIndexToHeight(0, this.rowCount - 1);
        }

        return this._totalRowsHeight;
      }
    }, {
      key: "totalColumnWidth",
      get: function get() {
        return this.colCount * this.defaultCellWidth;
      }
    }, {
      key: "cellIndxeToColIndex",
      value: function cellIndxeToColIndex(cellIdx) {
        return cellIdx % this.colCount;
      }
    }, {
      key: "cellIndxeToRowIndex",
      value: function cellIndxeToRowIndex(cellIdx) {
        return Math.floor(cellIdx / this.colCount);
      }
    }, {
      key: "getCell",
      value: function getCell(cellIdx, createNewCell) {
        if (!this.isValidCellIdx(cellIdx)) {
          return null;
        }

        if (createNewCell === undefined) {
          createNewCell = true;
        }

        if (this.cells[cellIdx] === null && createNewCell) {
          var cell = this.newCell(cellIdx);
          this.cells[cellIdx] = cell;
        }

        return this.cells[cellIdx];
      }
    }, {
      key: "newCell",
      value: function newCell(cellIdx) {
        var cell = this.cellPool.pop();

        if (cell === null) {
          cell = new Cell(this);
        } else {
          cell.setParent(this);
        }

        cell.index = cellIdx;
        return cell;
      }
    }, {
      key: "buildCellIndex",
      value: function buildCellIndex(startIdx) {
        if (startIdx === undefined) {
          startIdx = 0;
        }

        var cells = this.cells,
            cell;

        for (var i = startIdx, len = cells.length; i < len; i++) {
          cell = cells[i];

          if (cell) {
            cell.index = i;
          }
        }

        return this;
      }
    }, {
      key: "getParentContainer",
      value: function getParentContainer() {
        return this.parent;
      }
    }, {
      key: "freeCell",
      value: function freeCell(cell) {
        if (typeof cell === 'number') {
          cell = this.cells[cell];
        }

        if (!cell) {
          return this;
        }

        cell.destroy();
        this.cellPool.push(cell);
        return this;
      }
    }]);

    return Table;
  }();

  var SetTableOY = function SetTableOY(oy) {
    var table = this.table;
    var topTableOY = this.topTableOY;
    var bottomTableOY = this.bottomTableOY;
    var tableOYExceedTop = oy > this.topTableOY;
    var tableOYExeceedBottom = oy < this.bottomTableOY;

    if (this.clampTableOXY) {
      var rowCount = table.rowCount;
      var visibleRowCount = table.heightToRowIndex(this.instHeight, true); // less then 1 page            

      if (rowCount < visibleRowCount) {
        oy = 0;
      } else if (tableOYExceedTop) {
        oy = topTableOY;
      } else if (tableOYExeceedBottom) {
        oy = bottomTableOY;
      }
    }

    if (this._tableOY !== oy) {
      this._tableOY = oy;
    }

    if (tableOYExceedTop) {
      if (!this.execeedTopState) {
        this.emit('execeedtop', this, oy, topTableOY);
      }
    }

    this.execeedTopState = tableOYExceedTop;

    if (tableOYExeceedBottom) {
      if (!this.execeedBottomState) {
        this.emit('execeedbottom', this, oy, bottomTableOY);
      }
    }

    this.execeedBottomState = tableOYExeceedBottom;
    return this;
  };

  var SetTableOX = function SetTableOX(ox) {
    var table = this.table;
    var leftTableOX = this.leftTableOX;
    var rightTableOX = this.rightTableOX;
    var tableOXExeceedLeft = ox > this.leftTableOX;
    var tableOXExeceedRight = ox < this.rightTableOX;

    if (this.clampTableOXY) {
      var colCount = table.colCount;
      var visibleColCount = table.widthToColIndex(this.instWidth, true); // less then 1 page            

      if (colCount < visibleColCount) {
        ox = 0;
      } else if (tableOXExeceedLeft) {
        ox = leftTableOX;
      } else {
        // var tableVisibleWidth = this.tableVisibleWidth;
        if (tableOXExeceedRight) ox = rightTableOX;
      }
    }

    if (this._tableOX !== ox) {
      this._tableOX = ox;
    }

    if (tableOXExeceedLeft) {
      if (!this.execeedLeftState) {
        this.emit('execeedleft', this, ox, leftTableOX);
      }
    }

    this.execeedLeftState = tableOXExeceedLeft;

    if (tableOXExeceedRight) {
      if (!this.execeedRightState) {
        this.emit('execeedright', this, ox, rightTableOX);
      }
    }

    this.execeedRightState = tableOXExeceedRight;
    return this;
  };

  var MaskToGameObject = function MaskToGameObject(mask) {
    return mask.hasOwnProperty('geometryMask') ? mask.geometryMask : mask.bitmapMask;
  };

  var Intersects = Phaser.Geom.Intersects.RectangleToRectangle;
  var Overlaps = Phaser.Geom.Rectangle.Overlaps;

  var MaskChildren = function MaskChildren(parent, mask, children) {
    if (!mask) {
      return;
    }

    if (children === undefined) {
      children = parent.getAllChildren();
    }

    var parentBounds = parent.getBounds();
    var maskGameObject = MaskToGameObject(mask);
    var child, childBounds, visiblePointsNumber;

    for (var i = 0, cnt = children.length; i < cnt; i++) {
      child = children[i];

      if (child.hasOwnProperty('isRexContainerLite')) {
        continue;
      }

      if (child === maskGameObject) {
        continue;
      }

      if (!IsVisible(child)) {
        // Child is invisible before masking
        continue;
      }

      if (child.getBounds) {
        childBounds = child.getBounds(childBounds);
        visiblePointsNumber = ContainsPoints(parentBounds, childBounds);

        switch (visiblePointsNumber) {
          case 4:
            // 4 points are all inside visible window, set visible
            ShowAll(parent, child);
            break;

          case 0:
            // No point is inside visible window
            // Parent intersects with child, or parent is inside child, set visible, and apply mask
            if (Intersects(parentBounds, childBounds) || Overlaps(parentBounds, childBounds)) {
              ShowSome(parent, child, mask);
            } else {
              // Set invisible
              ShowNone(parent, child);
            }

            break;

          default:
            // Part of points are inside visible window, set visible, and apply mask
            ShowSome(parent, child, mask);
            break;
        }
      } else {
        ShowSome(parent, child, mask);
      }
    }
  };

  var IsVisible = function IsVisible(gameObject) {
    while (1) {
      var localState = gameObject.rexContainer;

      if (!localState) {
        // Top game object
        return gameObject.visible;
      } else if (localState.visible) {
        var parent = localState.parent;

        if (parent) {
          // Test parent's visible
          gameObject = parent;
          continue;
        } else {
          // Top visible game object
          return true;
        }
      } else {
        // Current game object is invisible
        return false;
      }
    }
  };

  var ContainsPoints = function ContainsPoints(rectA, rectB) {
    var result = 0;
    var top = rectB.top,
        bottom = rectB.bottom,
        left = rectB.left,
        right = rectB.right;
    result += rectA.contains(left, top) ? 1 : 0;
    result += rectA.contains(left, bottom) ? 1 : 0;
    result += rectA.contains(right, top) ? 1 : 0;
    result += rectA.contains(right, bottom) ? 1 : 0;
    return result;
  };

  var ShowAll = function ShowAll(parent, child, mask) {
    parent.setChildMaskVisible(child, true);

    if (child.clearMask) {
      child.clearMask();
    }
  };

  var ShowSome = function ShowSome(parent, child, mask) {
    parent.setChildMaskVisible(child, true);

    if (child.setMask) {
      child.setMask(mask);
    }
  };

  var ShowNone = function ShowNone(parent, child, mask) {
    parent.setChildMaskVisible(child, false);

    if (child.clearMask) {
      child.clearMask();
    }
  };

  var GetValue$w = Phaser.Utils.Objects.GetValue;
  var MASKUPDATEMODE = {
    update: 0,
    everyTick: 1
  };
  var ChildrenMaskMethods = {
    setupChildrenMask: function setupChildrenMask(config) {
      if (config === false) {
        // No children mask
        return this;
      }

      this.setMaskUpdateMode(GetValue$w(config, 'updateMode', 0));
      this.enableChildrenMask(GetValue$w(config, 'padding', 0));
      this.setMaskLayer(GetValue$w(config, 'layer', undefined));
      this.startMaskUpdate();
      return this;
    },
    destroyChildrenMask: function destroyChildrenMask() {
      if (!this.childrenMask) {
        return this;
      }

      this.stopMaskUpdate();
      this.childrenMask.destroy();
      this.childrenMask = undefined;
      return this;
    },
    setMaskUpdateMode: function setMaskUpdateMode(mode) {
      if (typeof mode === 'string') {
        mode = MASKUPDATEMODE[mode];
      }

      this.maskUpdateMode = mode;
      return this;
    },
    startMaskUpdate: function startMaskUpdate() {
      this.scene.game.events.on('poststep', this.maskChildren, this);
    },
    stopMaskUpdate: function stopMaskUpdate() {
      this.scene.game.events.off('poststep', this.maskChildren, this);
    },
    enableChildrenMask: function enableChildrenMask(maskPadding) {
      var maskGameObject = AddChildMask.call(this, null, this, 0, maskPadding);
      this.childrenMask = maskGameObject.createGeometryMask(); // this.childrenMask is a mask object, not a (Graphics) game object

      return this;
    },
    setMaskChildrenFlag: function setMaskChildrenFlag(value) {
      if (value === undefined) {
        value = true;
      }

      this.maskChildrenFlag = value;
      return this;
    },
    setMaskLayer: function setMaskLayer(layer) {
      // To reduce amount of masked game object
      this.maskLayer = layer;
      return this;
    },
    maskChildren: function maskChildren() {
      if (!this.childrenMask || // No childrenMask
      !this.maskChildrenFlag || // No maskChildrenFlag set
      this.alpha === 0 || !this.visible // Parent is not visible
      ) {
        return this;
      }

      if (this.maskLayer) {
        // 1. Add parent and children into layer
        this.addToLayer(this.maskLayer); // 2. Mask this layer

        this.maskLayer.setMask(this.childrenMask);
      } else {
        MaskChildren(this, this.childrenMask, this.getAllChildren(), this.maskLayer);
      }

      if (this.maskUpdateMode === 0) {
        this.maskChildrenFlag = false;
      }

      return this;
    },
    layoutChildrenMask: function layoutChildrenMask() {
      if (!this.childrenMask) {
        return this;
      }

      var maskGameObject = MaskToGameObject(this.childrenMask);
      maskGameObject.setPosition().resize();
      this.resetChildPositionState(maskGameObject);
      return this;
    }
  };

  var HideCell = function HideCell(cell) {
    // Option: pop container of cell by cell.popContainer() under this event 
    this.emit('cellinvisible', cell);

    if (this.cellContainersPool) {
      var cellContainer = cell.popContainer(); // null if already been removed

      if (cellContainer) {
        this.cellContainersPool.killAndHide(cellContainer);
      }
    }

    cell.destroyContainer(); // Destroy container of cell
  };

  var HideCells = function HideCells() {
    var preList = this.preVisibleCells;
    var curList = this.visibleCells;
    preList.iterate(function (cell) {
      if (!curList.contains(cell)) {
        HideCell.call(this, cell);
      }
    }, this);
  };

  var ShowCell = function ShowCell(cell) {
    // Attach container to cell by cell.setContainer(container) under this event
    var reusedCellContainer = null;
    var cellContainer = cell.getContainer();

    if (cellContainer) {
      reusedCellContainer = cellContainer;
      cell.popContainer();
    } else if (this.cellContainersPool) {
      reusedCellContainer = this.cellContainersPool.getFirstDead();

      if (reusedCellContainer !== null) {
        // Reuse this game object
        reusedCellContainer.setActive(true).setVisible(true);
      }
    }

    this.emit('cellvisible', cell, reusedCellContainer, this);

    if (this.cellContainersPool) {
      var cellContainer = cell.getContainer();

      if (cellContainer) {
        if (reusedCellContainer === null) {
          this.cellContainersPool.add(cellContainer); // New cell container, add to pool
        } else if (reusedCellContainer !== cellContainer) {
          // Why reusedCellContainer is not equal to cellContainer?
          this.cellContainersPool.add(cellContainer); // New cell container, add to pool

          this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
        }
      } else {
        // No cell container added
        if (reusedCellContainer !== null) {
          this.cellContainersPool.killAndHide(reusedCellContainer); // Unused cell container, put back to pool
        }
      }
    }
  };

  var ShowCells = function ShowCells() {
    if (this.cellsCount === 0) {
      return;
    }

    var table = this.table;
    var startRowIdx = table.heightToRowIndex(-this.tableOY);

    if (startRowIdx <= 0) {
      startRowIdx = 0; //Turn -0 to 0
    }

    var rowIdx = startRowIdx;
    var startColIdx = table.widthToColIndex(-this.tableOX);

    if (startColIdx <= 0) {
      startColIdx = 0; //Turn -0 to 0
    }

    var colIdx = startColIdx;
    var cellIdx = table.colRowToCellIndex(colIdx, rowIdx);
    var bottomBound = this.bottomBound;
    var rightBound = this.rightBound;
    var lastIdx = table.cellsCount - 1;
    var lastColIdx = table.colCount - 1;
    var startCellTLX = GetCellTLX.call(this, colIdx),
        cellTLX = startCellTLX;
    var cellTLY = GetCellTLY.call(this, rowIdx);

    while (cellTLY < bottomBound && cellIdx <= lastIdx) {
      if (this.table.isValidCellIdx(cellIdx)) {
        var cell = table.getCell(cellIdx, true);
        this.visibleCells.set(cell);

        if (!this.preVisibleCells.contains(cell)) {
          ShowCell.call(this, cell);
        }

        if (this.scrollMode === 0) {
          cell.setXY(cellTLX, cellTLY);
        } else {
          cell.setXY(cellTLY, cellTLX);
        }
      }

      if (cellTLX < rightBound && colIdx < lastColIdx) {
        cellTLX += table.getColWidth(colIdx);
        colIdx += 1;
      } else {
        cellTLX = startCellTLX;
        cellTLY += table.getRowHeight(rowIdx);
        colIdx = startColIdx;
        rowIdx += 1;
      }

      cellIdx = table.colRowToCellIndex(colIdx, rowIdx);
    }
  };

  var GetCellTLX = function GetCellTLX(colIdx) {
    var ox = this.scrollMode === 0 ? this.topLeftX : this.topLeftY;
    var x = this.tableOX + this.table.colIndexToWidth(0, colIdx - 1) + ox;
    return x;
  };

  var GetCellTLY = function GetCellTLY(rowIdx) {
    var oy = this.scrollMode === 0 ? this.topLeftY : this.topLeftX;
    var y = this.tableOY + this.table.rowIndexToHeight(0, rowIdx - 1) + oy;
    return y;
  };

  var UpdateTable = function UpdateTable(refresh) {
    if (refresh === undefined) {
      refresh = false;
    }

    if (refresh) {
      ClearVisibleCellIndexes.call(this);
      HideCells.call(this);
    }

    ClearVisibleCellIndexes.call(this);
    ShowCells.call(this);
    HideCells.call(this);
    this.setMaskChildrenFlag();
    return this;
  };

  var ClearVisibleCellIndexes = function ClearVisibleCellIndexes() {
    var tmp = this.preVisibleCells;
    this.preVisibleCells = this.visibleCells;
    this.visibleCells = tmp;
    this.visibleCells.clear();
  };

  var IsCellVisible = function IsCellVisible(cellIdx) {
    var cell = this.table.getCell(cellIdx, false);
    return cell && this.visibleCells.contains(cell);
  };

  var PointToCellIndex = function PointToCellIndex(x, y) {
    y -= this.y + this.topLeftY;
    x -= this.x + this.topLeftX;
    var offsetTableOY = this.tableOY - (this.scrollMode === 0 ? y : x);
    var offsetTableOX = this.tableOX - (this.scrollMode === 0 ? x : y);
    var table = this.table;
    var rowIdx = table.heightToRowIndex(-offsetTableOY);
    var colIdx = table.widthToColIndex(-offsetTableOX);
    var cellIdx = table.colRowToCellIndex(colIdx, rowIdx);

    if (cellIdx === null) {
      return null;
    }

    if (!this.isCellVisible(cellIdx)) {
      return null;
    }

    return cellIdx;
  };

  var PointToCellContainer = function PointToCellContainer(x, y) {
    var cellIdx = PointToCellIndex.call(this, x, y);

    if (cellIdx === null) {
      return undefined;
    }

    return this.getCellContainer(cellIdx);
  };

  // For when you know this Set will be modified during the iteration
  var EachVisibleCell = function EachVisibleCell(callback, scope) {
    this.visibleCells.each(callback, scope);
    return this;
  }; // For when you absolutely know this Set won't be modified during the iteration


  var IterateVisibleCell = function IterateVisibleCell(callback, scope) {
    this.visibleCells.iterate(callback, scope);
    return this;
  };

  var EachCell = function EachCell(callback, scope) {
    this.table.cells.slice().forEach(callback, scope);
    return this;
  };

  var IterateCell = function IterateCell(callback, scope) {
    this.table.cells.forEach(callback, scope);
    return this;
  };

  var SetCellsCount = function SetCellsCount(count) {
    var cellsCount = this.cellsCount;

    if (cellsCount === count) {
      return this;
    }

    if (cellsCount > count) {
      this.removeCells(count, cellsCount - count);
    } else {
      // cellsCount < count
      this.insertNewCells(cellsCount, count - cellsCount);
    }

    return this;
  };

  var Clamp$2 = Phaser.Math.Clamp;

  var InsertNewCells = function InsertNewCells(cellIdx, count) {
    if (_typeof(cellIdx) === 'object') {
      cellIdx = cellIdx.index;
    }

    if (count === undefined) {
      count = 1;
    }

    if (count <= 0) {
      return this;
    }

    cellIdx = Clamp$2(cellIdx, 0, this.cellsCount);
    this.table.insertNewCells(cellIdx, count);
    return this;
  };

  var RemoveCells = function RemoveCells(cellIdx, count) {
    if (_typeof(cellIdx) === 'object') {
      cellIdx = cellIdx.index;
    }

    if (count === undefined) {
      count = 1;
    }

    if (cellIdx < 0) {
      count += cellIdx;
      cellIdx = 0;
    }

    if (count <= 0) {
      return this;
    } // out-of-range


    if (cellIdx > this.cellsCount) {
      return this;
    }

    var cell;

    for (var i = cellIdx, endIdx = cellIdx + count; i < endIdx; i++) {
      cell = this.getCell(i, false);

      if (cell) {
        if (this.visibleCells.contains(cell)) {
          HideCell.call(this, cell);
          this.visibleCells["delete"](cell);
        }

        this.preVisibleCells["delete"](cell);
      }
    }

    this.table.removeCells(cellIdx, count);
    return this;
  };

  var SetColumnCount = function SetColumnCount(count) {
    if (this.table.colCount === count) {
      return this;
    }

    this.table.setColumnCount(count);
    return this;
  };

  var SetGridSize = function SetGridSize(colCount, rowCount) {
    this.setCellsCount(colCount * rowCount);
    this.table.setColumnCount(colCount);
    return this;
  };

  var UpdateVisibleCell = function UpdateVisibleCell(cellIdx) {
    var cell = this.table.getCell(cellIdx, false);

    if (!cell || !cell.container) {
      return this;
    }

    ShowCell.call(this, cell);
    return this;
  };

  var methods$7 = {
    setTableOY: SetTableOY,
    setTableOX: SetTableOX,
    updateTable: UpdateTable,
    isCellVisible: IsCellVisible,
    pointToCellIndex: PointToCellIndex,
    pointToCellContainer: PointToCellContainer,
    eachVisibleCell: EachVisibleCell,
    iterateVisibleCell: IterateVisibleCell,
    eachCell: EachCell,
    iterateCell: IterateCell,
    setCellsCount: SetCellsCount,
    insertNewCells: InsertNewCells,
    removeCells: RemoveCells,
    setColumnCount: SetColumnCount,
    setGridSize: SetGridSize,
    updateVisibleCell: UpdateVisibleCell
  };
  Object.assign(methods$7, ChildrenMaskMethods);

  var Group = Phaser.GameObjects.Group;
  var Set = Phaser.Structs.Set;
  var GetValue$v = Phaser.Utils.Objects.GetValue;

  var GridTable$1 = /*#__PURE__*/function (_ContainerLite) {
    _inherits(GridTable, _ContainerLite);

    var _super = _createSuper(GridTable);

    function GridTable(scene, x, y, width, height, config) {
      var _this;

      _classCallCheck(this, GridTable);

      if (config === undefined) {
        config = {};
      }

      _this = _super.call(this, scene, x, y, width, height);
      _this.type = 'rexGridTable';
      _this._tableOX = 0;
      _this._tableOY = 0;
      _this.visibleCells = new Set();
      _this.preVisibleCells = new Set();
      _this.execeedTopState = false;
      _this.execeedBottomState = false;
      _this.execeedLeftState = false;
      _this.execeedRightState = false;
      var reuseCellContainer = GetValue$v(config, 'reuseCellContainer', false);

      if (reuseCellContainer) {
        _this.cellContainersPool = new Group(scene); // Don't add Group into update list, I will destroy it manually
      }

      var callback = GetValue$v(config, 'cellVisibleCallback', null);

      if (callback !== null) {
        var scope = GetValue$v(config, 'cellVisibleCallbackScope', undefined);

        _this.on('cellvisible', callback, scope);
      }

      callback = GetValue$v(config, 'cellInvisibleCallback', null);

      if (callback !== null) {
        var scope = GetValue$v(config, 'cellInvisibleCallbackScope', undefined);

        _this.on('cellinvisible', callback, scope);
      }

      _this.setupChildrenMask(GetValue$v(config, 'mask', undefined));

      _this.setScrollMode(GetValue$v(config, 'scrollMode', 0));

      _this.setClampMode(GetValue$v(config, 'clamplTableOXY', true)); // Pre-process cell size


      if (_this.scrollMode === 0) {
        // scroll y
        var cellWidth = GetValue$v(config, 'cellWidth', undefined);
        _this.expandCellSize = cellWidth === undefined;

        if (cellWidth === undefined) {
          var columns = GetValue$v(config, 'columns', 1);
          config.cellWidth = _this.width / columns;
        }
      } else {
        // scroll x
        // Swap cell width and cell height
        var cellWidth = GetValue$v(config, 'cellHeight', undefined);
        var cellHeight = GetValue$v(config, 'cellWidth', undefined);
        _this.expandCellSize = cellWidth === undefined;
        config.cellWidth = cellWidth;
        config.cellHeight = cellHeight;
      }

      _this.table = new Table(_assertThisInitialized(_this), config);

      _this.updateTable();

      return _this;
    }

    _createClass(GridTable, [{
      key: "destroy",
      value: function destroy(fromScene) {
        // preDestroy method does not have fromScene parameter
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        this.destroyChildrenMask();
        this.table.destroy(fromScene);
        this.table = undefined;

        if (this.cellContainersPool) {
          this.cellContainersPool.destroy(true);
          this.cellContainersPool = undefined;
        }

        _get(_getPrototypeOf(GridTable.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setScrollMode",
      value: function setScrollMode(mode) {
        if (typeof mode === 'string') {
          mode = SCROLLMODE[mode.toLowerCase()];
        }

        this.scrollMode = mode;
        return this;
      }
    }, {
      key: "setClampMode",
      value: function setClampMode(mode) {
        if (mode === undefined) {
          mode = true;
        }

        this.clampTableOXY = mode;
        return this;
      }
    }, {
      key: "tableOY",
      get: function get() {
        return this._tableOY;
      },
      set: function set(oy) {
        this.setTableOY(oy).updateTable();
      }
    }, {
      key: "tableOX",
      get: function get() {
        return this._tableOX;
      },
      set: function set(ox) {
        this.setTableOX(ox).updateTable();
      }
    }, {
      key: "setTableOXY",
      value: function setTableOXY(ox, oy) {
        this.setTableOY(oy).setTableOX(ox);
        return this;
      }
    }, {
      key: "addTableOY",
      value: function addTableOY(dy) {
        this.setTableOY(this.tableOY + dy);
        return this;
      }
    }, {
      key: "addTableOX",
      value: function addTableOX(dx) {
        this.setTableOX(this.tableOX + dx);
        return this;
      }
    }, {
      key: "addTableOXY",
      value: function addTableOXY(dx, dy) {
        this.addTableOY(dy).addTableOX(dx);
        return this;
      }
    }, {
      key: "setTableOYByPercentage",
      value: function setTableOYByPercentage(percentage) {
        this.setTableOY(-this.tableVisibleHeight * percentage);
        return this;
      }
    }, {
      key: "getTableOYPercentage",
      value: function getTableOYPercentage() {
        var tableVisibleHeight = this.tableVisibleHeight;

        if (tableVisibleHeight === 0) {
          return 0;
        }

        return this.tableOY / -tableVisibleHeight;
      }
    }, {
      key: "t",
      get: function get() {
        return this.getTableOYPercentage();
      },
      set: function set(value) {
        this.setTableOYByPercentage(value).updateTable();
      }
    }, {
      key: "getCell",
      value: function getCell(cellIdx) {
        return this.table.getCell(cellIdx, true);
      }
    }, {
      key: "getCellContainer",
      value: function getCellContainer(cellIdx) {
        var cell = this.table.getCell(cellIdx, false);
        var container;

        if (cell) {
          container = cell.getContainer();
        }

        return container;
      }
    }, {
      key: "cellsCount",
      get: function get() {
        return this.table.cellsCount;
      }
    }, {
      key: "columnCount",
      get: function get() {
        return this.table.colCount;
      }
    }, {
      key: "setCellHeight",
      value: function setCellHeight(cellIdx, height) {
        var cell;

        if (typeof cellIdx === 'number') {
          cell = this.table.getCell(cellIdx, true);
        } else {
          cell = cellIdx;
        }

        cell.height = height; // Only worked when scrollMode is 0

        return this;
      }
    }, {
      key: "setCellWidth",
      value: function setCellWidth(cellIdx, width) {
        var cell;

        if (typeof cellIdx === 'number') {
          cell = this.table.getCell(cellIdx, true);
        } else {
          cell = cellIdx;
        }

        cell.width = width; // Only worked when scrollMode is 1

        return this;
      }
    }, {
      key: "instHeight",
      get: function get() {
        return this.scrollMode === 0 ? this.height : this.width;
      }
    }, {
      key: "instWidth",
      get: function get() {
        return this.scrollMode === 0 ? this.width : this.height;
      }
    }, {
      key: "tableHeight",
      get: function get() {
        return this.table.totalRowsHeight;
      }
    }, {
      key: "tableWidth",
      get: function get() {
        return this.table.totalColumnWidth;
      }
    }, {
      key: "topTableOY",
      get: function get() {
        return 0;
      }
    }, {
      key: "bottomTableOY",
      get: function get() {
        return -this.tableVisibleHeight;
      }
    }, {
      key: "leftTableOX",
      get: function get() {
        return 0;
      }
    }, {
      key: "rightTableOX",
      get: function get() {
        return -this.tableVisibleWidth;
      }
    }, {
      key: "tableVisibleHeight",
      get: function get() {
        var h = this.tableHeight - this.instHeight;

        if (h < 0) {
          h = 0;
        }

        return h;
      }
    }, {
      key: "tableVisibleWidth",
      get: function get() {
        var w;
        var tableWidth = this.tableWidth;
        var instWidth = this.instWidth;

        if (tableWidth > instWidth) {
          w = tableWidth - instWidth;
        } else {
          w = 0;
        }

        return w;
      }
    }, {
      key: "bottomLeftY",
      get: function get() {
        return -(this.displayHeight * this.originY) + this.displayHeight;
      }
    }, {
      key: "topRightX",
      get: function get() {
        return -(this.displayWidth * this.originX) + this.displayWidth;
      }
    }, {
      key: "topLeftX",
      get: function get() {
        return -(this.displayWidth * this.originX);
      }
    }, {
      key: "topLeftY",
      get: function get() {
        return -(this.displayHeight * this.originY);
      }
    }, {
      key: "bottomBound",
      get: function get() {
        if (this.scrollMode === 0) {
          return this.bottomLeftY;
        } else {
          return this.topRightX;
        }
      }
    }, {
      key: "rightBound",
      get: function get() {
        if (this.scrollMode === 0) {
          return this.topRightX;
        } else {
          return this.bottomLeftY;
        }
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        if (this.width === width && this.height === height) {
          return this;
        }

        _get(_getPrototypeOf(GridTable.prototype), "resize", this).call(this, width, height);

        if (this.expandCellSize) {
          this.table.setDefaultCellWidth(this.instWidth / this.table.colCount);
        }

        this.updateTable(true); // Layout children-mask

        this.layoutChildrenMask(); // Re-mask children

        this.maskChildren();
        return this;
      }
    }]);

    return GridTable;
  }(ContainerLite);

  Object.assign(GridTable$1.prototype, methods$7);
  var SCROLLMODE = {
    v: 0,
    vertical: 0,
    h: 1,
    horizontal: 1
  };

  var InjectProperties$1 = function InjectProperties(table) {
    Object.defineProperty(table, 'childOY', {
      configurable: true,
      get: function get() {
        return table.tableOY;
      },
      set: function set(value) {
        table.tableOY = value;
      }
    });
    Object.defineProperty(table, 'topChildOY', {
      get: function get() {
        return table.topTableOY;
      }
    });
    Object.defineProperty(table, 'bottomChildOY', {
      get: function get() {
        return table.bottomTableOY;
      }
    });
    Object.defineProperty(table, 'childVisibleHeight', {
      get: function get() {
        return table.instHeight;
      }
    });
    Object.defineProperty(table, 'childHeight', {
      get: function get() {
        return table.tableHeight;
      }
    });
  };

  var TableOnCellVisible = function TableOnCellVisible(table) {
    table.on('cellvisible', function (cell, cellContainer, table) {
      var callback = this.createCellContainerCallback;
      var scope = this.createCellContainerCallbackScope;
      cell.item = this.items[cell.index];
      var cellContainer;

      if (scope) {
        cellContainer = callback.call(scope, cell, cellContainer, table);
      } else {
        cellContainer = callback(cell, cellContainer, table);
      }

      if (cellContainer) {
        if (cellContainer.setOrigin) {
          cellContainer.setOrigin(0);
        }

        if (cellContainer.isRexSizer) {
          cellContainer.layout(); // Use original size
        }
      }

      cell.item = undefined;
      cell.setContainer(cellContainer);
    }, this);
  };

  var EmitCellEvent = function EmitCellEvent(eventEmitter, eventName, table, x, y, pointer, event) {
    var cellIndex;

    if (y === undefined) {
      cellIndex = x;
    } else {
      cellIndex = table.pointToCellIndex(x, y);
    }

    if (cellIndex === null || cellIndex === undefined) {
      return;
    }

    var cellContainer = table.getCellContainer(cellIndex);

    if (cellContainer) {
      eventEmitter.emit(eventName, cellContainer, cellIndex, pointer, event);
    }
  };

  var PointerUpDownCell = function PointerUpDownCell(table, tableConfig) {
    table.on('pointerdown', function (pointer, localX, localY, event) {
      EmitCellEvent(this.eventEmitter, 'cell.down', table, pointer.x, pointer.y, pointer, event);
    }, this).on('pointerup', function (pointer, localX, localY, event) {
      EmitCellEvent(this.eventEmitter, 'cell.up', table, pointer.x, pointer.y, pointer, event);
    }, this);
  };

  var OverCell = function OverCell(table, tableConfig) {
    table.on('pointermove', OnMove, this).on('pointerover', OnMove, this).on('pointerout', OnOut, this); // pointer-up is included too
  };

  var OnMove = function OnMove(pointer, localX, localY, event) {
    var table = this.childrenMap.child;
    var cellIndex = table.pointToCellIndex(pointer.x, pointer.y);

    if (cellIndex === table.input.lastOverCellIndex) {
      return;
    }

    var preCellIndex = table.input.lastOverCellIndex;
    table.input.lastOverCellIndex = cellIndex;
    EmitCellEvent(this.eventEmitter, 'cell.out', table, preCellIndex, undefined, pointer, event);
    EmitCellEvent(this.eventEmitter, 'cell.over', table, cellIndex, undefined, pointer, event);
  };

  var OnOut = function OnOut(pointer, event) {
    var table = this.childrenMap.child;
    var cellIndex = table.input.lastOverCellIndex;
    table.input.lastOverCellIndex = undefined;
    EmitCellEvent(this.eventEmitter, 'cell.out', table, cellIndex, undefined, pointer, event);
  };

  var GetValue$u = Phaser.Utils.Objects.GetValue;

  var ClickCell = function ClickCell(table, tableConfig) {
    var buttonConfig = GetValue$u(tableConfig, 'click', undefined);

    if (buttonConfig === false) {
      return;
    } else if (buttonConfig === undefined) {
      buttonConfig = {};
    }

    buttonConfig.threshold = 10;
    table._click = new Button(table, buttonConfig);

    table._click.on('click', function (button, gameObject, pointer, event) {
      EmitCellEvent(this.eventEmitter, 'cell.click', gameObject, pointer.x, pointer.y, pointer, event);
    }, this);
  };

  var GetValue$t = Phaser.Utils.Objects.GetValue;

  var TapCell = function TapCell(table, tableConfig) {
    var tapConfig = GetValue$t(tableConfig, 'tap', undefined);

    if (tapConfig === false) {
      return;
    }

    table._tap = new Tap(table, tapConfig);

    table._tap.on('tap', function (tap, gameObject, lastPointer) {
      var eventName = "cell.".concat(tap.tapsCount, "tap");
      EmitCellEvent(this.eventEmitter, eventName, tap.gameObject, tap.x, tap.y, lastPointer);
    }, this);
  };

  var GetValue$s = Phaser.Utils.Objects.GetValue;

  var PressCell = function PressCell(table, tableConfig) {
    var pressConfig = GetValue$s(tableConfig, 'press', undefined);

    if (pressConfig === false) {
      return;
    }

    table._press = new Press(table, pressConfig);

    table._press.on('pressstart', function (press, gameObject, lastPointer) {
      EmitCellEvent(this.eventEmitter, 'cell.pressstart', table, press.x, press.y, lastPointer);
    }, this).on('pressend', function (press, gameObject, lastPointer) {
      EmitCellEvent(this.eventEmitter, 'cell.pressend', table, press.x, press.y, lastPointer);
    }, this);
  };

  var GetValue$r = Phaser.Utils.Objects.GetValue;

  var SwipeCell = function SwipeCell(table, tableConfig) {
    var swipeConfig = GetValue$r(tableConfig, 'swipe', undefined);

    if (swipeConfig === false) {
      return;
    } else if (swipeConfig === undefined) {
      swipeConfig = {};
    }

    swipeConfig.dir = '4dir';
    table._swipe = new Swipe(table, swipeConfig);

    table._swipe.on('swipe', function (swipe, gameObject, lastPointer) {
      var dirName = swipe.left ? 'left' : swipe.right ? 'right' : swipe.up ? 'up' : 'down';
      EmitCellEvent(this.eventEmitter, "cell.swipe".concat(dirName), table, swipe.x, swipe.y, lastPointer);
    }, this);
  };

  var TableSetInteractive = function TableSetInteractive(table, tableConfig) {
    table.setInteractive();
    PointerUpDownCell.call(this, table, tableConfig);
    OverCell.call(this, table, tableConfig);
    ClickCell.call(this, table, tableConfig);
    TapCell.call(this, table, tableConfig);
    PressCell.call(this, table, tableConfig);
    SwipeCell.call(this, table, tableConfig);
  };

  var SetItems = function SetItems(items) {
    if (items === undefined) {
      this.items.length = 0;
    } else {
      this.items = items;
    }

    var table = this.childrenMap.child;
    table.setCellsCount(this.items.length);
    table.updateTable(true);
    this.resizeController();
    return this;
  };

  var GetValue$q = Phaser.Utils.Objects.GetValue;

  var GridTable = /*#__PURE__*/function (_Scrollable) {
    _inherits(GridTable, _Scrollable);

    var _super = _createSuper(GridTable);

    function GridTable(scene, config) {
      var _this;

      _classCallCheck(this, GridTable);

      if (config === undefined) {
        config = {};
      } // Create grid table core


      var scrollMode = GetScrollMode(config);
      var tableConfig = GetValue$q(config, 'table', undefined);

      if (tableConfig === undefined) {
        tableConfig = {};
      }

      tableConfig.scrollMode = scrollMode;
      tableConfig.clamplTableOXY = GetValue$q(config, 'clamplChildOY', false);
      var tableWidth = GetValue$q(tableConfig, 'width', undefined);
      var tableHeight = GetValue$q(tableConfig, 'height', undefined);
      var table = new GridTable$1(scene, 0, 0, tableWidth, tableHeight, tableConfig);
      scene.add.existing(table); // Important: Add to display list for touch detecting

      var proportion, expand;

      if (scrollMode === 0) {
        proportion = tableWidth === undefined ? 1 : 0;
        expand = tableHeight === undefined;
      } else {
        proportion = tableHeight === undefined ? 1 : 0;
        expand = tableWidth === undefined;
      } // Inject properties for scrollable interface


      InjectProperties$1(table); // Set minWidth/minHeight to 0 if tableWidth/tableHeight is undefined

      table.minWidth = tableWidth === undefined ? 0 : undefined;
      table.minHeight = tableHeight === undefined ? 0 : undefined; // Fill config of scrollable

      config.type = 'rexGridTable';
      config.child = {
        gameObject: table,
        proportion: proportion,
        expand: expand
      };
      var spaceConfig = GetValue$q(config, 'space', undefined);

      if (spaceConfig) {
        spaceConfig.child = spaceConfig.table;
      }

      _this = _super.call(this, scene, config);

      _this.addChildrenMap('table', table);

      _this.addChildrenMap('tableLayer', table.maskLayer);

      _this.eventEmitter = GetValue$q(config, 'eventEmitter', _assertThisInitialized(_this));
      var callback = GetValue$q(config, 'createCellContainerCallback', NOOP);
      var scope = GetValue$q(config, 'createCellContainerCallbackScope', undefined);

      _this.setCreateCellContainerCallback(callback, scope);

      TableOnCellVisible.call(_assertThisInitialized(_this), table);
      _this.resizeControllerFlag = false;
      var eventName = scrollMode === 0 ? 'cellheightchange' : 'cellwidthchange';
      table.on(eventName, function () {
        this.resizeControllerFlag = true;
      }, _assertThisInitialized(_this));

      if (GetValue$q(tableConfig, 'interactive', true)) {
        TableSetInteractive.call(_assertThisInitialized(_this), table, tableConfig);
      }

      _this.setItems(GetValue$q(config, 'items', []));

      scene.game.events.on('poststep', _this.onPostStep, _assertThisInitialized(_this));
      return _this;
    }

    _createClass(GridTable, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        this.scene.game.events.off('poststep', this.onPostStep, this);

        _get(_getPrototypeOf(GridTable.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setCreateCellContainerCallback",
      value: function setCreateCellContainerCallback(callback, scope) {
        this.createCellContainerCallback = callback;
        this.createCellContainerCallbackScope = scope;
        return this;
      }
    }, {
      key: "refresh",
      value: function refresh() {
        this.setItems(this.items);
        return this;
      }
    }, {
      key: "getCell",
      value: function getCell(cellIdx) {
        var table = this.childrenMap.child;
        return table.getCell(cellIdx);
      }
    }, {
      key: "getCellContainer",
      value: function getCellContainer(cellIdx) {
        var table = this.childrenMap.child;
        return table.getCellContainer(cellIdx);
      }
    }, {
      key: "updateVisibleCell",
      value: function updateVisibleCell(cellIdx) {
        var table = this.childrenMap.child;
        return table.updateVisibleCell(cellIdx);
      }
    }, {
      key: "onPostStep",
      value: function onPostStep() {
        if (this.resizeControllerFlag) {
          this.resizeController();
          this.resizeControllerFlag = false;
        }
      }
    }]);

    return GridTable;
  }(Scrollable);

  var methods$6 = {
    setItems: SetItems
  };
  Object.assign(GridTable.prototype, methods$6);

  ObjectFactory.register('gridTable', function (config) {
    var gameObject = new GridTable(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.GridTable', GridTable);

  var ExpandSubMenu = function ExpandSubMenu(parentButton, items) {
    this.collapseSubMenu();
    var orientation;

    if (this.root.toggleOrientation) {
      orientation = this.orientation === 0 ? 1 : 0;
    } else {
      orientation = this.orientation;
    }

    var subMenu = new this.constructor(this.scene, {
      items: items,
      orientation: orientation,
      createBackgroundCallback: this.root.createBackgroundCallback,
      createBackgroundCallbackScope: this.root.createBackgroundCallbackScope,
      createButtonCallback: this.root.createButtonCallback,
      createButtonCallbackScope: this.root.createButtonCallbackScope,
      easeIn: this.root.easeIn,
      easeOut: this.root.easeOut,
      _rootMenu: this.root,
      _parentMenu: this,
      _parentButton: parentButton
    });
    this.pin(subMenu);
    this.childrenMap.subMenu = subMenu;
    this.root.emit('expand', subMenu, parentButton, this);
    return this;
  };

  var GetEaseConfig = function GetEaseConfig(easeConfig, menu) {
    if (easeConfig.sameOrientation) {
      easeConfig.orientation = menu.orientation;
    } else {
      easeConfig.orientation = menu.orientation === 0 ? 1 : 0;
    }

    return easeConfig;
  };

  var Collapse = function Collapse() {
    this.root.emit('collapse', this, this.parentButton, this.root);
    this.scaleDownDestroy(GetEaseConfig(this.root.easeOut, this));
    this.collapseSubMenu();
    return this;
  };

  var CollapseSubMenu = function CollapseSubMenu() {
    if (this.childrenMap.subMenu === undefined) {
      return this;
    }

    var subMenu = this.childrenMap.subMenu;
    this.childrenMap.subMenu = undefined;
    this.remove(subMenu);
    subMenu.collapse();
    return this;
  };

  var Methods$3 = {
    expandSubMenu: ExpandSubMenu,
    collapse: Collapse,
    collapseSubMenu: CollapseSubMenu
  };

  var CreateBackground = function CreateBackground(scene, items, callback, scope) {
    var background;

    if (callback) {
      items.scene = scene;

      if (scope) {
        background = callback.call(scope, items);
      } else {
        background = callback(items);
      }

      items.scene = undefined;
    }

    return background;
  };

  var CreateButtons = function CreateButtons(scene, items, callback, scope) {
    var item;
    var buttons = [],
        button;

    if (items && callback) {
      for (var i = 0, cnt = items.length; i < cnt; i++) {
        item = items[i];
        item.scene = scene;

        if (scope) {
          button = callback.call(scope, item, i, items);
        } else {
          button = callback(item, i, items);
        }

        item.scene = undefined;
        buttons.push(button);
      }
    }

    return buttons;
  };

  var MenuSetInteractive = function MenuSetInteractive(menu) {
    menu // Expand sub event
    .on(menu.root.expandEventName, function (button, index) {
      if (this._isPassedEvent) {
        return;
      }

      var subItems = this.items[index].children;

      if (subItems) {
        this.expandSubMenu(button, subItems);
      }
    }, menu) // Click any button
    .on('button.click', function (button, index, pointer, event) {
      // Pass event to root menu object
      if (this !== this.root) {
        this.root._isPassedEvent = true;
        this.root.emit('button.click', button, index, pointer, event);
        this.root._isPassedEvent = false;
      }
    }, menu) //Pointer over any button
    .on('button.over', function (button, index, pointer, event) {
      // Pass event to root menu object
      if (this !== this.root) {
        this.root._isPassedEvent = true;
        this.root.emit('button.over', button, index, pointer, event);
        this.root._isPassedEvent = false;
      }
    }, menu) //Pointer out any button
    .on('button.out', function (button, index, pointer, event) {
      // Pass event to root menu object
      if (this !== this.root) {
        this.root._isPassedEvent = true;
        this.root.emit('button.out', button, index, pointer, event);
        this.root._isPassedEvent = false;
      }
    }, menu);
  };

  var GetValue$p = Phaser.Utils.Objects.GetValue;

  var Menu = /*#__PURE__*/function (_Buttons) {
    _inherits(Menu, _Buttons);

    var _super = _createSuper(Menu);

    function Menu(scene, config) {
      var _this;

      _classCallCheck(this, Menu);

      if (config === undefined) {
        config = {};
      } // Orientation


      if (!config.hasOwnProperty('orientation')) {
        config.orientation = 1; // y
      } // Parent


      var rootMenu = config._rootMenu;
      var parentMenu = config._parentMenu;
      var parentButton = config._parentButton; // Items

      var items = GetValue$p(config, 'items', undefined); // Background

      var createBackgroundCallback = GetValue$p(config, 'createBackgroundCallback', undefined);
      var createBackgroundCallbackScope = GetValue$p(config, 'createBackgroundCallbackScope', undefined);
      config.background = CreateBackground(scene, items, createBackgroundCallback, createBackgroundCallbackScope); // Buttons

      var createButtonCallback = GetValue$p(config, 'createButtonCallback', undefined);
      var createButtonCallbackScope = GetValue$p(config, 'createButtonCallbackScope', undefined);
      config.buttons = CreateButtons(scene, items, createButtonCallback, createButtonCallbackScope);
      _this = _super.call(this, scene, config);
      _this.type = 'rexMenu';
      _this.items = items;
      _this.root = rootMenu === undefined ? _assertThisInitialized(_this) : rootMenu;
      _this.parentMenu = parentMenu;
      _this.parentButton = parentButton;

      var isRootMenu = _this.root === _assertThisInitialized(_this); // Root menu


      if (isRootMenu) {
        // Bounds
        var bounds = config.bounds;

        if (bounds === undefined) {
          bounds = GetViewport(scene);
        }

        _this.bounds = bounds; // Side of submenu

        _this.subMenuSide = [_this.y < bounds.centerY ? SUBMENU_DOWN : SUBMENU_UP, _this.x < bounds.centerX ? SUBMENU_RIGHT : SUBMENU_LEFT]; // Overwrite subMenuSide value if given

        var subMenuSide = GetValue$p(config, 'subMenuSide', undefined);

        if (subMenuSide !== undefined) {
          if (typeof subMenuSide === 'string') {
            subMenuSide = SubMenuSideMode[subMenuSide];
          }

          _this.subMenuSide[_this.orientation] = subMenuSide;
        } // ToggleOrientation mode


        _this.toggleOrientation = GetValue$p(config, 'toggleOrientation', false); // Expand mode

        _this.expandEventName = GetValue$p(config, 'expandEvent', 'button.click'); // Transition

        _this.easeIn = ParseEaseConfig(_assertThisInitialized(_this), GetValue$p(config, 'easeIn', 0));
        _this.easeOut = ParseEaseConfig(_assertThisInitialized(_this), GetValue$p(config, 'easeOut', 0)); // Callbacks

        _this.createBackgroundCallback = createBackgroundCallback;
        _this.createBackgroundCallbackScope = createBackgroundCallbackScope;
        _this.createButtonCallback = createButtonCallback;
        _this.createButtonCallbackScope = createButtonCallbackScope; // Event flag

        _this._isPassedEvent = false;
      }

      var originX = 0,
          originY = 0;

      if (!_this.root.easeIn.sameOrientation) {
        var easeOrientation = GetEaseConfig(_this.root.easeIn, _assertThisInitialized(_this)).orientation;
        var menuOrientation = parentMenu ? parentMenu.orientation : _this.orientation;
        var subMenuSide = _this.root.subMenuSide[menuOrientation];

        if (easeOrientation === 0 && subMenuSide === SUBMENU_LEFT) {
          originX = 1;
        }

        if (easeOrientation === 1 && subMenuSide === SUBMENU_UP) {
          originY = 1;
        }
      }

      _this.setOrigin(originX, originY).layout(); // Sub-menu: 
      // - scale to root's scale value
      // - align to parent button


      if (!isRootMenu) {
        _this.setScale(_this.root.scaleX, _this.root.scaleY);

        var subMenuSide = _this.root.subMenuSide[parentMenu.orientation];

        switch (subMenuSide) {
          case SUBMENU_LEFT:
            //Put submene at left side
            _this.alignTop(parentButton.top).alignRight(parentButton.left);

            break;

          case SUBMENU_RIGHT:
            //Put submene at right side
            _this.alignTop(parentButton.top).alignLeft(parentButton.right);

            break;

          case SUBMENU_UP:
            //Put submene at up side
            _this.alignLeft(parentButton.left).alignBottom(parentButton.top);

            break;

          case SUBMENU_DOWN:
            //Put submene at down side
            _this.alignLeft(parentButton.left).alignTop(parentButton.bottom);

            break;
        }
      }

      _this.pushIntoBounds(_this.root.bounds);

      MenuSetInteractive(_assertThisInitialized(_this)); // Ease in menu

      _this.popUp(GetEaseConfig(_this.root.easeIn, _assertThisInitialized(_this)));

      _this.once('popup.complete', function () {
        // Pass event to root menu object
        if (this !== this.root) {
          this.root.emit('popup.complete', this);
        }
      }, _assertThisInitialized(_this));

      return _this;
    }

    _createClass(Menu, [{
      key: "isInTouching",
      value: function isInTouching(pointer) {
        if (_get(_getPrototypeOf(Menu.prototype), "isInTouching", this).call(this, pointer)) {
          return true;
        } else if (this.childrenMap.subMenu) {
          return this.childrenMap.subMenu.isInTouching(pointer);
        } else {
          return false;
        }
      }
    }]);

    return Menu;
  }(Buttons$1);

  var ParseEaseConfig = function ParseEaseConfig(menu, easeConfig) {
    if (typeof easeConfig === 'number') {
      easeConfig = {
        duration: easeConfig
      };
    }

    if (easeConfig.hasOwnProperty('orientation') && easeConfig.orientation !== undefined) {
      easeConfig.sameOrientation = GetOrientationMode(easeConfig.orientation) === menu.orientation;
    } else {
      easeConfig.sameOrientation = true;
    }

    return easeConfig;
  };

  var SUBMENU_LEFT = 2;
  var SUBMENU_RIGHT = 0;
  var SUBMENU_UP = 3;
  var SUBMENU_DOWN = 1;
  var SubMenuSideMode = {
    up: SUBMENU_UP,
    down: SUBMENU_DOWN,
    left: SUBMENU_LEFT,
    right: SUBMENU_RIGHT
  };
  Object.assign(Menu.prototype, Methods$3);

  ObjectFactory.register('menu', function (config) {
    var gameObject = new Menu(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Menu', Menu);

  var methods$5 = {
    setWrapEnable: function setWrapEnable(enable) {
      if (enable === undefined) {
        enable = true;
      }

      this.listWrapEnable = enable;
      return this;
    },
    setCreateButtonCallback: function setCreateButtonCallback(callback) {
      this.listCreateButtonCallback = callback;
      return this;
    },
    setCreateBackgroundCallback: function setCreateBackgroundCallback(callback) {
      this.listCreateBackgroundCallback = callback;
      return this;
    },
    setButtonClickCallback: function setButtonClickCallback(callback) {
      this.listOnButtonClick = callback;
      return this;
    },
    setButtonOverCallback: function setButtonOverCallback(callback) {
      this.listOnButtonOver = callback;
      return this;
    },
    setButtonOutCallback: function setButtonOutCallback(callback) {
      this.listOnButtonOut = callback;
      return this;
    },
    setListEaseOutDuration: function setListEaseOutDuration(duration) {
      if (duration === undefined) {
        duration = 0;
      }

      this.listEaseOutDuration = duration;
      return this;
    },
    setListBounds: function setListBounds(bounds) {
      this.listBounds = bounds;
      return this;
    },
    setListWidth: function setListWidth(width) {
      this.listWidth = width;
      return this;
    },
    setListHeight: function setListHeight(height) {
      this.listHeight = height;
      return this;
    },
    setListSize: function setListSize(width, height) {
      this.setListWidth(width).setListHeight(height);
      return this;
    },
    setListAlignmentMode: function setListAlignmentMode(mode) {
      this.listAlignMode = mode;
      return this;
    },
    setListEaseInDuration: function setListEaseInDuration(duration) {
      if (duration === undefined) {
        duration = 0;
      }

      this.listEaseInDuration = duration;
      return this;
    },
    setListSpace: function setListSpace(space) {
      if (space === undefined) {
        space = {};
      }

      this.listSpace = space;
      return this;
    },
    setListDraggable: function setListDraggable(enable) {
      if (enable === undefined) {
        enable = true;
      }

      this.listDraggable = enable;
      return this;
    }
  };

  var CreateListPanel = function CreateListPanel(scene) {
    var background;
    var createBackgroundCallback = this.listCreateBackgroundCallback;

    if (createBackgroundCallback) {
      background = createBackgroundCallback.call(this, scene);
      scene.add.existing(background);
    }

    var buttons = [];
    var createButtonCallback = this.listCreateButtonCallback;

    if (createButtonCallback) {
      var options = this.options;

      for (var i = 0, cnt = options.length; i < cnt; i++) {
        var button = createButtonCallback.call(this, scene, options[i], i, options);
        scene.add.existing(button);
        buttons.push(button);
      }
    }

    var width = this.listWidth;

    if (width === undefined) {
      if (this.listAlignMode === 'text') {
        width = this.getElement('text').width;
      } else {
        width = this.width;
      }
    }

    var height = this.listHeight;
    var listPanel;

    if (!this.listWrapEnable) {
      listPanel = new Buttons$1(scene, {
        width: width,
        height: height,
        orientation: 'y',
        background: background,
        buttons: buttons,
        space: this.listSpace,
        draggable: this.listDraggable
      });
    } else {
      listPanel = new Buttons(scene, {
        width: width,
        height: height,
        background: background,
        buttons: buttons,
        space: this.listSpace,
        draggable: this.listDraggable
      });
    }

    scene.add.existing(listPanel);
    return listPanel;
  };

  var OpenListPanel = function OpenListPanel() {
    if (this.listPanel) {
      return this;
    }

    var scene = this.scene;
    var listPanel = CreateListPanel.call(this, scene).setOrigin(0, 0).layout();
    var x = this.getElement(this.listAlignMode).getTopLeft().x;
    listPanel.setPosition(x, this.bottom);
    var bounds = this.listBounds;

    if (!bounds) {
      bounds = GetViewport(scene);
    }

    if (listPanel.bottom > bounds.bottom) {
      // Out of bounds, can't put list-panel below parent
      listPanel.changeOrigin(0, 1).setPosition(x, this.top);
    }

    var onButtonOver = this.listOnButtonOver;

    if (onButtonOver) {
      listPanel.on('button.over', onButtonOver, this);
    }

    var onButtonOut = this.listOnButtonOut;

    if (onButtonOut) {
      listPanel.on('button.out', onButtonOut, this);
    }

    listPanel.popUp(this.listEaseInDuration, 'y', 'Cubic').once('popup.complete', function (listPanel) {
      // After popping up
      // Can click
      var onButtonClick = this.listOnButtonClick;

      if (onButtonClick) {
        listPanel.on('button.click', function (button, index, pointer, event) {
          onButtonClick.call(this, button, index, pointer, event);
          this.emit('list.click', this, listPanel, button, index, pointer, event);
        }, this);
      } // Can close list panel


      scene.input.once('pointerup', this.closeListPanel, this);
      this.emit('list.open', this, listPanel);
    }, this);
    this.pin(listPanel);
    this.listPanel = listPanel;
    return this;
  };

  var CloseListPanel = function CloseListPanel() {
    if (!this.listPanel) {
      return this;
    }

    var listPanel = this.listPanel;
    this.listPanel = undefined;
    listPanel.scaleDownDestroy(this.listEaseOutDuration, 'y', 'Linear').once('scaledown.complete', function () {
      this.emit('list.close', this, listPanel);
    }, this);
    return this;
  };

  var ToggleListPanel = function ToggleListPanel() {
    if (!this.listPanel) {
      this.openListPanel();
    } else {
      this.closeListPanel();
    }

    return this;
  };

  var Methods$2 = {
    openListPanel: OpenListPanel,
    closeListPanel: CloseListPanel,
    toggleListPanel: ToggleListPanel
  };
  Object.assign(Methods$2, methods$5);

  var GetValue$o = Phaser.Utils.Objects.GetValue;

  var DropDownList = /*#__PURE__*/function (_Label) {
    _inherits(DropDownList, _Label);

    var _super = _createSuper(DropDownList);

    function DropDownList(scene, config) {
      var _this;

      _classCallCheck(this, DropDownList);

      _this = _super.call(this, scene, config);
      _this.type = 'rexDropDownList';

      _this.setOptions(GetValue$o(config, 'options'));

      var listConfig = GetValue$o(config, 'list');

      _this.setWrapEnable(GetValue$o(listConfig, 'wrap', false));

      _this.setCreateButtonCallback(GetValue$o(listConfig, 'createButtonCallback'));

      _this.setCreateBackgroundCallback(GetValue$o(listConfig, 'createBackgroundCallback'));

      _this.setButtonClickCallback(GetValue$o(listConfig, 'onButtonClick'));

      _this.setButtonOverCallback(GetValue$o(listConfig, 'onButtonOver'));

      _this.setButtonOutCallback(GetValue$o(listConfig, 'onButtonOut'));

      _this.setListEaseInDuration(GetValue$o(listConfig, 'easeIn', 500));

      _this.setListEaseOutDuration(GetValue$o(listConfig, 'easeOut', 100));

      _this.setListSize(GetValue$o(listConfig, 'width'), GetValue$o(listConfig, 'height'));

      _this.setListAlignmentMode(GetValue$o(listConfig, 'alignParent', 'text'));

      _this.setListBounds(GetValue$o(listConfig, 'bounds'));

      _this.setListSpace(GetValue$o(listConfig, 'space'));

      _this.setListDraggable(GetValue$o(listConfig, 'draggable', false));

      _this.setValueChangeCallback(GetValue$o(config, 'setValueCallback'), GetValue$o(config, 'setValueCallbackScope'));

      _this.setValue(GetValue$o(config, 'value'));

      _this.onClick(_this.toggleListPanel, _assertThisInitialized(_this));

      return _this;
    }

    _createClass(DropDownList, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        if (this.listPanel) {
          this.listPanel.destroy(fromScene);
          this.listPanel = undefined;
        }

        _get(_getPrototypeOf(DropDownList.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        if (options === undefined) {
          options = [];
        }

        this.options = options;
        return this;
      }
    }, {
      key: "setValueChangeCallback",
      value: function setValueChangeCallback(callback, scope) {
        this.valueChangeCallback = callback;
        this.valueChangeCallbackScope = scope;
        return this;
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        return this._value;
      },
      set: function set(value) {
        if (this._value === value) {
          return;
        }

        var previousValue = this._value;
        this._value = value;
        var callback = this.valueChangeCallback,
            scope = this.valueChangeCallbackScope;

        if (callback) {
          if (scope) {
            callback.call(scope, this, value, previousValue);
          } else {
            callback(this, value, previousValue);
          }
        }
      }
    }]);

    return DropDownList;
  }(Label);

  Object.assign(DropDownList.prototype, Methods$2);

  ObjectFactory.register('dropDownList', function (config) {
    var gameObject = new DropDownList(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.DropDownList', DropDownList);

  var TextKlass = Phaser.GameObjects.Text;

  var IsTextGameObject = function IsTextGameObject(gameObject) {
    return gameObject instanceof TextKlass;
  };

  var BitmapTextKlass = Phaser.GameObjects.BitmapText;

  var IsBitmapTextGameObject = function IsBitmapTextGameObject(gameObject) {
    return gameObject instanceof BitmapTextKlass;
  };

  var TextType = 0;
  var TagTextType = 1;
  var BitmapTextType = 2;

  var GetTextObjectType = function GetTextObjectType(textObject) {
    var textObjectType;

    if (IsBitmapTextGameObject(textObject)) {
      textObjectType = BitmapTextType;
    } else if (IsTextGameObject(textObject)) {
      textObjectType = TextType;
    } else {
      textObjectType = TagTextType;
    }

    return textObjectType;
  };

  var TextToLines = function TextToLines(textObject, text, lines) {
    var textObjectType = GetTextObjectType(textObject);

    switch (textObjectType) {
      case TextType:
        lines = textObject.getWrappedText(text); // Array of string

        break;

      case TagTextType:
        lines = textObject.getPenManager(text, lines); // Pens-manager

        break;

      case BitmapTextType:
        if (textObject.maxWidth > 0) {
          lines = textObject.setText(text).getTextBounds().wrappedText.split('\n');
        } else {
          lines = text.split('\n');
        }

        break;
    }

    return lines;
  };

  var GetLines$1 = function GetLines(startLineIndex, endLineIdx) {
    if (startLineIndex === undefined) {
      startLineIndex = this.startLineIndex;
    }

    if (endLineIdx === undefined) {
      endLineIdx = startLineIndex + this.pageLinesCount;
    }

    var text;

    switch (this.textObjectType) {
      case TextType:
      case BitmapTextType:
        text = this.lines.slice(startLineIndex, endLineIdx).join('\n');
        break;

      case TagTextType:
        var startIdx = this.lines.getLineStartIndex(startLineIndex);
        var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
        text = this.lines.getSliceTagText(startIdx, endIdx, true);
        break;
    }

    return text;
  };

  var GetString = function GetString(text) {
    if (Array.isArray(text)) {
      text = text.join('\n');
    } else if (typeof text === 'number') {
      text = text.toString();
    }

    return text;
  };

  var SetContentMethods = {
    clearText: function clearText() {
      this.sections.length = 0;
      this.pageStartIndexes.length = 0;
      this.lines.length = 0;
      return this;
    },
    appendPage: function appendPage(text) {
      var pageStartIndex = this.totalLinesCount;
      this.sections.push(GetString(text));
      var text = this.sections.join('\n');
      this.lines = TextToLines(this.parent, text, this.lines);
      var newLinesCount = this.totalLinesCount - pageStartIndex;
      var pageCount = Math.ceil(newLinesCount / this.pageLinesCount);

      for (var i = 0; i < pageCount; i++) {
        this.pageStartIndexes.push(pageStartIndex + i * this.pageLinesCount);
      }

      return this;
    },
    setText: function setText(text, resetPageIdx) {
      if (resetPageIdx === undefined) {
        resetPageIdx = true;
      }

      if (resetPageIdx) {
        this.resetPageIdx();
      }

      this.clearText();
      var sections = GetString(text).split(this.pageBreak); // if (sections[sections.length - 1] === '') { // Last section is an empty string
      //     sections.length -= 1;
      // }

      for (var i = 0, cnt = sections.length; i < cnt; i++) {
        this.appendPage(sections[i]);
      }

      return this;
    },
    appendText: function appendText(text) {
      var content = this.content + GetString(text);
      this.setText(content, false);
      return this;
    }
  };

  var Clamp$1 = Phaser.Math.Clamp;
  var GetPageMethods = {
    getPage: function getPage(idx) {
      if (idx === undefined) {
        idx = this.pageIndex;
      }

      return this.setPageIndex(idx).getLines(this.startLineIndex, this.endLineIndex);
    },
    getNextPage: function getNextPage() {
      return this.getPage(this.pageIndex + 1);
    },
    getPreviousPage: function getPreviousPage() {
      return this.getPage(this.pageIndex - 1);
    },
    resetPageIdx: function resetPageIdx() {
      this.pageIndex = -1;
      return this;
    },
    setPageIndex: function setPageIndex(idx) {
      idx = Clamp$1(idx, 0, this.pageCount - 1);
      this.pageIndex = idx;
      this.startLineIndex = this.pageStartIndexes[idx];
      this.endLineIndex = this.pageStartIndexes[idx + 1];
      return this;
    }
  };

  var SetNoWrapText = function SetNoWrapText(textObject, text) {
    var textObjectType = GetTextObjectType(textObject);

    switch (textObjectType) {
      case TextType:
        // Store wrap properties
        var style = textObject.style;
        var wordWrapWidth = style.wordWrapWidth;
        var wordWrapCallback = style.wordWrapCallback; // Disable wrap

        style.wordWrapWidth = 0;
        style.wordWrapCallback = undefined; // Set text

        textObject.setText(text); // Restore wrap

        style.wordWrapWidth = wordWrapWidth;
        style.wordWrapCallback = wordWrapCallback;
        break;

      case TagTextType:
        // Store wrap properties
        var style = textObject.style;
        var wrapMode = style.wrapMode; // Disable wrap

        style.wrapMode = 0; // Set text

        textObject.setText(text); // Restore wrap

        style.wrapMode = wrapMode;
        break;

      case BitmapTextType:
        // Store wrap properties
        var maxWidth = textObject._maxWidth; // Disable wrap

        textObject._maxWidth = 0; // Set text

        textObject.setText(text); // Restore wrap

        textObject._maxWidth = maxWidth;
        break;
    }
  };

  var ShowMethods = {
    showPage: function showPage(idx) {
      this.displayText(this.getPage(idx));
      return this;
    },
    showNextPage: function showNextPage() {
      this.displayText(this.getNextPage());
      return this;
    },
    showPreviousPage: function showPreviousPage() {
      this.displayText(this.getPreviousPage());
      return this;
    },
    show: function show() {
      this.displayText(this.getLines());
      return this;
    },
    showNextLine: function showNextLine() {
      this.displayText(this.setStartLineIndex(this.startLineIndex + 1).getLines());
      return this;
    },
    showPreviousLine: function showPreviousLine() {
      this.displayText(this.setStartLineIndex(this.startLineIndex - 1).getLines());
      return this;
    },
    displayText: function displayText(text) {
      SetNoWrapText(this.parent, text);
    }
  };

  var Methods$1 = {
    getLines: GetLines$1
  };
  Object.assign(Methods$1, SetContentMethods, GetPageMethods, ShowMethods);

  var GetValue$n = Phaser.Utils.Objects.GetValue;
  var Clamp = Phaser.Math.Clamp;

  var TextPage = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TextPage, _ComponentBase);

    var _super = _createSuper(TextPage);

    function TextPage(gameObject, config) {
      var _this;

      _classCallCheck(this, TextPage);

      _this = _super.call(this, gameObject, {
        eventEmitter: false
      }); // No event emitter
      // this.parent = gameObject;

      _this.textObjectType = GetTextObjectType(_this.parent);
      _this.pageStartIndexes = []; // Text object : array of string
      // Tag text object : pens-manager
      // Bitmap text object : array of string

      _this.lines = TextToLines(_this.parent, '');
      _this.sections = [];

      _this.resetFromJSON(config);

      return _this;
    }

    _createClass(TextPage, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setMaxLines(GetValue$n(o, 'maxLines', undefined));
        this.setPageBreak(GetValue$n(o, 'pageBreak', '\f\n'));
        this.setText(GetValue$n(o, 'text', ''));
        this.setStartLineIndex(GetValue$n(o, 'start', 0));
        this.setPageIndex(GetValue$n(o, 'page', -1));
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          maxLines: this.maxLines,
          text: this.content,
          start: this.startLineIndex,
          page: this.pageIndex,
          pageBreak: this.pageBreak
        };
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        switch (this.textObjectType) {
          case TextType:
            this.lines.length = 0;
            break;

          case TagTextType:
            this.lines.destroy();
            break;

          case BitmapTextType:
            this.lines.length = 0;
            break;
        }

        this.pageStartIndexes.length = 0;
        this.sections.length = 0;
        this.lines = undefined;
        this.pageStartIndexes = undefined;
        this.sections = undefined;

        _get(_getPrototypeOf(TextPage.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "setMaxLines",
      value: function setMaxLines(maxLines) {
        this.maxLines = maxLines;
        return this;
      }
    }, {
      key: "setPageBreak",
      value: function setPageBreak(pageBreak) {
        this.pageBreak = pageBreak;
        return this;
      }
    }, {
      key: "pageCount",
      get: function get() {
        return this.pageStartIndexes.length;
      }
    }, {
      key: "isFirstPage",
      get: function get() {
        return this.pageIndex <= 0;
      }
    }, {
      key: "isLastPage",
      get: function get() {
        return this.pageIndex >= this.pageCount - 1;
      }
    }, {
      key: "totalLinesCount",
      get: function get() {
        return this.lines ? this.lines.length : 0;
      }
    }, {
      key: "startLineIndex",
      get: function get() {
        return this._startLineIndex;
      },
      set: function set(value) {
        value = Clamp(value, 0, this.totalLinesCount - 1);
        this._startLineIndex = value;
      }
    }, {
      key: "setStartLineIndex",
      value: function setStartLineIndex(idx) {
        this.startLineIndex = idx;
        return this;
      }
    }, {
      key: "pageLinesCount",
      get: function get() {
        if (this.maxLines !== undefined) {
          return this.maxLines;
        } else {
          var count;

          switch (this.textObjectType) {
            case TextType:
            case TagTextType:
              var maxLines = this.parent.style.maxLines;

              if (maxLines > 0) {
                count = maxLines;
              } else {
                count = this.totalLinesCount;
              }

              break;

            case BitmapTextType:
              count = this.totalLinesCount;
              break;
          }

          return count;
        }
      }
    }, {
      key: "content",
      get: function get() {
        return this.sections.join(this.pageBreak);
      }
    }]);

    return TextPage;
  }(ComponentBase);

  Object.assign(TextPage.prototype, Methods$1);

  var GetWrapText = function GetWrapText(textObject, text) {
    var textObjectType = GetTextObjectType(textObject);

    switch (textObjectType) {
      case TextType:
        textObject.style.syncFont(textObject.canvas, textObject.context);
        text = textObject.runWordWrap(text);
        break;

      case TagTextType:
        text = textObject.getText(text, undefined, undefined, true);
        break;

      case BitmapTextType:
        text = textObject.setText(text).getTextBounds().wrappedText;
        break;
    }

    return text;
  };

  var GetFastValue = Phaser.Utils.Objects.GetFastValue;
  var GetValue$m = Phaser.Utils.Objects.GetValue;

  var TextTyping = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TextTyping, _ComponentBase);

    var _super = _createSuper(TextTyping);

    function TextTyping(gameObject, config) {
      var _this;

      _classCallCheck(this, TextTyping);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;

      _this.timer = null;

      _this.resetFromJSON(config);

      return _this;
    }

    _createClass(TextTyping, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.setTextWrapEnable(GetValue$m(o, 'wrap', false));
        this.setTypeMode(GetValue$m(o, 'typeMode', 0));
        this.setTypeSpeed(GetValue$m(o, 'speed', 333));
        this.setTextCallback = GetFastValue(o, 'setTextCallback', null);
        this.setTextCallbackScope = GetFastValue(o, 'setTextCallbackScope', null);
        this.setTypingContent(GetFastValue(o, 'text', ''));
        this.typingIdx = GetFastValue(o, 'typingIdx', 0);
        this.insertIdx = GetFastValue(o, 'insertIdx', null);
        var elapsed = GetFastValue(o, 'elapsed', null);

        if (elapsed !== null) {
          this.start(undefined, undefined, this.typingIdx, elapsed);
        }

        return this;
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        this.freeTimer();

        _get(_getPrototypeOf(TextTyping.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "setTypeMode",
      value: function setTypeMode(m) {
        if (typeof m === 'string') {
          m = TYPEMODE[m];
        }

        this.typeMode = m;
        return this;
      }
    }, {
      key: "setTypeSpeed",
      value: function setTypeSpeed(speed) {
        this.speed = speed;
        return this;
      }
    }, {
      key: "setTextWrapEnable",
      value: function setTextWrapEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }

        this.textWrapEnable = enable;
        return this;
      }
    }, {
      key: "text",
      get: function get() {
        return this._text;
      },
      set: function set(value) {
        var text = TransferText(value);

        if (this.textWrapEnable) {
          text = GetWrapText(this.parent, text);
        }

        this._text = text;
      }
    }, {
      key: "isTyping",
      get: function get() {
        return this.getTimer() !== null;
      }
    }, {
      key: "isLastChar",
      get: function get() {
        return this.typingIdx === this.textLen;
      }
    }, {
      key: "start",
      value: function start(text, speed, startIdx, timerStartAt) {
        if (text !== undefined) {
          this.setTypingContent(text);
        }

        if (speed !== undefined) {
          this.speed = speed;
        }

        if (startIdx === undefined) {
          startIdx = 0;
        }

        this.typingIdx = startIdx + 1;

        if (this.speed === 0) {
          this.stop(true);
        } else {
          this.setText('');
          this.startTimer(timerStartAt);
        }

        return this;
      }
    }, {
      key: "appendText",
      value: function appendText(text) {
        var newText = this.text.concat(TransferText(text));

        if (this.isTyping) {
          this.setTypingContent(newText);
        } else {
          this.start(newText, undefined, this.textLen);
        }

        return this;
      }
    }, {
      key: "stop",
      value: function stop(showAllText) {
        var timer = this.getTimer();

        if (timer) {
          this.freeTimer();
        }

        if (showAllText) {
          this.typingIdx = this.textLen;
          this.setText(this.text);
          this.emit('type');
          this.emit('complete', this, this.parent);
        }

        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        var timer = this.getTimer();

        if (timer) {
          timer.paused = true;
        }

        return this;
      }
    }, {
      key: "resume",
      value: function resume() {
        var timer = this.getTimer();

        if (timer) {
          timer.paused = false;
        }

        return this;
      }
    }, {
      key: "setTypingContent",
      value: function setTypingContent(text) {
        this.text = text;
        this.textLen = this.getTextLength(this.text);
        return this;
      }
    }, {
      key: "onTyping",
      value: function onTyping() {
        var newText = this.getTypingString(this.text, this.typingIdx, this.textLen, this.typeMode);
        this.setText(newText);
        this.emit('type');

        if (this.isLastChar) {
          this.freeTimer();
          this.emit('complete', this, this.parent);
        } else {
          this.timer.delay = this.speed; // delay of next typing            

          this.typingIdx++;
        }
      }
    }, {
      key: "getTypingString",
      value: function getTypingString(text, typeIdx, textLen, typeMode) {
        var result;

        if (typeMode === 0) {
          //left-to-right
          var startIdx = 0;
          var endIdx = typeIdx;
          this.insertIdx = endIdx;
          result = this.getSubString(text, startIdx, endIdx);
        } else if (typeMode === 1) {
          //right-to-left
          var endIdx = textLen;
          var startIdx = endIdx - typeIdx;
          this.insertIdx = 0;
          result = this.getSubString(text, startIdx, endIdx);
        } else if (typeMode === 2) {
          //middle-to-sides
          var midIdx = textLen / 2;
          var startIdx = Math.floor(midIdx - typeIdx / 2);
          var endIdx = startIdx + typeIdx;
          this.insertIdx = typeIdx % 2 ? typeIdx : 0;
          result = this.getSubString(text, startIdx, endIdx);
        } else if (typeMode === 3) {
          //sides-to-middle
          var lowerLen = Math.floor(typeIdx / 2);
          var lowerResult;

          if (lowerLen > 0) {
            var endIdx = textLen;
            var startIdx = endIdx - lowerLen;
            lowerResult = this.getSubString(text, startIdx, endIdx);
          } else {
            lowerResult = "";
          }

          var upperLen = typeIdx - lowerLen;
          var upperResult;

          if (upperLen > 0) {
            var startIdx = 0;
            var endIdx = startIdx + upperLen;
            this.insertIdx = endIdx;
            upperResult = this.getSubString(text, startIdx, endIdx);
          } else {
            upperResult = "";
            this.insertIdx = 0;
          }

          result = upperResult + lowerResult;
        }

        return result;
      }
    }, {
      key: "startTimer",
      value: function startTimer(timerStartAt) {
        if (this.timer) {
          this.freeTimer();
        }

        var startAt;

        if (timerStartAt === undefined) {
          startAt = 0;
        } else {
          startAt = timerStartAt;
        }

        this.timer = this.scene.time.addEvent({
          delay: 0,
          startAt: startAt,
          loop: true,
          callback: this.onTyping,
          callbackScope: this
        });
        return this;
      }
    }, {
      key: "getTimer",
      value: function getTimer() {
        return this.timer;
      }
    }, {
      key: "freeTimer",
      value: function freeTimer() {
        if (this.timer) {
          this.timer.remove();
          this.timer = null;
        }

        return this;
      }
    }, {
      key: "setText",
      value: function setText(text) {
        if (this.setTextCallback) {
          if (this.setTextCallbackScope) {
            text = this.setTextCallback.call(this.setTextCallbackScope, text, this.isLastChar, this.insertIdx);
          } else {
            text = this.setTextCallback(text, this.isLastChar, this.insertIdx);
          }
        }

        if (this.textWrapEnable) {
          SetNoWrapText(this.parent, text);
        } else {
          this.parent.setText(text);
        }
      }
    }, {
      key: "getTextLength",
      value: function getTextLength(text) {
        var gameObject = this.parent;
        var len;

        if (gameObject.getPlainText) {
          len = gameObject.getPlainText(text).length;
        } else {
          len = text.length;
        }

        return len;
      }
    }, {
      key: "getSubString",
      value: function getSubString(text, startIdx, endIdx) {
        var gameObject = this.parent;
        var result;

        if (gameObject.getSubString) {
          result = gameObject.getSubString(text, startIdx, endIdx);
        } else {
          result = text.slice(startIdx, endIdx);
        }

        return result;
      }
    }]);

    return TextTyping;
  }(ComponentBase);

  var TransferText = function TransferText(text) {
    if (Array.isArray(text)) {
      text = text.join('\n');
    } else if (typeof text === 'number') {
      text = text.toString();
    }

    return text;
  };

  var TYPEMODE = {
    'left-to-right': 0,
    'right-to-left': 1,
    'middle-to-sides': 2,
    'sides-to-middle': 3
  };

  var GetValue$l = Phaser.Utils.Objects.GetValue;

  var TextBox = /*#__PURE__*/function (_Label) {
    _inherits(TextBox, _Label);

    var _super = _createSuper(TextBox);

    function TextBox(scene, config) {
      var _this;

      _classCallCheck(this, TextBox);

      if (config === undefined) {
        config = {
          text: createDefaultTextObject$1(scene)
        };
      }

      _this = _super.call(this, scene, config);
      _this.type = 'rexTextBox';
      var text = _this.childrenMap.text;
      _this.page = new TextPage(text, GetValue$l(config, 'page', undefined));
      _this.typing = new TextTyping(text, GetValue$l(config, 'type', undefined));

      _this.typing.on('complete', _this.onPageEnd, _assertThisInitialized(_this)).on('type', _this.onType, _assertThisInitialized(_this));

      _this.textWidth = text.width;
      _this.textHeight = text.height;
      return _this;
    }

    _createClass(TextBox, [{
      key: "start",
      value: function start(text, speed) {
        this.page.setText(text);

        if (speed !== undefined) {
          this.setTypeSpeed(speed);
        }

        this.typeNextPage();
        return this;
      }
    }, {
      key: "typeNextPage",
      value: function typeNextPage() {
        if (!this.isLastPage) {
          var txt = this.page.getNextPage();
          this.typing.start(txt);
        } else {
          this.emit('complete');
        }

        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        this.typing.pause();
        return this;
      }
    }, {
      key: "resume",
      value: function resume() {
        this.typing.resume();
        return this;
      }
    }, {
      key: "stop",
      value: function stop(showAllText) {
        this.typing.stop(showAllText);
        return this;
      }
    }, {
      key: "setTypeSpeed",
      value: function setTypeSpeed(speed) {
        this.typing.setTypeSpeed(speed);
        return this;
      }
    }, {
      key: "isTyping",
      get: function get() {
        return this.typing.isTyping;
      }
    }, {
      key: "isLastPage",
      get: function get() {
        return this.page.isLastPage;
      }
    }, {
      key: "isFirstPage",
      get: function get() {
        return this.page.isFirstPage;
      }
    }, {
      key: "pageCount",
      get: function get() {
        return this.page.pageCount;
      }
    }, {
      key: "pageIndex",
      get: function get() {
        return this.page.pageIndex;
      }
    }, {
      key: "onType",
      value: function onType() {
        var text = this.childrenMap.text;

        if (this.textWidth !== text.width || this.textHeight !== text.height) {
          this.textWidth = text.width;
          this.textHeight = text.height;
          this.getTopmostSizer().layout();
        }

        this.emit('type');
      }
    }, {
      key: "onPageEnd",
      value: function onPageEnd() {
        this.emit('pageend');

        if (this.isLastPage) {
          this.emit('complete');
        }
      }
    }]);

    return TextBox;
  }(Label);

  var createDefaultTextObject$1 = function createDefaultTextObject(scene) {
    return scene.add.text(0, 0, '', {
      wordWrap: {
        width: 200
      },
      maxLines: 5
    });
  };

  ObjectFactory.register('textBox', function (config) {
    var gameObject = new TextBox(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.TextBox', TextBox);

  var GetValue$k = Phaser.Utils.Objects.GetValue;

  var NumberBar = /*#__PURE__*/function (_Sizer) {
    _inherits(NumberBar, _Sizer);

    var _super = _createSuper(NumberBar);

    function NumberBar(scene, config) {
      var _this;

      _classCallCheck(this, NumberBar);

      // Create sizer
      _this = _super.call(this, scene, config);
      _this.type = 'rexNumberBar'; // Add elements

      var background = GetValue$k(config, 'background', undefined);
      var icon = GetValue$k(config, 'icon', undefined);
      var iconMask = GetValue$k(config, 'iconMask', undefined);
      var sliderConfig = GetValue$k(config, 'slider', undefined);
      var text = GetValue$k(config, 'text', undefined); // Space

      var iconSpace = GetValue$k(config, 'space.icon', 0);
      var sliderSpace = GetValue$k(config, 'space.slider', 0);

      if (background) {
        _this.addBackground(background);
      }

      if (icon) {
        var padding;

        if (_this.orientation === 0) {
          if (sliderConfig || text) {
            padding = {
              right: iconSpace
            };
          }
        } else {
          if (sliderConfig || text) {
            padding = {
              bottom: iconSpace
            };
          }
        }

        _this.add(icon, {
          proportion: 0,
          align: 'center',
          padding: padding
        });

        if (iconMask) {
          iconMask = AddChildMask.call(_assertThisInitialized(_this), icon, icon, 1); // Circle mask
        }
      }

      var slider;

      if (sliderConfig) {
        sliderConfig.orientation = _this.orientation;
        sliderConfig.eventEmitter = _assertThisInitialized(_this);
        sliderConfig.value = null;

        if (!sliderConfig.hasOwnProperty('input')) {
          sliderConfig.input = -1;
        }

        slider = new Slider$1(scene, sliderConfig);
        scene.add.existing(slider);
        var padding;

        if (_this.orientation === 0) {
          if (text) {
            padding = {
              right: sliderSpace
            };
          }
        } else {
          if (text) {
            padding = {
              bottom: sliderSpace
            };
          }
        }

        var proportion;

        if (_this.orientation === 0) {
          var sliderWidth = GetValue$k(sliderConfig, 'width', undefined);
          proportion = sliderWidth === undefined ? 1 : 0;
        } else {
          var sliderHeight = GetValue$k(sliderConfig, 'height', undefined);
          proportion = sliderHeight === undefined ? 1 : 0;
        }

        _this.add(slider, {
          proportion: proportion,
          align: 'center',
          padding: padding
        });
      }

      if (text) {
        _this.add(text);
      }

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('icon', icon);

      _this.addChildrenMap('iconMask', iconMask);

      _this.addChildrenMap('slider', slider);

      _this.addChildrenMap('text', text);

      var callback = GetValue$k(config, 'valuechangeCallback', null);

      if (callback !== null) {
        var scope = GetValue$k(config, 'valuechangeCallbackScope', undefined);

        _this.on('valuechange', callback, scope);
      }

      _this.setEnable(GetValue$k(config, 'enable', undefined));

      _this.setValue(GetValue$k(config, 'value', 0));

      return _this;
    }

    _createClass(NumberBar, [{
      key: "enable",
      get: function get() {
        if (this.childrenMap.slider) {
          return this.childrenMap.slider.enable;
        } else {
          return false;
        }
      },
      set: function set(value) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setEnable(value);
        }
      }
    }, {
      key: "setEnable",
      value: function setEnable(enable) {
        if (enable === undefined) {
          enable = true;
        }

        this.enable = enable;
        return this;
      }
    }, {
      key: "value",
      get: function get() {
        if (this.childrenMap.slider) {
          return this.childrenMap.slider.value;
        } else {
          return 0;
        }
      },
      set: function set(value) {
        if (!this.childrenMap.slider) {
          return;
        }

        this.childrenMap.slider.value = value;
      }
    }, {
      key: "setValue",
      value: function setValue(value, min, max) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setValue(value, min, max);
        }

        return this;
      }
    }, {
      key: "addValue",
      value: function addValue(inc, min, max) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.addValue(inc, min, max);
        }

        return this;
      }
    }, {
      key: "getValue",
      value: function getValue(min, max) {
        if (this.childrenMap.slider) {
          return this.childrenMap.slider.getValue(min, max);
        } else {
          return 0;
        }
      }
    }, {
      key: "easeValueTo",
      value: function easeValueTo(value, min, max) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.easeValueTo(value, min, max);
        }

        return this;
      }
    }, {
      key: "stopEaseValue",
      value: function stopEaseValue() {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.stopEaseValue();
        }

        return this;
      }
    }, {
      key: "setEaseValueDuration",
      value: function setEaseValueDuration(duration) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setEaseValueDuration(duration);
        }

        return this;
      }
    }, {
      key: "setEaseValueFunction",
      value: function setEaseValueFunction(ease) {
        if (this.childrenMap.slider) {
          this.childrenMap.slider.setEaseValueFunction(ease);
        }

        return this;
      }
    }, {
      key: "text",
      get: function get() {
        var textObject = this.childrenMap.text;

        if (textObject === undefined) {
          return '';
        }

        var value;

        if (textObject.text) {
          value = textObject.text;
        } else {
          value = textObject.getData('text');
        }

        return value;
      },
      set: function set(value) {
        var textObject = this.childrenMap.text;

        if (textObject === undefined) {
          return;
        }

        if (textObject.setText) {
          textObject.setText(value);
        } else {
          textObject.setData('text', value);
        }
      }
    }, {
      key: "setText",
      value: function setText(value) {
        this.text = value;
        return this;
      }
    }]);

    return NumberBar;
  }(Sizer);

  ObjectFactory.register('numberBar', function (config) {
    var gameObject = new NumberBar(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.NumberBar', NumberBar);

  ObjectFactory.register('scrollBar', function (config) {
    var gameObject = new ScrollBar(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.ScrollBar', ScrollBar);

  var GetValue$j = Phaser.Utils.Objects.GetValue;
  var BadgeKeys = {
    leftTop: 'left-top',
    centerTop: 'center-top',
    rightTop: 'right-top',
    leftCenter: 'left-center',
    center: 'center',
    rightCenter: 'right-center',
    leftBottom: 'left-bottom',
    centerBottom: 'center-bottom',
    rightBottom: 'right-bottom'
  };

  var Badge = /*#__PURE__*/function (_OverlapSizer) {
    _inherits(Badge, _OverlapSizer);

    var _super = _createSuper(Badge);

    function Badge(scene, config) {
      var _this;

      _classCallCheck(this, Badge);

      // Create sizer  
      _this = _super.call(this, scene, config);
      _this.type = 'rexBadge'; // Add elements

      var background = GetValue$j(config, 'background', undefined);

      if (background) {
        _this.addBackground(background);
      }

      _this.addChildrenMap('background', background); // Base item


      var main = GetValue$j(config, 'main', undefined);

      if (main) {
        _this.add(main, {
          key: 'main',
          align: 'center',
          expand: false
        });
      }

      _this.addChildrenMap('main', main); // Badges


      for (var key in BadgeKeys) {
        var badge = GetValue$j(config, key, undefined);

        if (badge) {
          _this.add(badge, {
            key: key,
            align: BadgeKeys[key],
            expand: false
          });

          _this.addChildrenMap(key, badge);
        }
      }

      return _this;
    }

    return _createClass(Badge);
  }(OverlapSizer);

  ObjectFactory.register('badgeLabel', function (config) {
    var gameObject = new Badge(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.BadgeLabel', Badge);

  var OverlapSizerAdd = OverlapSizer.prototype.add;

  var Add = function Add(gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY) {
    gameObject.setVisible(false); // Default is invisible

    OverlapSizerAdd.call(this, gameObject, childKey, align, padding, expand, minWidth, minHeight, offsetX, offsetY);
    return this;
  };

  var AddChildMethods = {
    add: Add,
    addPage: Add
  };

  var GetPage = function GetPage(key) {
    if (key === undefined) {
      return null;
    } else if (!this.sizerChildren.hasOwnProperty(key)) {
      return null;
    } else {
      return this.sizerChildren[key];
    }
  };

  var ContainerSetChildVisible$1 = ContainerLite.prototype.setChildVisible;

  var SwapPage = function SwapPage(key) {
    this._previousKey = this._currentKey;
    var prevoiusPage = this.previousPage;

    if (prevoiusPage) {
      if (this.swapMode === 0) {
        // Invisible
        ContainerSetChildVisible$1.call(this, prevoiusPage, false);
        this.emit('pageinvisible', prevoiusPage, this._previousKey, this);
      } else {
        // Destroy
        prevoiusPage.destroy();
      }
    }

    if (key && !this.sizerChildren.hasOwnProperty(key)) {
      this.emit('createpage', key, this);
    }

    this._currentKey = key;
    var currentPage = this.currentPage;

    if (currentPage) {
      ContainerSetChildVisible$1.call(this, currentPage, true);
      this.emit('pagevisible', currentPage, this._currentKey, this);
    }

    return this;
  };

  var methods$4 = {
    getPage: GetPage,
    swapPage: SwapPage
  };
  Object.assign(methods$4, AddChildMethods);

  var GetValue$i = Phaser.Utils.Objects.GetValue;

  var Pages = /*#__PURE__*/function (_OverlapSizer) {
    _inherits(Pages, _OverlapSizer);

    var _super = _createSuper(Pages);

    function Pages(scene, config) {
      var _this;

      _classCallCheck(this, Pages);

      _this = _super.call(this, scene, config);
      _this.type = 'rexPages';
      _this.childrenMap = _this.sizerChildren;
      _this._previousKey = undefined;
      _this._currentKey = undefined;

      _this.setSwapMode(GetValue$i(config, 'swapMode', 0));

      return _this;
    }

    _createClass(Pages, [{
      key: "setSwapMode",
      value: function setSwapMode(mode) {
        if (typeof mode === 'string') {
          mode = SWAPMODE[mode];
        }

        this.swapMode = mode;
        return this;
      }
    }, {
      key: "previousKey",
      get: function get() {
        return this._previousKey;
      }
    }, {
      key: "currentKey",
      get: function get() {
        return this._currentKey;
      },
      set: function set(key) {
        this.swapPage(key);
      }
    }, {
      key: "currentPage",
      get: function get() {
        return this.getPage(this.currentKey);
      }
    }, {
      key: "previousPage",
      get: function get() {
        return this.getPage(this.previousKey);
      }
    }, {
      key: "keys",
      get: function get() {
        return Object.keys(this.sizerChildren);
      }
    }]);

    return Pages;
  }(OverlapSizer);

  Object.assign(Pages.prototype, methods$4);
  var SWAPMODE = {
    invisible: 0,
    destroy: 1
  };

  ObjectFactory.register('pages', function (config) {
    var gameObject = new Pages(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Pages', Pages);

  var SetText$1 = function SetText(text) {
    if (text !== undefined) {
      this.text = text;
    } // Wrap content in lines


    this.lines = TextToLines(this.textObject, this.text, this.lines); // Get lines count

    this.linesCount = this.lines.length; // Re-calculate these values later

    this._textHeight = undefined;
    this._textVisibleHeight = undefined;
    this.updateTextObject();
    return this;
  };

  var TextHeightToLinesCount = function TextHeightToLinesCount(height) {
    // height = (lines * (lineHeight + lineSpacing)) - lineSpacing
    return (height - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing);
  };

  var LinesCountToTextHeight = function LinesCountToTextHeight(linesCount) {
    // height = (linesCount * (lineHeight + lineSpacing)) - lineSpacing
    return linesCount * (this.textLineHeight + this.textLineSpacing) - this.textLineSpacing;
  };

  var GetLines = function GetLines(startLineIdx) {
    var endLineIdx = startLineIdx + this.visibleLinesCount + 1;
    var text;

    switch (this.textObjectType) {
      case TextType:
        text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
        break;

      case TagTextType:
        var startIdx = this.lines.getLineStartIndex(startLineIdx);
        var endIdx = this.lines.getLineEndIndex(endLineIdx - 1);
        text = this.lines.getSliceTagText(startIdx, endIdx, true);
        break;

      case BitmapTextType:
        text = this.lines.slice(startLineIdx, endLineIdx).join('\n');
        break;
    }

    return text;
  };

  var ResetTextObjectPosition = function ResetTextObjectPosition() {
    var config = this.textObject.rexSizer;
    this.textObject.y += config.offsetY - config.preOffsetY;
    config.preOffsetY = config.offsetY;
    this.resetChildPositionState(this.textObject);

    if (this.textCropEnable) {
      CropTextObject.call(this);
    }
  };

  var CropTextObject = function CropTextObject() {
    // Don't have setCrop method, return
    if (!this.textObject.setCrop) {
      return;
    }

    var offsetY = this.textObject.rexSizer.offsetY;
    var cropY, cropHeight;

    if (offsetY <= 0) {
      cropY = -offsetY;
      cropHeight = this.height;
    } else {
      cropY = 0;
      cropHeight = this.height - offsetY;
    }

    this.textObject.setCrop(0, cropY, this.width, cropHeight);
  };

  var UpdateTextObject = function UpdateTextObject() {
    var startLineIndex = Math.max(Math.floor(TextHeightToLinesCount.call(this, -this.textOY)), 0);
    var textOffset = LinesCountToTextHeight.call(this, startLineIndex) + this.textOY; // Grab visible lines

    var text = GetLines.call(this, startLineIndex); // Display visible content

    SetNoWrapText(this.textObject, text);
    this.textObject.rexSizer.offsetY = textOffset;
    ResetTextObjectPosition.call(this);
    return this;
  };

  var PreLayout = function PreLayout() {
    // Style of text
    this._textLineHeight = undefined;
    this._textLineSpacing = undefined; // Style of text, width of text

    this._visibleLinesCount = undefined; // Style of text, total lines of content

    this._textHeight = undefined;
    this._textVisibleHeight = undefined;
    PreLayout$4.call(this);
    return this;
  };

  var ResizeText = function ResizeText(textObject, width, height) {
    height += this.textLineHeight + this.textLineSpacing; // Add 1 line

    if (this.textObjectWidth === width && this._textObjectRealHeight === height) {
      return;
    }

    this.textObjectWidth = width;
    this._textObjectRealHeight = height;

    switch (this.textObjectType) {
      case TextType:
      case TagTextType:
        textObject.setFixedSize(width, height);
        var style = textObject.style;
        var wrapWidth = Math.max(width, 0);

        if (this.textObjectType === TextType) {
          // Built-in text
          style.wordWrapWidth = wrapWidth;
        } else {
          // BBCode text, Tag text
          if (style.wrapMode === 0) {
            // Turn no-wrap to word-wrap
            style.wrapMode = 1;
          }

          style.wrapWidth = wrapWidth;
        }

        break;

      case BitmapTextType:
        textObject.setMaxWidth(width);
        break;
    } // Render content again


    this.setText();
  };

  var LayoutChildren$1 = function LayoutChildren() {
    var child, childConfig, padding;
    var startX = this.left,
        startY = this.top;
    var x, y, width, height; // Align zone
    // LayoutChildren text child
    // Skip invisible child

    child = this.textObject;

    if (!child.rexSizer.hidden) {
      childConfig = child.rexSizer;
      padding = childConfig.padding;
      x = startX + padding.left;
      y = startY + padding.top;
      width = this.width - padding.left - padding.right;
      height = this.height - padding.top - padding.bottom;
      ResizeText.call(this, child, width, height);
      AlignIn(child, x, y, width, height, childConfig.align);
      childConfig.preOffsetY = 0; // Clear preOffsetY

      ResetTextObjectPosition.call(this);

      if (this.textMask) {
        this.textMask.setPosition().resize();
        this.resetChildPositionState(this.textMask);
      }
    }
  };

  var Methods = {
    setText: SetText$1,
    updateTextObject: UpdateTextObject,
    preLayout: PreLayout,
    layoutChildren: LayoutChildren$1
  };

  var IsPlainObject$4 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$h = Phaser.Utils.Objects.GetValue;
  var ALIGN_LEFTTOP$1 = Phaser.Display.Align.TOP_LEFT;

  var TextBlock = /*#__PURE__*/function (_BaseSizer) {
    _inherits(TextBlock, _BaseSizer);

    var _super = _createSuper(TextBlock);

    function TextBlock(scene, x, y, minWidth, minHeight, config) {
      var _this;

      _classCallCheck(this, TextBlock);

      if (IsPlainObject$4(x)) {
        config = x;
        x = GetValue$h(config, 'x', 0);
        y = GetValue$h(config, 'y', 0);
        minWidth = GetValue$h(config, 'width', undefined);
        minHeight = GetValue$h(config, 'height', undefined);
      } else if (IsPlainObject$4(minWidth)) {
        config = minWidth;
        minWidth = GetValue$h(config, 'width', undefined);
        minHeight = GetValue$h(config, 'height', undefined);
      }

      _this = _super.call(this, scene, x, y, minWidth, minHeight, config);
      _this.type = 'rexTextBlock';
      _this.textObject = undefined;
      _this.linesCount = 0;
      _this.textMask = undefined;
      _this.textObjectType = undefined;
      _this._textLineHeight = undefined;
      _this._textLineSpacing = undefined;
      _this._visibleLinesCount = undefined;
      _this._textHeight = undefined;
      _this._textVisibleHeight = undefined;
      _this.lines = undefined; // Text object : array of string
      // Tag text object : pens-manager
      // Bitmap text object : array of string

      _this.text = GetValue$h(config, 'content', '');
      _this._textOY = 0;
      _this.execeedTopState = false;
      _this.execeedBottomState = false;

      _this.setClampMode(GetValue$h(config, 'clamplTextOY', true));

      _this.alwaysScrollable = GetValue$h(config, 'alwaysScrollable', false); // Add elements

      var background = GetValue$h(config, 'background', undefined);
      var textObject = GetValue$h(config, 'text', undefined);

      if (textObject === undefined) {
        textObject = CreateDefaultTextObject(scene);
      }

      _this.textCropEnable = GetValue$h(config, 'textCrop', !!textObject.setCrop);
      var textMaskEnable = GetValue$h(config, 'textMask', !_this.textCropEnable);

      if (background) {
        _this.addBackground(background);
      }

      _this.add(textObject);

      _this.sizerChildren = [textObject];

      var sizerConfig = _this.getSizerConfig(textObject);

      sizerConfig.align = ALIGN_LEFTTOP$1;
      sizerConfig.padding = GetBoundsConfig(0);
      sizerConfig.expand = true;
      _this.textObject = textObject;
      _this.textObjectType = GetTextObjectType(textObject); // Add more variables

      sizerConfig.preOffsetY = 0;
      sizerConfig.offsetY = 0; // Create mask of text object

      if (textMaskEnable) {
        _this.textMask = AddChildMask.call(_assertThisInitialized(_this), _this.textObject, _assertThisInitialized(_this));
      }

      _this.addChildrenMap('background', background);

      _this.addChildrenMap('text', textObject);

      return _this;
    }

    _createClass(TextBlock, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        this.textObject = undefined;
        this.textMask = undefined;

        if (this.lines) {
          switch (this.textObjectType) {
            case TextType:
              this.lines.length = 0;
              break;

            case TagTextType:
              this.lines.destroy();
              break;

            case BitmapTextType:
              this.lines.length = 0;
              break;
          }

          this.lines = undefined;
        }

        _get(_getPrototypeOf(TextBlock.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setClampMode",
      value: function setClampMode(mode) {
        if (mode === undefined) {
          mode = true;
        }

        this.clampTextOY = mode;
        return this;
      }
    }, {
      key: "textLineHeight",
      get: function get() {
        if (this._textLineHeight === undefined) {
          var lineHeight;

          switch (this.textObjectType) {
            case TextType:
            case TagTextType:
              var style = this.textObject.style;
              lineHeight = style.metrics.fontSize + style.strokeThickness;
              break;

            case BitmapTextType:
              var scale = this.textObject.fontSize / this.textObject.fontData.size;
              lineHeight = this.textObject.fontData.lineHeight * scale;
              break;
          }

          this._textLineHeight = lineHeight;
        }

        return this._textLineHeight;
      }
    }, {
      key: "textLineSpacing",
      get: function get() {
        if (this._textLineSpacing === undefined) {
          var lineSpacing;

          switch (this.textObjectType) {
            case TextType:
            case TagTextType:
              lineSpacing = this.textObject.lineSpacing;
              break;

            case BitmapTextType:
              lineSpacing = 0;
              break;
          }

          this._textLineSpacing = lineSpacing;
        }

        return this._textLineSpacing;
      }
    }, {
      key: "visibleLinesCount",
      get: function get() {
        if (this._visibleLinesCount === undefined) {
          this._visibleLinesCount = Math.floor(TextHeightToLinesCount.call(this, this._textObjectRealHeight));
        }

        return this._visibleLinesCount;
      }
    }, {
      key: "topTextOY",
      get: function get() {
        return 0;
      }
    }, {
      key: "bottomTextOY",
      get: function get() {
        return -this.textVisibleHeight;
      }
    }, {
      key: "textHeight",
      get: function get() {
        if (this._textHeight === undefined) {
          this._textHeight = LinesCountToTextHeight.call(this, this.linesCount);
        }

        return this._textHeight;
      }
    }, {
      key: "textObjectHeight",
      get: function get() {
        return this._textObjectRealHeight - (this.textLineHeight + this.textLineSpacing); // Remove 1 text line
      }
    }, {
      key: "textVisibleHeight",
      get: function get() {
        if (this._textVisibleHeight === undefined) {
          var h = this.textHeight - this.textObjectHeight;

          if (!this.alwaysScrollable && h < 0) {
            h = 0;
          }

          this._textVisibleHeight = h;
        }

        return this._textVisibleHeight;
      }
    }, {
      key: "textOYExceedTop",
      value: function textOYExceedTop(oy) {
        if (oy === undefined) {
          oy = this.textOY;
        }

        return oy > this.topTextOY;
      }
    }, {
      key: "textOYExeceedBottom",
      value: function textOYExeceedBottom(oy) {
        if (oy === undefined) {
          oy = this.textOY;
        }

        return oy < this.bottomTextOY;
      }
    }, {
      key: "textOY",
      get: function get() {
        return this._textOY;
      },
      set: function set(oy) {
        var topTextOY = this.topTextOY;
        var bottomTextOY = this.bottomTextOY;
        var textOYExceedTop = this.textOYExceedTop(oy);
        var textOYExeceedBottom = this.textOYExeceedBottom(oy);

        if (this.clampTextOY) {
          if (this.visibleLinesCount > this.linesCount) {
            oy = 0;
          } else if (textOYExceedTop) {
            oy = topTextOY;
          } else if (textOYExeceedBottom) {
            oy = bottomTextOY;
          }
        }

        if (this._textOY !== oy) {
          this._textOY = oy;
          this.updateTextObject();
        }

        if (textOYExceedTop) {
          if (!this.execeedTopState) {
            this.emit('execeedtop', this, oy, topTextOY);
          }
        }

        this.execeedTopState = textOYExceedTop;

        if (textOYExeceedBottom) {
          if (!this.execeedBottomState) {
            this.emit('execeedbottom', this, oy, bottomTextOY);
          }
        }

        this.execeedBottomState = textOYExeceedBottom;
      }
    }, {
      key: "setTextOY",
      value: function setTextOY(oy) {
        this.textOY = oy;
        return this;
      }
    }, {
      key: "t",
      get: function get() {
        var textVisibleHeight = this.textVisibleHeight;

        if (textVisibleHeight === 0) {
          return 0;
        }

        return this.textOY / -textVisibleHeight;
      },
      set: function set(value) {
        this.textOY = -this.textVisibleHeight * value;
      }
    }, {
      key: "setTextOYByPercentage",
      value: function setTextOYByPercentage(percentage) {
        this.t = percentage;
        return this;
      }
    }]);

    return TextBlock;
  }(Base);

  var CreateDefaultTextObject = function CreateDefaultTextObject(scene) {
    return scene.add.text(0, 0, '');
  };

  Object.assign(TextBlock.prototype, Methods);

  var InjectProperties = function InjectProperties(textBlock) {
    Object.defineProperty(textBlock, 'childOY', {
      configurable: true,
      get: function get() {
        return textBlock.textOY;
      },
      set: function set(value) {
        textBlock.textOY = value;
      }
    });
    Object.defineProperty(textBlock, 'topChildOY', {
      get: function get() {
        return textBlock.topTextOY;
      }
    });
    Object.defineProperty(textBlock, 'bottomChildOY', {
      get: function get() {
        return textBlock.bottomTextOY;
      }
    });
    Object.defineProperty(textBlock, 'childVisibleHeight', {
      get: function get() {
        return textBlock.textObjectHeight;
      }
    });
    Object.defineProperty(textBlock, 'childHeight', {
      get: function get() {
        return textBlock.textHeight;
      }
    });
  };

  var SetText = function SetText(text) {
    var textBlock = this.childrenMap.child;
    textBlock.setText(text);
    this.resizeController();
    return this;
  };

  var AppendText = function AppendText(text) {
    this.setText(this.text + text);
    return this;
  };

  var GetValue$g = Phaser.Utils.Objects.GetValue;

  var TextArea = /*#__PURE__*/function (_Scrollable) {
    _inherits(TextArea, _Scrollable);

    var _super = _createSuper(TextArea);

    function TextArea(scene, config) {
      var _this;

      _classCallCheck(this, TextArea);

      if (config === undefined) {
        config = {};
      } // Create text-block


      var textObject = GetValue$g(config, 'text', undefined);
      var textWidth = GetValue$g(config, 'textWidth', undefined);
      var textHeight = GetValue$g(config, 'textHeight', undefined);
      var textCrop = GetValue$g(config, 'textCrop', !!textObject.setCrop);
      var textMask = GetValue$g(config, 'textMask', !textCrop);
      var content = GetValue$g(config, 'content', '');
      var textBlock = new TextBlock(scene, {
        width: textWidth,
        height: textHeight,
        text: textObject,
        textMask: textMask,
        textCrop: textCrop && !textMask,
        content: content,
        clamplTextOY: GetValue$g(config, 'clamplChildOY', false),
        alwaysScrollable: GetValue$g(config, 'alwaysScrollable', false)
      });
      scene.add.existing(textBlock); // Important: Add to display list for touch detecting

      var proportion = textWidth === undefined ? 1 : 0;
      var expand = textHeight === undefined; // Inject properties for scrollable interface

      InjectProperties(textBlock); // Fill config of scrollable

      config.scrollMode = 0; // Vertical

      config.type = 'rexTextArea';
      config.child = {
        gameObject: textBlock,
        proportion: proportion,
        expand: expand
      };
      var spaceConfig = GetValue$g(config, 'space', undefined);

      if (spaceConfig) {
        spaceConfig.child = spaceConfig.text;
      }

      _this = _super.call(this, scene, config);

      _this.addChildrenMap('text', textObject);

      return _this;
    }

    _createClass(TextArea, [{
      key: "text",
      get: function get() {
        return this.childrenMap.child.text;
      }
    }, {
      key: "linesCount",
      get: function get() {
        return this.childrenMap.child.linesCount;
      }
    }, {
      key: "contentHeight",
      get: function get() {
        return this.childrenMap.child.textHeight;
      }
    }]);

    return TextArea;
  }(Scrollable);

  var methods$3 = {
    setText: SetText,
    appendText: AppendText
  };
  Object.assign(TextArea.prototype, methods$3);

  ObjectFactory.register('textArea', function (config) {
    var gameObject = new TextArea(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.TextArea', TextArea);

  var GetChildrenWidth = function GetChildrenWidth() {
    if (this.rexSizer.hidden) {
      return 0;
    }

    var result;
    var child = this.child,
        childConfig = child.rexSizer;

    if (childConfig.hidden) {
      result = 0;
    } else if (this.scrollMode === 0) {
      // scroll y
      result = this.getChildWidth(child);
    } else {
      // scroll x
      result = 0;
    }

    return result;
  };

  var GetChildrenHeight = function GetChildrenHeight() {
    if (this.rexSizer.hidden) {
      return 0;
    }

    var result;
    var child = this.child,
        childConfig = child.rexSizer;

    if (childConfig.hidden) {
      result = 0;
    } else if (this.scrollMode === 0) {
      // scroll y   
      result = 0;
    } else {
      // scroll x
      result = child.isRexSizer ? Math.max(child.minHeight, child.childrenHeight) : child.hasOwnProperty('minHeight') ? child.minHeight : GetDisplayHeight(child);
    }

    return result;
  };

  var GetChildrenSizers = function GetChildrenSizers(out) {
    if (out === undefined) {
      out = [];
    }

    if (this.child && this.child.isRexSizer) {
      out.push(this.child);
    }

    return out;
  };

  var ResetChildPosition = function ResetChildPosition() {
    var x = this.left;
    var y = this.top;

    if (this.scrollMode === 0) {
      y += this.childOY;
    } else {
      x += this.childOY;
    }

    this.child.setPosition(x, y);
    this.resetChildPositionState(this.child);
    this.setMaskChildrenFlag();
  };

  var LayoutChildren = function LayoutChildren() {
    // LayoutChildren child
    var child = this.child;
    var childWidth, childHeight;

    if (!child.rexSizer.hidden) {
      // Set size
      if (this.scrollMode === 0) {
        childWidth = this.width;
      } else {
        childHeight = this.height;
      }

      if (child.isRexSizer) {
        child.runLayout(this, childWidth, childHeight);
      } else {
        ResizeGameObject(child, childWidth, childHeight);
      } // Update local state


      this.resetChildPosition(); // Layout children-mask

      this.layoutChildrenMask(); // Re-mask children

      this.maskChildren();
    }
  };

  var methods$2 = {
    getChildrenWidth: GetChildrenWidth,
    getChildrenHeight: GetChildrenHeight,
    getChildrenSizers: GetChildrenSizers,
    resetChildPosition: ResetChildPosition,
    layoutChildren: LayoutChildren
  };
  Object.assign(methods$2, ChildrenMaskMethods);

  var IsPlainObject$3 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$f = Phaser.Utils.Objects.GetValue;
  var ALIGN_LEFTTOP = Phaser.Display.Align.TOP_LEFT;

  var ScrollableBlock = /*#__PURE__*/function (_BaseSizer) {
    _inherits(ScrollableBlock, _BaseSizer);

    var _super = _createSuper(ScrollableBlock);

    function ScrollableBlock(scene, x, y, minWidth, minHeight, config) {
      var _this;

      _classCallCheck(this, ScrollableBlock);

      if (IsPlainObject$3(x)) {
        config = x;
        x = GetValue$f(config, 'x', 0);
        y = GetValue$f(config, 'y', 0);
        minWidth = GetValue$f(config, 'width', undefined);
        minHeight = GetValue$f(config, 'height', undefined);
      } else if (IsPlainObject$3(minWidth)) {
        config = minWidth;
        minWidth = GetValue$f(config, 'width', undefined);
        minHeight = GetValue$f(config, 'height', undefined);
      }

      _this = _super.call(this, scene, x, y, minWidth, minHeight, config);
      _this.type = 'rexScrollableBlock';
      _this.child = undefined;
      _this.childrenMask = undefined;
      _this._childOY = 0;
      _this.execeedTopState = false;
      _this.execeedBottomState = false;

      _this.setScrollMode(GetValue$f(config, 'scrollMode', true));

      _this.setClampMode(GetValue$f(config, 'clamplChildOY', true)); // Add elements
      // No background object, and child does not have padding


      var child = GetValue$f(config, 'child', undefined);
      var expand = GetValue$f(config, 'expand', true);

      if (child.setOrigin) {
        child.setOrigin(0);
      }

      _this.add(child);

      _this.sizerChildren = [child];

      var sizerConfig = _this.getSizerConfig(child);

      sizerConfig.align = ALIGN_LEFTTOP;
      sizerConfig.expand = expand;
      _this.child = child; // Create mask of child object

      _this.setupChildrenMask(GetValue$f(config, 'mask', undefined));

      return _this;
    }

    _createClass(ScrollableBlock, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        this.destroyChildrenMask();
        this.child = undefined;

        _get(_getPrototypeOf(ScrollableBlock.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setScrollMode",
      value: function setScrollMode(mode) {
        if (typeof mode === 'string') {
          mode = SCROLLMODE$1[mode.toLowerCase()];
        }

        this.scrollMode = mode;
        return this;
      }
    }, {
      key: "setClampMode",
      value: function setClampMode(mode) {
        if (mode === undefined) {
          mode = true;
        }

        this.clampChildOY = mode;
        return this;
      }
    }, {
      key: "instHeight",
      get: function get() {
        return this.scrollMode === 0 ? this.height : this.width;
      }
    }, {
      key: "instWidth",
      get: function get() {
        return this.scrollMode === 0 ? this.width : this.height;
      }
    }, {
      key: "childHeight",
      get: function get() {
        return this.scrollMode === 0 ? GetDisplayHeight(this.child) : GetDisplayWidth(this.child);
      }
    }, {
      key: "childWidth",
      get: function get() {
        return this.scrollMode === 0 ? GetDisplayWidth(this.child) : GetDisplayHeight(this.child);
      }
    }, {
      key: "topChildOY",
      get: function get() {
        return 0;
      }
    }, {
      key: "bottomChildOY",
      get: function get() {
        return -this.visibleHeight;
      }
    }, {
      key: "childVisibleHeight",
      get: function get() {
        return this.instHeight;
      }
    }, {
      key: "visibleHeight",
      get: function get() {
        var h = this.childHeight - this.childVisibleHeight;

        if (h < 0) {
          h = 0;
        }

        return h;
      }
    }, {
      key: "childOYExceedTop",
      value: function childOYExceedTop(oy) {
        if (oy === undefined) {
          oy = this.childOY;
        }

        return oy > this.topChildOY;
      }
    }, {
      key: "childOYExeceedBottom",
      value: function childOYExeceedBottom(oy) {
        if (oy === undefined) {
          oy = this.childOY;
        }

        return oy < this.bottomChildOY;
      }
    }, {
      key: "childOY",
      get: function get() {
        return this._childOY;
      },
      set: function set(oy) {
        var topChildOY = this.topChildOY;
        var bottomChildOY = this.bottomChildOY;
        var childOYExceedTop = this.childOYExceedTop(oy);
        var childOYExeceedBottom = this.childOYExeceedBottom(oy);

        if (this.clampChildOY) {
          if (this.childVisibleHeight > this.childHeight) {
            oy = 0;
          } else if (childOYExceedTop) {
            oy = topChildOY;
          } else if (childOYExeceedBottom) {
            oy = bottomChildOY;
          }
        }

        if (this._childOY !== oy) {
          this._childOY = oy;
          this.resetChildPosition();
        }

        if (childOYExceedTop) {
          if (!this.execeedTopState) {
            this.emit('execeedtop', this, oy, topChildOY);
          }
        }

        this.execeedTopState = childOYExceedTop;

        if (childOYExeceedBottom) {
          if (!this.execeedBottomState) {
            this.emit('execeedbottom', this, oy, bottomChildOY);
          }
        }

        this.execeedBottomState = childOYExeceedBottom;
      }
    }, {
      key: "setChildOY",
      value: function setChildOY(oy) {
        this.childOY = oy;
        return this;
      }
    }, {
      key: "t",
      get: function get() {
        var visibleHeight = this.visibleHeight;

        if (visibleHeight === 0) {
          return 0;
        }

        return this.childOY / -visibleHeight;
      },
      set: function set(value) {
        this.childOY = -this.visibleHeight * value;
      }
    }, {
      key: "setChildOYByPercentage",
      value: function setChildOYByPercentage(percentage) {
        this.t = percentage;
        return this;
      }
    }]);

    return ScrollableBlock;
  }(Base);

  Object.assign(ScrollableBlock.prototype, methods$2);

  var GetValue$e = Phaser.Utils.Objects.GetValue;

  var ScrollablePanel = /*#__PURE__*/function (_Scrollable) {
    _inherits(ScrollablePanel, _Scrollable);

    var _super = _createSuper(ScrollablePanel);

    function ScrollablePanel(scene, config) {
      var _this;

      _classCallCheck(this, ScrollablePanel);

      if (config === undefined) {
        config = {};
      } // Create scrollable-block


      var scrollMode = GetScrollMode(config);
      var panelConfig = GetValue$e(config, 'panel', undefined);

      if (panelConfig === undefined) {
        panelConfig = {};
      }

      panelConfig.scrollMode = scrollMode;
      panelConfig.clamplChildOY = GetValue$e(config, 'clamplChildOY', false);
      var scrollableBlock = new ScrollableBlock(scene, panelConfig);
      scene.add.existing(scrollableBlock); // Important: Add to display list for touch detecting

      var panelWidth = GetValue$e(panelConfig, 'width', undefined);
      var panelHeight = GetValue$e(panelConfig, 'height', undefined);
      var proportion, expand;

      if (scrollMode === 0) {
        proportion = panelWidth === undefined ? 1 : 0;
        expand = panelHeight === undefined;
      } else {
        proportion = panelHeight === undefined ? 1 : 0;
        expand = panelWidth === undefined;
      } // Fill config of scrollable


      config.type = 'rexScrollablePanel';
      config.child = {
        gameObject: scrollableBlock,
        proportion: proportion,
        expand: expand
      };
      var spaceConfig = GetValue$e(config, 'space', undefined);

      if (spaceConfig) {
        spaceConfig.child = spaceConfig.panel;
      }

      _this = _super.call(this, scene, config);

      _this.addChildrenMap('panel', scrollableBlock.child);

      _this.addChildrenMap('panelLayer', scrollableBlock.maskLayer);

      return _this;
    }

    _createClass(ScrollablePanel, [{
      key: "setChildrenInteractive",
      value: function setChildrenInteractive(config) {
        if (config === undefined) {
          config = {};
        }

        if (!config.hasOwnProperty('eventEmitter')) {
          config.eventEmitter = this;
        }

        if (!config.hasOwnProperty('targets')) {
          config.targets = [this.childrenMap.panel];
        }

        SetChildrenInteractive(this.childrenMap.child, config);
        return this;
      }
    }]);

    return ScrollablePanel;
  }(Scrollable);

  ObjectFactory.register('scrollablePanel', function (config) {
    var gameObject = new ScrollablePanel(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.ScrollablePanel', ScrollablePanel);

  var DefaultTransitCallbacks$1 = {
    popUp: function popUp(gameObject, duration) {
      gameObject.popUp(duration);
    },
    scaleDown: function scaleDown(gameObject, duration) {
      gameObject.scaleDown(duration);
    },
    fadeIn: function fadeIn(gameObject, duration) {
      gameObject.fadeIn(duration);
    },
    fadeOut: function fadeOut(gameObject, duration) {
      gameObject.fadeOut(duration);
    }
  };

  var Copy = function Copy(dest, src, startIdx, endIdx) {
    if (startIdx === undefined) {
      startIdx = 0;
    }

    if (endIdx === undefined) {
      endIdx = src.length;
    }

    dest.length = endIdx - startIdx;

    for (var i = 0, len = dest.length; i < len; i++) {
      dest[i] = src[i + startIdx];
    }

    return dest;
  };

  var GetValue$d = Phaser.Utils.Objects.GetValue;

  var RunCommands = function RunCommands(queue, scope, config) {
    var reverse = GetValue$d(config, 'reverse', false);
    var retVal;

    if (IsArray(queue[0])) {
      if (!reverse) {
        for (var i = 0, len = queue.length; i < len; i++) {
          retVal = RunCommands(queue[i], scope, config);
        }
      } else {
        for (var len = queue.length, i = len - 1; i >= 0; i--) {
          retVal = RunCommands(queue[i], scope, config);
        }
      }
    } else {
      retVal = RunCommand(queue, scope, config);
    }

    return retVal;
  };

  var RunCommand = function RunCommand(cmd, scope, config) {
    var argsConvert = GetValue$d(config, 'argsConvert', undefined);
    var argsConvertScope = GetValue$d(config, 'argsConvertScope', undefined);
    var fnName = cmd[0];
    ARGS = Copy(ARGS, cmd, 1);

    if (argsConvert) {
      // convert string to floating number, boolean, null, or string        
      if (argsConvert === true) {
        argsConvert = convert;
        argsConvertScope = undefined;
      }

      for (var i = 0, len = ARGS.length; i < len; i++) {
        if (argsConvertScope) {
          ARGS[i] = argsConvert.call(argsConvertScope, ARGS[i], cmd);
        } else {
          ARGS[i] = argsConvert(ARGS[i], cmd);
        }
      }
    }

    var fn;

    if (typeof fnName === 'string') {
      fn = scope[fnName];

      if (fn == null) {
        fn = GetValue$d(scope, fnName, null);
      }
    } else {
      fn = fnName;
    }

    var retValue = fn.apply(scope, ARGS);
    return retValue;
  };

  var ARGS = []; // reuse this array

  var GetValue$c = Phaser.Utils.Objects.GetValue;

  var Player = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Player, _ComponentBase);

    var _super = _createSuper(Player);

    function Player(parent, config) {
      var _this;

      _classCallCheck(this, Player);

      _this = _super.call(this, parent, config);
      var clock = GetValue$c(config, 'clock', undefined);

      if (!clock) {
        clock = new Clock(parent);
      }

      _this.clock = clock;

      _this.clock.on('update', _this.update, _assertThisInitialized(_this));

      _this.resetFromJSON(config); // this function had been called in super(config)


      return _this;
    }

    _createClass(Player, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.clock.resetFromJSON(GetValue$c(o, 'clock', undefined));
        this.state = GetValue$c(o, 'state', 0); // 0=idle, 1=run, 2=completed

        this.commands = GetValue$c(o, 'commands', []); // [[time, cmds], [time, cmds], ...]

        this.scope = GetValue$c(o, 'scope', undefined);
        this.setTimeUnit(GetValue$c(o, 'timeUnit', 0));
        this.setDtMode(GetValue$c(o, 'dtMode', 0));
        this.index = GetValue$c(o, 'index', 0);
        this.nextTime = GetValue$c(o, 'nextTime', 0);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          clock: this.clock.toJSON(),
          state: this.state,
          commands: this.commands,
          scope: this.scope,
          timeUnit: this.timeUnit,
          dtMode: this.dtMode,
          index: this.index,
          nextTime: this.nextTime
        };
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        this.clock.shutdown(fromScene);
        this.commands = undefined;

        _get(_getPrototypeOf(Player.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "load",
      value: function load(commands, scope, config) {
        this.stop();
        var timeUnit = GetValue$c(config, 'timeUnit', undefined);

        if (timeUnit !== undefined) {
          this.setTimeUnit(timeUnit);
        }

        var dtMode = GetValue$c(config, 'dtMode', undefined);

        if (dtMode !== undefined) {
          this.setDtMode(dtMode);
        }

        commands = commands.filter(function (item) {
          var dt = item[0];
          return !isNaN(dt);
        }).map(function (item) {
          var dt = item[0];

          if (typeof dt === 'string') {
            item[0] = parseFloat(item[0]);
          }

          return item;
        });

        if (this.dtMode === 0) {
          commands.sort(function (itemA, itemB) {
            var dtA = itemA[0],
                dtB = itemB[0];
            return dtA > dtB ? 1 : dtA < dtB ? -1 : 0;
          });
        }

        this.commands = commands;
        this.scope = scope;
        return this;
      }
    }, {
      key: "start",
      value: function start(startAt) {
        if (startAt === undefined) {
          startAt = 0;
        }

        this.stop();
        this.index = 0;
        this.state = 1;
        this.nextTime = this.getNextDt(0);
        this.clock.start(startAt);
        this.update(startAt);
        this.emit('start', this.parent, this);
        return this;
      }
    }, {
      key: "pause",
      value: function pause() {
        this.clock.pause();
        this.emit('pause', this.parent, this);
        return this;
      }
    }, {
      key: "resume",
      value: function resume() {
        this.clock.resume();
        this.emit('resume', this.parent, this);
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.clock.stop();
        this.state = 0;
        this.emit('stop', this.parent, this);
        return this;
      }
    }, {
      key: "seek",
      value: function seek(time) {
        this.clock.seek(time);
        return this;
      }
    }, {
      key: "isPlaying",
      get: function get() {
        return this.clock.isRunning;
      }
    }, {
      key: "completed",
      get: function get() {
        return this.state === 2;
      }
    }, {
      key: "timeScale",
      get: function get() {
        return this.clock.timeScale;
      },
      set: function set(timeScale) {
        this.clock.timeScale = timeScale;
      }
    }, {
      key: "setTimeScale",
      value: function setTimeScale(timeScale) {
        this.timeScale = timeScale;
        return this;
      }
    }, {
      key: "now",
      get: function get() {
        return this.clock.now;
      }
    }, {
      key: "update",
      value: function update(now) {
        if (this.nextTime > now) {
          return this;
        }

        var lastCommandIndex = this.commands.length - 1;

        while (1) {
          // Execute a command
          var item = this.commands[this.index];
          var command = item[1];

          if (!IsArray(command)) {
            // [dt, fnName, param0, param1, ...]
            command = Copy(CMD, item, 1);
          }

          RunCommands(command, this.scope);
          this.emit('runcommand', command, this.scope); // Execute a command

          if (this.index === lastCommandIndex) {
            this.complete();
            return this;
          } else {
            // Get next time
            this.index++; // Point to next command

            this.nextTime = this.getNextDt(this.nextTime);

            if (this.nextTime > now) {
              return this;
            } // Get next time

          }
        }
      }
    }, {
      key: "complete",
      value: function complete() {
        this.clock.stop();
        this.state = 2;
        this.emit('complete', this.parent, this);
      }
    }, {
      key: "getNextDt",
      value: function getNextDt(currentDt) {
        var time = this.commands[this.index][0];

        if (this.timeUnit === 1) {
          // Second mode
          time = time * 1000;
        }

        if (this.dtMode === 1) {
          time += currentDt;
        }

        return time;
      }
    }, {
      key: "setDtMode",
      value: function setDtMode(dtMode) {
        if (typeof dtMode === 'string') {
          dtMode = DTMODE[dtMode];
        }

        this.dtMode = dtMode;
        return this;
      }
    }, {
      key: "setTimeUnit",
      value: function setTimeUnit(timeUnit) {
        if (typeof timeUnit === 'string') {
          timeUnit = TIMEUNITMODE[timeUnit];
        }

        this.timeUnit = timeUnit;
        return this;
      }
    }]);

    return Player;
  }(ComponentBase);

  var CMD = []; // reuse this array

  var TIMEUNITMODE = {
    ms: 0,
    s: 1,
    sec: 1
  };
  var DTMODE = {
    abs: 0,
    absolute: 0,
    inc: 1,
    increment: 1
  };

  var GetValue$b = Phaser.Utils.Objects.GetValue;

  var Toast = /*#__PURE__*/function (_Label) {
    _inherits(Toast, _Label);

    var _super = _createSuper(Toast);

    function Toast(scene, config) {
      var _this;

      _classCallCheck(this, Toast);

      if (config === undefined) {
        config = {
          text: createDefaultTextObject(scene)
        };
      }

      _this = _super.call(this, scene, config);
      _this.type = 'rexToast';

      _this.setTransitInTime(GetValue$b(config, 'duration.in', 200));

      _this.setDisplayTime(GetValue$b(config, 'duration.hold', 1200));

      _this.setTransitOutTime(GetValue$b(config, 'duration.out', 200));

      _this.setTransitInCallback(GetValue$b(config, 'transitIn', TransitionMode$1.popUp));

      _this.setTransitOutCallback(GetValue$b(config, 'transitOut', TransitionMode$1.scaleDown));

      _this.player = new Player(_assertThisInitialized(_this), {
        dtMode: 1
      });
      _this.messages = [];
      _this.scaleX0 = undefined;
      _this.scaleY0 = undefined;

      _this.setVisible(false);

      return _this;
    }

    _createClass(Toast, [{
      key: "destroy",
      value: function destroy(fromScene) {
        //  This Game Object has already been destroyed
        if (!this.scene) {
          return;
        }

        this.player.destroy();
        this.player = undefined;
        this.messages = undefined;

        _get(_getPrototypeOf(Toast.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "setDisplayTime",
      value: function setDisplayTime(time) {
        this.displayTime = time;
        return this;
      }
    }, {
      key: "setTransitOutTime",
      value: function setTransitOutTime(time) {
        this.transitOutTime = time;
        return this;
      }
    }, {
      key: "setTransitInTime",
      value: function setTransitInTime(time) {
        this.transitInTime = time;
        return this;
      }
    }, {
      key: "setTransitInCallback",
      value: function setTransitInCallback(callback) {
        if (typeof callback === 'string') {
          callback = TransitionMode$1[callback];
        }

        switch (callback) {
          case TransitionMode$1.popUp:
            callback = DefaultTransitCallbacks$1.popUp;
            break;

          case TransitionMode$1.fadeIn:
            callback = DefaultTransitCallbacks$1.fadeIn;
            break;
        }

        if (!callback) {
          callback = NOOP;
        }

        this.transitInCallback = callback; // callback = function(gameObject, duration) {}

        return this;
      }
    }, {
      key: "setTransitOutCallback",
      value: function setTransitOutCallback(callback) {
        if (typeof callback === 'string') {
          callback = TransitionMode$1[callback];
        }

        switch (callback) {
          case TransitionMode$1.scaleDown:
            callback = DefaultTransitCallbacks$1.scaleDown;
            break;

          case TransitionMode$1.fadeOut:
            callback = DefaultTransitCallbacks$1.fadeOut;
            break;
        }

        if (!callback) {
          callback = NOOP;
        }

        this.transitOutCallback = callback; // callback = function(gameObject, duration) {}

        return this;
      }
    }, {
      key: "setScale",
      value: function setScale(scaleX, scaleY) {
        if (scaleY === undefined) {
          scaleY = scaleX;
        } // Can override initial scale


        this.scaleX0 = scaleX;
        this.scaleY0 = scaleY;

        _get(_getPrototypeOf(Toast.prototype), "setScale", this).call(this, scaleX, scaleY);

        return this;
      }
    }, {
      key: "showMessage",
      value: function showMessage(callback) {
        // Remember first scaleX, scaleY as initial scale
        if (this.scaleX0 === undefined) {
          this.scaleX0 = this.scaleX;
        }

        if (this.scaleY0 === undefined) {
          this.scaleY0 = this.scaleY;
        }

        if (callback === undefined) {
          // Try pop up a pendding message
          if (this.messages.length === 0) {
            return this;
          }

          callback = this.messages.shift();
        }

        if (this.player.isPlaying) {
          // Pend message
          this.messages.push(callback);
          return this;
        } // Recover to initial state


        this.setScale(this.scaleX0, this.scaleY0).setVisible(true);

        if (typeof callback === 'string') {
          this.setText(callback);
        } else {
          callback(this);
        }

        this.layout();
        var commands = [[// Transit-in
        0, // time
        [this.transitInCallback, this, this.transitInTime] // [callback, param, ...]
        ], [// Hold
        this.transitInTime, [NOOP]], [// Transit-out
        this.displayTime, [this.transitOutCallback, this, this.transitOutTime]], [// End
        this.transitOutTime, [this.setVisible, false]], [// Complete - show next message
        30, // Add a small delay before complete
        [NOOP]]];
        this.player.load(commands, this).once('complete', function () {
          this.showMessage();
        }, this).start();
        return this;
      }
    }]);

    return Toast;
  }(Label);

  var TransitionMode$1 = {
    popUp: 0,
    fadeIn: 1,
    scaleDown: 0,
    fadeOut: 1
  };

  ObjectFactory.register('toast', function (config) {
    var gameObject = new Toast(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Toast', Toast);

  var GetShowCallback$1 = function GetShowCallback() {
    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.setChildVisible(child, true);
      }
    };
  };

  var GetHideCallback$1 = function GetHideCallback() {
    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.setChildVisible(child, false);
      }
    };
  };

  var VisibleCallbacks = {
    show: GetShowCallback$1,
    hide: GetHideCallback$1
  };

  var GetShowCallback = function GetShowCallback(duration, alpha) {
    if (alpha === undefined) {
      alpha = 1;
    }

    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.fadeChild(child, reset ? 0 : duration, alpha);
      }
    };
  };

  var GetHideCallback = function GetHideCallback(duration, alpha) {
    if (alpha === undefined) {
      alpha = 0;
    }

    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.fadeChild(child, reset ? 0 : duration, alpha);
      }
    };
  };

  var FadeCallbacks = {
    show: GetShowCallback,
    hide: GetHideCallback
  };

  var GetCallback$1 = function GetCallback(duration, ease) {
    return function (child, key, sides, reset) {
      if (key !== 'panel') {
        sides.moveChild(child, reset ? 0 : duration, ease);
      }
    };
  };

  var MoveCallbacks = {
    show: GetCallback$1,
    hide: GetCallback$1
  };

  var GetCallback = function GetCallback(duration, ease) {
    return function (child, key, sides, reset) {
      if (key === 'panel') {
        sides.moveChild(child, reset ? 0 : duration, ease);
      }
    };
  };

  var MovePanelCallbacks = {
    show: GetCallback,
    hide: GetCallback
  };

  var DefaultCallbacks = {
    visible: VisibleCallbacks,
    fade: FadeCallbacks,
    move: MoveCallbacks,
    'move-panel': MovePanelCallbacks
  };

  var GetDefaultCallbacks = function GetDefaultCallbacks(config) {
    var callbackType, callbackParams;

    var _ref = typeof config === 'string' ? [config] : config;

    var _ref2 = _toArray(_ref);

    callbackType = _ref2[0];
    callbackParams = _ref2.slice(1);
    var showCallback, hideCallback;

    if (DefaultCallbacks.hasOwnProperty(callbackType)) {
      showCallback = DefaultCallbacks[callbackType].show.apply(null, callbackParams);
      hideCallback = DefaultCallbacks[callbackType].hide.apply(null, callbackParams);
    } else {
      showCallback = NOOP;
      hideCallback = NOOP;
    }

    return {
      show: showCallback,
      hide: hideCallback
    };
  };

  var ShowChildMethods = {
    showChild: function showChild(key, reset) {
      var child = this.sizerChildren[key];

      if (child) {
        this.emit('showchild', child, key, this, reset);
        this.resetChildState(child);
      }

      return this;
    },
    hideChild: function hideChild(key, reset) {
      var child = this.sizerChildren[key];

      if (child) {
        this.emit('hidechild', child, key, this, reset);
        this.resetChildState(child);
      }

      return this;
    },
    swapChild: function swapChild(key, reset) {
      if (this.currentChildKey === key) ; else if (this.currentChildKey === 'panel' || key === 'panel') {
        this.previousChildKey = this.currentChildKey;
        this.currentChildKey = key;
        this.hideChild(this.previousChildKey, reset);
        this.showChild(this.currentChildKey, reset);
      } else {
        // Swap from current side to another side
        this.swapChild('panel', reset);
        this.swapChild(key, reset);
      }

      return this;
    },
    showPanel: function showPanel(reset) {
      this.swapChild('panel', reset);
      return this;
    },
    showLeftSide: function showLeftSide() {
      this.swapChild('leftSide');
      return this;
    },
    showRightSide: function showRightSide() {
      this.swapChild('rightSide');
      return this;
    },
    showTopSide: function showTopSide() {
      this.swapChild('topSide');
      return this;
    },
    showBottomSide: function showBottomSide() {
      this.swapChild('bottomSide');
      return this;
    },
    hideLeftSide: function hideLeftSide() {
      if (this.currentChildKey == 'leftSide') {
        this.showPanel();
      }

      return this;
    },
    hideRightSide: function hideRightSide() {
      if (this.currentChildKey == 'rightSide') {
        this.showPanel();
      }

      return this;
    },
    hideTopSide: function hideTopSide() {
      if (this.currentChildKey == 'topSide') {
        this.showPanel();
      }

      return this;
    },
    hideBottomSide: function hideBottomSide() {
      if (this.currentChildKey == 'bottomSide') {
        this.showPanel();
      }

      return this;
    },
    toggleLeftSide: function toggleLeftSide() {
      var key = this.currentChildKey !== 'panel' ? 'panel' : 'leftSide';
      this.swapChild(key);
      return this;
    },
    toggleRightSide: function toggleRightSide() {
      var key = this.currentChildKey !== 'panel' ? 'panel' : 'rightSide';
      this.swapChild(key);
      return this;
    },
    toggleTopSide: function toggleTopSide() {
      var key = this.currentChildKey !== 'panel' ? 'panel' : 'topSide';
      this.swapChild(key);
      return this;
    },
    toggleBottomSide: function toggleBottomSide() {
      var key = this.currentChildKey !== 'panel' ? 'panel' : 'bottomSide';
      this.swapChild(key);
      return this;
    }
  };

  var ContainerSetChildVisible = ContainerLite.prototype.setChildVisible;
  var Visible = {
    setChildVisible: function setChildVisible(child, visible) {
      var key;

      if (typeof child === 'string') {
        var key = child;
        child = this.sizerChildren[key];
      } else {
        key = IndexOf(this.sizerChildren, child);
      }

      if (visible === undefined) {
        visible = this.currentChildKey === key ? true : false;
      }

      ContainerSetChildVisible.call(this, child, visible);
      return this;
    }
  };

  var Fade = {
    fadeChild: function fadeChild(child, duration, alpha) {
      var key;

      if (typeof child === 'string') {
        key = child;
        child = this.sizerChildren[key];
      } else {
        key = IndexOf(this.sizerChildren, child);
      }

      if (duration === undefined) {
        duration = 500;
      }

      if (alpha === undefined) {
        alpha = this.currentChildKey === key ? 1 : 0;
      }

      child.fadeIn(duration, {
        start: child.alpha,
        end: alpha
      });
      return this;
    },
    fadeChildPromise: function fadeChildPromise(child, duration, alpha) {
      if (typeof child === 'string') {
        child = this.sizerChildren[key];
      }

      this.fadeChild(child, duration, alpha);

      if (child._fade) {
        return WaitComplete(child._fade);
      } else {
        return Promise.resolve();
      }
    }
  };

  var Move = {
    moveChild: function moveChild(child, duration, ease, distance) {
      var key;

      if (typeof child === 'string') {
        key = child;
        child = this.sizerChildren[key];
      } else {
        key = IndexOf(this.sizerChildren, child);
      }

      if (duration === undefined) {
        duration = 500;
      }

      var isShownChild = this.currentChildKey === key;

      if (distance === undefined) {
        switch (key) {
          case 'leftSide':
          case 'rightSide':
            distance = GetDisplayWidth(child);
            break;

          case 'topSide':
          case 'bottomSide':
            distance = GetDisplayHeight(child);
            break;

          default:
            // 'panel'
            if (isShownChild) {
              // Show panel
              switch (this.previousChildKey) {
                case 'leftSide':
                case 'rightSide':
                  distance = GetDisplayWidth(this.sizerChildren[this.previousChildKey]);
                  break;

                case 'topSide':
                case 'bottomSide':
                  distance = GetDisplayHeight(this.sizerChildren[this.previousChildKey]);
                  break;

                default:
                  distance = 0;
                  break;
              }
            } else {
              // Hide panel
              switch (this.currentChildKey) {
                case 'leftSide':
                case 'rightSide':
                  distance = GetDisplayWidth(this.sizerChildren[this.currentChildKey]);
                  break;

                case 'topSide':
                case 'bottomSide':
                  distance = GetDisplayHeight(this.sizerChildren[this.currentChildKey]);
                  break;

                default:
                  distance = 0;
                  break;
              }
            }

            break;
        }
      }

      var moveLeft, moveRight, moveUp, moveDown;

      if (isShownChild) {
        switch (key) {
          case 'panel':
            switch (this.previousChildKey) {
              case 'leftSide':
                moveLeft = true;
                break;

              case 'rightSide':
                moveRight = true;
                break;

              case 'topSide':
                moveUp = true;
                break;

              case 'bottomSide':
                moveDown = true;
                break;
            }

            break;

          case 'leftSide':
            moveRight = true;
            break;

          case 'rightSide':
            moveLeft = true;
            break;

          case 'topSide':
            moveDown = true;
            break;

          case 'bottomSide':
            moveUp = true;
            break;
        }
      } else {
        // Hide
        switch (key) {
          case 'panel':
            switch (this.currentChildKey) {
              case 'leftSide':
                moveRight = true;
                break;

              case 'rightSide':
                moveLeft = true;
                break;

              case 'topSide':
                moveDown = true;
                break;

              case 'bottomSide':
                moveUp = true;
                break;
            }

            break;

          case 'leftSide':
            moveLeft = true;
            break;

          case 'rightSide':
            moveRight = true;
            break;

          case 'topSide':
            moveUp = true;
            break;

          case 'bottomSide':
            moveDown = true;
            break;
        }
      }

      if (moveLeft) {
        child.moveTo(duration, "-=".concat(distance), undefined, ease);
      } else if (moveRight) {
        child.moveTo(duration, "+=".concat(distance), undefined, ease);
      } else if (moveUp) {
        child.moveTo(duration, undefined, "-=".concat(distance), ease);
      } else if (moveDown) {
        child.moveTo(duration, undefined, "+=".concat(distance), ease);
      } else {
        child.moveTo(0);
      }

      return this;
    },
    moveChildPromise: function moveChildPromise(child, duration, ease, distance) {
      if (typeof child === 'string') {
        child = this.sizerChildren[key];
      }

      this.moveChild(child, duration, ease, distance);

      if (child._easeMove) {
        return WaitComplete(child._easeMove);
      } else {
        return Promise.resolve();
      }
    }
  };

  var methods$1 = {};
  Object.assign(methods$1, Visible, Fade, Move);

  var GetValue$a = Phaser.Utils.Objects.GetValue;

  var Sides = /*#__PURE__*/function (_OverlapSizer) {
    _inherits(Sides, _OverlapSizer);

    var _super = _createSuper(Sides);

    function Sides(scene, config) {
      var _this;

      _classCallCheck(this, Sides);

      _this = _super.call(this, scene, config);
      _this.type = 'rexSides';
      _this.childrenMap = _this.sizerChildren;
      _this.previousChildKey = undefined;
      _this.currentChildKey = undefined; // Callbacks

      var showChildCallback = GetValue$a(config, 'showChildCallback', undefined);

      if (showChildCallback) {
        // Has showChildCallback, and hideChildCallback
        if (IsFunction(showChildCallback)) {
          // Custom callbacks
          var showChildCallbackScope = GetValue$a(config, 'showChildCallbackScope', undefined);

          _this.on('showchild', showChildCallback, showChildCallbackScope);

          var hideChildCallback = GetValue$a(config, 'hideChildCallback', undefined);
          var hideChildCallbackScope = GetValue$a(config, 'hideChildCallbackScope', undefined);

          _this.on('hidechild', hideChildCallback, hideChildCallbackScope);
        } else {
          // Default callbacks
          var defaultCallbacks = GetDefaultCallbacks(showChildCallback);

          _this.on('showchild', defaultCallbacks.show);

          _this.on('hidechild', defaultCallbacks.hide);
        }
      } // Add elements


      var background = GetValue$a(config, 'background', undefined);
      var panel = GetValue$a(config, 'panel', undefined);
      var leftSide = GetValue$a(config, 'leftSide', undefined);
      var rightSide = GetValue$a(config, 'rightSide', undefined);
      var topSide = GetValue$a(config, 'topSide', undefined);
      var bottomSide = GetValue$a(config, 'bottomSide', undefined);

      if (background) {
        _this.addBackground(background);
      }

      if (panel) {
        _this.add(panel, 'panel', 'center', 0, true);
      }

      if (leftSide) {
        var expand = GetValue$a(config, 'expand.left', true);

        _this.add(leftSide, 'leftSide', 'left-top', 0, {
          height: expand
        });
      }

      if (rightSide) {
        var expand = GetValue$a(config, 'expand.right', true);

        _this.add(rightSide, 'rightSide', 'right-top', 0, {
          height: expand
        });
      }

      if (topSide) {
        var expand = GetValue$a(config, 'expand.top', true);

        _this.add(topSide, 'topSide', 'left-top', 0, {
          width: expand
        });
      }

      if (bottomSide) {
        var expand = GetValue$a(config, 'expand.bottom', true);

        _this.add(bottomSide, 'bottomSide', 'left-bottom', 0, {
          width: expand
        });
      }

      return _this;
    }

    _createClass(Sides, [{
      key: "reset",
      value: function reset() {
        this.previousChildKey = undefined;
        this.currentChildKey = 'panel';
        this.showChild('panel', true);
        this.hideChild('leftSide', true);
        this.hideChild('rightSide', true);
        this.hideChild('topSide', true);
        this.hideChild('bottomSide', true);
        return this;
      }
    }]);

    return Sides;
  }(OverlapSizer);

  Object.assign(Sides.prototype, ShowChildMethods, methods$1);

  ObjectFactory.register('sides', function (config) {
    var gameObject = new Sides(this.scene, config);
    this.scene.add.existing(gameObject);
    return gameObject;
  });
  SetValue(window, 'RexPlugins.UI.Sides', Sides);

  ObjectFactory.register('click', function (gameObject, config) {
    return new Button(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Click', Button);

  ObjectFactory.register('clickOutside', function (gameObject, config) {
    return new ClickOutside(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.ClickOutside', ClickOutside);

  var GameObjectClass = Phaser.GameObjects.GameObject;

  var IsGameObject = function IsGameObject(object) {
    return object instanceof GameObjectClass;
  };

  ObjectFactory.register('tap', function (gameObject, config) {
    if (!IsGameObject(gameObject)) {
      config = gameObject;
      gameObject = this.scene;
    }

    return new Tap(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Tap', Tap);

  ObjectFactory.register('press', function (gameObject, config) {
    if (!IsGameObject(gameObject)) {
      config = gameObject;
      gameObject = this.scene;
    }

    return new Press(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Press', Press);

  ObjectFactory.register('swipe', function (gameObject, config) {
    if (!IsGameObject(gameObject)) {
      config = gameObject;
      gameObject = this.scene;
    }

    return new Swipe(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Swipe', Swipe);

  ObjectFactory.register('pan', function (gameObject, config) {
    if (!IsGameObject(gameObject)) {
      config = gameObject;
      gameObject = this.scene;
    }

    return new Pan(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Pan', Pan);

  var RequestDrag = function RequestDrag(gameObject) {
    var inputPlugin = gameObject.scene.input;
    var inputManager = inputPlugin.manager;
    var pointersTotal = inputManager.pointersTotal;
    var pointers = inputManager.pointers,
        pointer;

    for (var i = 0; i < pointersTotal; i++) {
      pointer = pointers[i];

      if (!pointer.primaryDown || inputPlugin.getDragState(pointer) !== 0 || !IsPointerInHitArea(gameObject, pointer)) {
        continue;
      } // For 3.18.0


      inputPlugin.setDragState(pointer, 1);
      inputPlugin._drag[pointer.id] = [gameObject];

      if (inputPlugin.dragDistanceThreshold === 0 || inputPlugin.dragTimeThreshold === 0) {
        //  No drag criteria, so snap immediately to mode 3
        inputPlugin.setDragState(pointer, 3);
        inputPlugin.processDragStartList(pointer);
      } else {
        //  Check the distance / time on the next event
        inputPlugin.setDragState(pointer, 2);
      } // For 3.18.0


      return true;
    }

    return false;
  };

  var GetValue$9 = Phaser.Utils.Objects.GetValue;
  var DistanceBetween = Phaser.Math.Distance.Between;
  var RotateAroundDistance = Phaser.Math.RotateAroundDistance;

  var Drag = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Drag, _ComponentBase);

    var _super = _createSuper(Drag);

    function Drag(gameObject, config) {
      var _this;

      _classCallCheck(this, Drag);

      _this = _super.call(this, gameObject, {
        eventEmitter: false
      }); // No event emitter
      // this.parent = gameObject;

      _this._enable = undefined;
      gameObject.setInteractive(GetValue$9(config, "inputConfig", undefined));

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(Drag, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        this.pointer = undefined;
        this.setEnable(GetValue$9(o, "enable", true));
        this.setAxisMode(GetValue$9(o, "axis", 0));
        this.setAxisRotation(GetValue$9(o, "rotation", 0));
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          enable: this.enable,
          axis: this.axisMode,
          rotation: this.axisRotation
        };
      }
    }, {
      key: "boot",
      value: function boot() {
        var gameObject = this.parent;
        gameObject.on('dragstart', this.onDragStart, this);
        gameObject.on('drag', this.onDrag, this);
        gameObject.on('dragend', this.onDragEnd, this);
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        } // GameObject events will be removed when this gameObject destroyed 
        // this.parent.on('dragstart', this.onDragStart, this);
        // this.parent.on('drag', this.onDrag, this);
        // this.parent.on('dragend', this.onDragEnd, this);


        this.pointer = undefined;

        _get(_getPrototypeOf(Drag.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "enable",
      get: function get() {
        return this._enable;
      },
      set: function set(e) {
        if (this._enable === e) {
          return;
        }

        if (!e) {
          this.dragend();
        }

        this._enable = e;
        this.scene.input.setDraggable(this.parent, e);
        return this;
      }
    }, {
      key: "setEnable",
      value: function setEnable(e) {
        if (e === undefined) {
          e = true;
        }

        this.enable = e;
        return this;
      }
    }, {
      key: "toggleEnable",
      value: function toggleEnable() {
        this.setEnable(!this.enable);
        return this;
      }
    }, {
      key: "setAxisMode",
      value: function setAxisMode(m) {
        if (typeof m === 'string') {
          m = DIRECTIONNODE[m];
        }

        this.axisMode = m;
        return this;
      }
    }, {
      key: "setAxisRotation",
      value: function setAxisRotation(a) {
        this.axisRotation = a;
        return this;
      }
    }, {
      key: "drag",
      value: function drag() {
        RequestDrag(this.parent);
        return this;
      }
    }, {
      key: "dragend",
      value: function dragend() {
        if (!this.isDragging) {
          return;
        }

        this.scene.input.setDragState(this.pointer, 5);
        return this;
      }
    }, {
      key: "onDragStart",
      value: function onDragStart(pointer, dragX, dragY) {
        if (this.isDragging) {
          return;
        }

        this.pointer = pointer;
      }
    }, {
      key: "onDrag",
      value: function onDrag(pointer, dragX, dragY) {
        if (this.pointer !== pointer) {
          return;
        }

        var gameObject = this.parent;

        if (this.axisMode === 0) {
          gameObject.x = dragX;
          gameObject.y = dragY;
        } else if (this.axisRotation === 0) {
          if (this.axisMode === 1) {
            gameObject.x = dragX;
          } else if (this.axisMode === 2) {
            gameObject.y = dragY;
          }
        } else {
          var dist;
          var p1 = {
            x: dragX,
            y: dragY
          };
          dist = DistanceBetween(p1.x, p1.y, gameObject.x, gameObject.y);
          p1 = RotateAroundDistance(p1, gameObject.x, gameObject.y, -this.axisRotation, dist);

          if (this.axisMode === 1) {
            p1.y = gameObject.y;
          } else if (this.axisMode === 2) {
            p1.x = gameObject.x;
          }

          dist = DistanceBetween(p1.x, p1.y, gameObject.x, gameObject.y);
          p1 = RotateAroundDistance(p1, gameObject.x, gameObject.y, this.axisRotation, dist);
          gameObject.x = p1.x;
          gameObject.y = p1.y;
        }
      }
    }, {
      key: "onDragEnd",
      value: function onDragEnd(pointer, dragX, dragY, dropped) {
        if (this.pointer !== pointer) {
          return;
        }

        this.pointer = undefined;
      }
    }, {
      key: "isDragging",
      get: function get() {
        return this.pointer !== undefined;
      }
    }]);

    return Drag;
  }(ComponentBase);

  var DIRECTIONNODE = {
    'both': 0,
    'h&v': 0,
    'x&y': 0,
    'horizontal': 1,
    'h': 1,
    'x': 1,
    'vertical': 2,
    'v': 2,
    'y': 2
  };

  ObjectFactory.register('drag', function (gameObject, config) {
    return new Drag(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Drag', Drag);

  ObjectFactory.register('pinch', function (config) {
    return new Pinch(this.scene, config);
  });
  SetValue(window, 'RexPlugins.UI.Pinch', Pinch);

  ObjectFactory.register('rotate', function (config) {
    return new Rotate(this.scene, config);
  });
  SetValue(window, 'RexPlugins.UI.Rotate', Rotate);

  var IsPlainObject$2 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$8 = Phaser.Utils.Objects.GetValue;

  var GetFrameUpdatingCallback = function GetFrameUpdatingCallback(key, frame, gameObject) {
    var callback;

    if (key === undefined) {
      key = gameObject.texture.key;
      frame = gameObject.frame.name;
    } else if (IsPlainObject$2(key)) {
      var config = key;
      key = GetValue$8(config, 'key', gameObject.texture.key);
      frame = GetValue$8(config, 'frame', gameObject.frame.name);
    } else if (typeof key === 'string') ; else {
      callback = key;
    }

    if (callback === undefined) {
      callback = function callback(gameObject) {
        gameObject.setTexture(key, frame);
      };
    }

    return callback;
  };

  var GetValue$7 = Phaser.Utils.Objects.GetValue;
  var GetAdvancedValue = Phaser.Utils.Objects.GetAdvancedValue;
  var Linear = Phaser.Math.Linear;

  var Flip = /*#__PURE__*/function (_EaseValueTaskBase) {
    _inherits(Flip, _EaseValueTaskBase);

    var _super = _createSuper(Flip);

    function Flip(gameObject, config) {
      var _this;

      _classCallCheck(this, Flip);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;
      // this.timer

      _this.resetFromJSON(config);

      _this.boot();

      return _this;
    }

    _createClass(Flip, [{
      key: "resetFromJSON",
      value: function resetFromJSON(o) {
        _get(_getPrototypeOf(Flip.prototype), "resetFromJSON", this).call(this, o);

        this.setDuration(GetAdvancedValue(o, 'duration', 500));
        this.setEase(GetValue$7(o, 'ease', 'Sine'));
        this.setOrientation(GetValue$7(o, 'orientation', 0));
        this.setFrontFace(GetValue$7(o, 'front', undefined));
        this.setBackFace(GetValue$7(o, 'back', undefined));
        this.setFace(GetValue$7(o, 'face', 0));
        return this;
      }
    }, {
      key: "setOrientation",
      value: function setOrientation(orientation) {
        if (typeof orientation === 'string') {
          orientation = ORIENTATIONMODE[orientation];
        }

        this.orientation = orientation;
        return this;
      }
    }, {
      key: "face",
      get: function get() {
        return this._face;
      },
      set: function set(face) {
        if (typeof face === 'string') {
          face = FACEMODE[face];
        }

        this._face = face;

        if (face === 0 && this.frontFaceCallback) {
          this.frontFaceCallback(this.parent);
        } else if (face === 1 && this.backFaceCallback) {
          this.backFaceCallback(this.parent);
        }
      }
    }, {
      key: "setFace",
      value: function setFace(face) {
        this.face = face;
        return this;
      }
    }, {
      key: "toggleFace",
      value: function toggleFace() {
        var newFace = this.face === 0 ? 1 : 0;
        this.setFace(newFace);
        return this;
      }
    }, {
      key: "setFrontFace",
      value: function setFrontFace(key, frame) {
        this.frontFaceCallback = GetFrameUpdatingCallback(key, frame, this.parent);
        return this;
      }
    }, {
      key: "setBackFace",
      value: function setBackFace(key, frame) {
        this.backFaceCallback = GetFrameUpdatingCallback(key, frame, this.parent);
        return this;
      }
    }, {
      key: "start",
      value: function start() {
        if (this.timer.isRunning) {
          return this;
        }

        this.timer.setDelay(this.delay).setDuration(this.duration / 2).setRepeat(1); // 2 times

        _get(_getPrototypeOf(Flip.prototype), "start", this).call(this);

        return this;
      }
    }, {
      key: "flip",
      value: function flip(duration) {
        if (this.isRunning) {
          return this;
        }

        if (duration !== undefined) {
          this.setDuration(duration);
        }

        this.start();
        return this;
      }
    }, {
      key: "updateGameObject",
      value: function updateGameObject(gameObject, timer) {
        if (timer.justRestart) {
          this.toggleFace();
        }

        var t = timer.t;

        if (timer.isOddIteration) {
          // Yoyo
          t = 1 - t;
        }

        t = this.easeFn(t);
        var value = Linear(1, 0, t);

        if (this.orientation === 0) {
          gameObject.scaleX = value;
        } else {
          gameObject.scaleY = value;
        }
      }
    }]);

    return Flip;
  }(EaseValueTaskBase);

  var ORIENTATIONMODE = {
    x: 0,
    horizontal: 0,
    y: 1,
    vertical: 1
  };
  var FACEMODE = {
    front: 0,
    back: 1
  };

  ObjectFactory.register('flip', function (gameObject, config) {
    return new Flip(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Flip', Flip);

  ObjectFactory.register('shake', function (gameObject, config) {
    return new ShakePosition(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Shake', ShakePosition);

  ObjectFactory.register('touchEventStop', function (gameObject, config) {
    return new TouchEventStop(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.TouchEventStop', TouchEventStop);

  var Vector3 = Phaser.Math.Vector3;
  var Matrix4 = Phaser.Math.Matrix4;
  var tempPosition = new Vector3();
  var tempRotation = new Vector3();
  var tempMatrix = new Matrix4();

  var TransformVerts = function TransformVerts(mesh, x, y, z, rotateX, rotateY, rotateZ) {
    if (x === undefined) {
      x = 0;
    }

    if (y === undefined) {
      y = 0;
    }

    if (z === undefined) {
      z = 0;
    }

    if (rotateX === undefined) {
      rotateX = 0;
    }

    if (rotateY === undefined) {
      rotateY = 0;
    }

    if (rotateZ === undefined) {
      rotateZ = 0;
    }

    tempPosition.set(x, y, z);
    tempRotation.set(rotateX, rotateY, rotateZ);
    tempMatrix.fromRotationXYTranslation(tempRotation, tempPosition, true);

    for (var i = 0, cnt = mesh.vertices.length; i < cnt; i++) {
      mesh.vertices[i].transformMat4(tempMatrix);
    }
  };

  var Mesh = Phaser.GameObjects.Mesh;
  var IsPlainObject$1 = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$6 = Phaser.Utils.Objects.GetValue;
  var GenerateGridVerts = Phaser.Geom.Mesh.GenerateGridVerts;
  var RadToDeg = Phaser.Math.RadToDeg;
  var DegToRad$1 = Phaser.Math.DegToRad;
  var FOV = 45;
  var PanZ = 1 + 1 / Math.sin(DegToRad$1(FOV));

  var Image$1 = /*#__PURE__*/function (_Mesh) {
    _inherits(Image, _Mesh);

    var _super = _createSuper(Image);

    function Image(scene, x, y, key, frame, config) {
      var _this;

      _classCallCheck(this, Image);

      if (IsPlainObject$1(x)) {
        config = x;
        x = GetValue$6(config, 'x', 0);
        y = GetValue$6(config, 'y', 0);
        key = GetValue$6(config, 'key', null);
        frame = GetValue$6(config, 'frame', null);
      }

      _this = _super.call(this, scene, x, y, key, frame);
      _this.type = 'rexPerspectiveImage';

      _this.setSizeToFrame();

      _this.resetPerspective();

      _this.panZ(PanZ);

      _this.hideCCW = GetValue$6(config, 'hideCCW', true);
      var gridWidth = GetValue$6(config, 'gridWidth', 32);
      var gridHeight = GetValue$6(config, 'gridHeight', gridWidth);

      _this.resetVerts(gridWidth, gridHeight);

      return _this;
    }

    _createClass(Image, [{
      key: "resetPerspective",
      value: function resetPerspective() {
        this.setPerspective(this.width, this.height, FOV);
        return this;
      }
    }, {
      key: "resetVerts",
      value: function resetVerts(gridWidth, gridHeight) {
        if (gridWidth !== undefined) {
          this.gridWidth = gridWidth;
        }

        if (gridHeight !== undefined) {
          this.gridHeight = gridHeight;
        } // Clear faces and vertices


        this.clear();
        this.dirtyCache[9] = -1;

        if (this.width === 0 || this.height === 0) {
          return this;
        } // Generate faces and vertices


        var frameWidth = this.frame.cutWidth,
            frameHeight = this.frame.cutHeight;
        GenerateGridVerts({
          mesh: this,
          texture: this.texture.key,
          frame: this.frame.name,
          width: frameWidth / this.height,
          height: frameHeight / this.height,
          widthSegments: Math.ceil(frameWidth / this.gridWidth),
          heightSegments: Math.ceil(frameHeight / this.gridHeight),
          flipY: this.frame.source.isRenderTexture
        });
        return this;
      }
    }, {
      key: "syncSize",
      value: function syncSize() {
        this.setSizeToFrame(); // Reset size

        this.resetPerspective(); // Reset perspective

        this.resetVerts(); // Reset verts

        return this;
      }
    }, {
      key: "rotationX",
      get: function get() {
        return this.modelRotation.x;
      },
      set: function set(value) {
        this.modelRotation.x = value;
      }
    }, {
      key: "angleX",
      get: function get() {
        return RadToDeg(this.rotationX);
      },
      set: function set(value) {
        this.rotationX = DegToRad$1(value);
      }
    }, {
      key: "rotationY",
      get: function get() {
        return this.modelRotation.y;
      },
      set: function set(value) {
        this.modelRotation.y = value;
      }
    }, {
      key: "angleY",
      get: function get() {
        return RadToDeg(this.rotationY);
      },
      set: function set(value) {
        this.rotationY = DegToRad$1(value);
      }
    }, {
      key: "rotationZ",
      get: function get() {
        return this.modelRotation.z;
      },
      set: function set(value) {
        this.modelRotation.z = value;
      }
    }, {
      key: "angleZ",
      get: function get() {
        return RadToDeg(this.rotationZ);
      },
      set: function set(value) {
        this.rotationZ = DegToRad$1(value);
      }
    }, {
      key: "transformVerts",
      value: function transformVerts(x, y, z, rotateX, rotateY, rotateZ) {
        TransformVerts(this, x, y, z, rotateX, rotateY, rotateZ);
        return this;
      }
    }, {
      key: "forceUpdate",
      value: function forceUpdate() {
        this.dirtyCache[10] = 1;
        return this;
      }
    }, {
      key: "tint",
      get: function get() {
        if (this.vertices.length === 0) {
          return 0xffffff;
        } else {
          return this.vertices[0].color;
        }
      },
      set: function set(value) {
        var vertices = this.vertices;

        for (var i = 0, cnt = vertices.length; i < cnt; i++) {
          vertices[i].color = value;
        }
      }
    }, {
      key: "setTint",
      value: function setTint(color) {
        this.tint = color;
        return this;
      }
    }]);

    return Image;
  }(Mesh);

  var RT = Phaser.GameObjects.RenderTexture;
  var IsPlainObject = Phaser.Utils.Objects.IsPlainObject;
  var GetValue$5 = Phaser.Utils.Objects.GetValue;

  var RenderTexture = /*#__PURE__*/function (_Image) {
    _inherits(RenderTexture, _Image);

    var _super = _createSuper(RenderTexture);

    function RenderTexture(scene, x, y, width, height, config) {
      var _this;

      _classCallCheck(this, RenderTexture);

      if (IsPlainObject(x)) {
        config = x;
        x = GetValue$5(config, 'x', 0);
        y = GetValue$5(config, 'y', 0);
        width = GetValue$5(config, 'width', 32);
        height = GetValue$5(config, 'height', 32);
      } // render-texture -> perspective-image


      var rt = new RT(scene, x, y, width, height).setOrigin(0.5);
      _this = _super.call(this, scene, x, y, rt.texture.key, null, config);
      _this.type = 'rexPerspectiveRenderTexture';
      _this.rt = rt;
      return _this;
    }

    _createClass(RenderTexture, [{
      key: "destroy",
      value: function destroy(fromScene) {
        _get(_getPrototypeOf(RenderTexture.prototype), "destroy", this).call(this, fromScene);

        this.rt.destroy();
        this.rt = null;
      }
    }]);

    return RenderTexture;
  }(Image$1);

  Phaser.Animations.AnimationState;
  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;

  Phaser.Math.RadToDeg;
  Phaser.Math.DegToRad;

  Phaser.Utils.Objects.IsPlainObject;

  var DegToRad = Phaser.Math.DegToRad;
  DegToRad(180);

  Phaser.Utils.Objects.GetValue;
  Phaser.Math.Linear;

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;

  Phaser.Utils.Objects.GetValue;
  Phaser.Math.RadToDeg;
  Phaser.Math.DegToRad;
  Phaser.Math.Angle.WrapDegrees;
  Phaser.Math.Angle.ShortestBetween;
  Phaser.Math.Wrap;
  Phaser.Math.Linear;

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;
  Phaser.Math.DegToRad;
  Phaser.Math.RadToDeg;
  Phaser.Math.Angle.WrapDegrees;
  Phaser.Math.Linear;
  Phaser.Math.Wrap;

  Phaser.Utils.Objects.IsPlainObject;
  Phaser.Utils.Objects.GetValue;
  Phaser.Math.Wrap;

  var Rectangle = Phaser.Geom.Rectangle;
  var Union = Phaser.Geom.Rectangle.Union;

  var GetBoundsOfGameObjects = function GetBoundsOfGameObjects(gameObjects, out) {
    if (out === undefined) {
      out = new Rectangle();
    } else if (out === true) {
      if (GlobRect === undefined) {
        GlobRect = new Rectangle();
      }

      out = GlobRect;
    }

    var gameObject;
    var firstClone = true;

    for (var i = 0, cnt = gameObjects.length; i < cnt; i++) {
      gameObject = gameObjects[i];

      if (!gameObject.getBounds) {
        continue;
      }

      var boundsRect = GetBounds(gameObject, true);

      if (firstClone) {
        out.setTo(boundsRect.x, boundsRect.y, boundsRect.width, boundsRect.height);
        firstClone = false;
      } else {
        Union(boundsRect, out, out);
      }
    }

    return out;
  };

  var GlobRect;

  var GetValue$4 = Phaser.Utils.Objects.GetValue;

  var Snapshot = function Snapshot(config) {
    var gameObjects = config.gameObjects;
    var renderTexture = config.renderTexture;

    if (gameObjects.length === 0) {
      if (renderTexture) {
        renderTexture.setSize(1, 1).clear();
      }

      return renderTexture;
    }

    var x = GetValue$4(config, 'x', undefined);
    var y = GetValue$4(config, 'y', undefined);
    var width = GetValue$4(config, 'width', undefined);
    var height = GetValue$4(config, 'height', undefined);
    var originX = GetValue$4(config, 'originX', 0);
    var originY = GetValue$4(config, 'originY', 0);
    var scrollX, scrollY;

    if (width === undefined || height === undefined || x === undefined || y === undefined) {
      // Union bounds of gameObjects
      var bounds = GetBoundsOfGameObjects(gameObjects, true);
      var isCenterOrigin = x !== undefined && y !== undefined;

      if (isCenterOrigin) {
        width = Math.max(x - bounds.left, bounds.right - x) * 2;
        height = Math.max(y - bounds.top, bounds.bottom - y) * 2;
        originX = 0.5;
        originY = 0.5;
      } else {
        x = bounds.x;
        y = bounds.y;
        width = bounds.width;
        height = bounds.height;
        originX = 0;
        originY = 0;
      }

      scrollX = bounds.x;
      scrollY = bounds.y;
    } else {
      scrollX = x + (0 - originX) * width;
      scrollY = y + (0 - originY) * height;
    } // Configurate render texture


    if (!renderTexture) {
      var scene = gameObjects[0].scene;
      renderTexture = scene.add.renderTexture(x, y, width, height);
    } else {
      renderTexture.setPosition(x, y);

      if (renderTexture.width !== width || renderTexture.height !== height) {
        renderTexture.setSize(width, height);
      }
    }

    renderTexture.setOrigin(originX, originY);
    renderTexture.camera.setScroll(scrollX, scrollY); // Draw gameObjects

    gameObjects = SortGameObjectsByDepth(Clone(gameObjects));
    renderTexture.draw(gameObjects);
    return renderTexture;
  };

  var ContainerAdd = ContainerLite.prototype.add;
  var GetValue$3 = Phaser.Utils.Objects.GetValue;

  var ContainerPerspective = /*#__PURE__*/function (_RenderTexture) {
    _inherits(ContainerPerspective, _RenderTexture);

    var _super = _createSuper(ContainerPerspective);

    function ContainerPerspective(parentContainer, config) {
      var _this;

      _classCallCheck(this, ContainerPerspective);

      var scene = parentContainer.scene;
      _this = _super.call(this, scene, parentContainer.x, parentContainer.y, 1, 1, config);
      scene.add.existing(_assertThisInitialized(_this));

      _this.setVisible(false);

      ContainerAdd.call(parentContainer, _assertThisInitialized(_this));
      _this.visibleSibling = [];
      _this.perspectiveState = false;
      _this.useParentBounds = GetValue$3(config, 'useParentBounds', false);

      _this.boot();

      return _this;
    }

    _createClass(ContainerPerspective, [{
      key: "boot",
      value: function boot() {
        this.rexContainer.parent.once('destroy', this.onParentDestroy, this);
      }
    }, {
      key: "destroy",
      value: function destroy(fromScene) {
        if (!this.scene) {
          return;
        }

        this.exit();
        this.rexContainer.parent.off('destroy', this.onParentDestroy, this);

        _get(_getPrototypeOf(ContainerPerspective.prototype), "destroy", this).call(this, fromScene);
      }
    }, {
      key: "onParentDestroy",
      value: function onParentDestroy(parent, fromScene) {
        this.destroy(fromScene);
      }
    }, {
      key: "enter",
      value: function enter() {
        this.exit();
        var parentContainer = this.rexContainer.parent; // Get and paste all visible children, which dose not include this render texture

        Snapshot({
          gameObjects: parentContainer.getAllVisibleChildren(),
          renderTexture: this.rt,
          x: this.x,
          y: this.y,
          width: this.useParentBounds ? parentContainer.displayWidth : undefined,
          height: this.useParentBounds ? parentContainer.displayHeighth : undefined,
          originX: this.useParentBounds ? parentContainer.originX : undefined,
          originY: this.useParentBounds ? parentContainer.originY : undefined
        });
        this.syncSize(); // Set this renderTexture to be visible

        parentContainer.setChildVisible(this, true); // Set visible sibling to be invisible

        parentContainer.children.forEach(function (child) {
          if (child !== this) {
            parentContainer.setChildVisible(child, false);
            this.visibleSibling.push(child);
          }
        }, this);
        this.perspectiveState = true;
        return this;
      }
    }, {
      key: "exit",
      value: function exit() {
        var parentContainer = this.rexContainer.parent; // Set all visible children to be visible back

        this.visibleSibling.forEach(function (child) {
          parentContainer.setChildVisible(child, true);
        }, this);
        this.visibleSibling.length = 0; // Set this renderTexture to be invisible        

        parentContainer.setChildVisible(this, false);
        this.perspectiveState = false;
        return this;
      }
    }]);

    return ContainerPerspective;
  }(RenderTexture);

  ObjectFactory.register('perspective', function (gameObject, config) {
    return new ContainerPerspective(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Perspective', ContainerPerspective);

  ObjectFactory.register('anchor', function (gameObject, config) {
    return new Anchor(gameObject, config);
  });
  SetValue(window, 'RexPlugins.UI.Anchor', Anchor);

  /*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */
  function isNothing(subject) {
    return (typeof subject === 'undefined') || (subject === null);
  }


  function isObject(subject) {
    return (typeof subject === 'object') && (subject !== null);
  }


  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;
    else if (isNothing(sequence)) return [];

    return [ sequence ];
  }


  function extend(target, source) {
    var index, length, key, sourceKeys;

    if (source) {
      sourceKeys = Object.keys(source);

      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }

    return target;
  }


  function repeat(string, count) {
    var result = '', cycle;

    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }

    return result;
  }


  function isNegativeZero(number) {
    return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
  }


  var isNothing_1      = isNothing;
  var isObject_1       = isObject;
  var toArray_1        = toArray;
  var repeat_1         = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1         = extend;

  var common = {
  	isNothing: isNothing_1,
  	isObject: isObject_1,
  	toArray: toArray_1,
  	repeat: repeat_1,
  	isNegativeZero: isNegativeZero_1,
  	extend: extend_1
  };

  // YAML error class. http://stackoverflow.com/questions/8458984


  function formatError(exception, compact) {
    var where = '', message = exception.reason || '(unknown reason)';

    if (!exception.mark) return message;

    if (exception.mark.name) {
      where += 'in "' + exception.mark.name + '" ';
    }

    where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';

    if (!compact && exception.mark.snippet) {
      where += '\n\n' + exception.mark.snippet;
    }

    return message + ' ' + where;
  }


  function YAMLException$1(reason, mark) {
    // Super constructor
    Error.call(this);

    this.name = 'YAMLException';
    this.reason = reason;
    this.mark = mark;
    this.message = formatError(this, false);

    // Include stack trace in error object
    if (Error.captureStackTrace) {
      // Chrome and NodeJS
      Error.captureStackTrace(this, this.constructor);
    } else {
      // FF, IE 10+ and Safari 6+. Fallback for others
      this.stack = (new Error()).stack || '';
    }
  }


  // Inherit from Error
  YAMLException$1.prototype = Object.create(Error.prototype);
  YAMLException$1.prototype.constructor = YAMLException$1;


  YAMLException$1.prototype.toString = function toString(compact) {
    return this.name + ': ' + formatError(this, compact);
  };


  var exception$1 = YAMLException$1;

  // get snippet for a single line, respecting maxLength
  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
    var head = '';
    var tail = '';
    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;

    if (position - lineStart > maxHalfLength) {
      head = ' ... ';
      lineStart = position - maxHalfLength + head.length;
    }

    if (lineEnd - position > maxHalfLength) {
      tail = ' ...';
      lineEnd = position + maxHalfLength - tail.length;
    }

    return {
      str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, '→') + tail,
      pos: position - lineStart + head.length // relative position
    };
  }


  function padStart(string, max) {
    return common.repeat(' ', max - string.length) + string;
  }


  function makeSnippet(mark, options) {
    options = Object.create(options || null);

    if (!mark.buffer) return null;

    if (!options.maxLength) options.maxLength = 79;
    if (typeof options.indent      !== 'number') options.indent      = 1;
    if (typeof options.linesBefore !== 'number') options.linesBefore = 3;
    if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;

    var re = /\r?\n|\r|\0/g;
    var lineStarts = [ 0 ];
    var lineEnds = [];
    var match;
    var foundLineNo = -1;

    while ((match = re.exec(mark.buffer))) {
      lineEnds.push(match.index);
      lineStarts.push(match.index + match[0].length);

      if (mark.position <= match.index && foundLineNo < 0) {
        foundLineNo = lineStarts.length - 2;
      }
    }

    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;

    var result = '', i, line;
    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);

    for (i = 1; i <= options.linesBefore; i++) {
      if (foundLineNo - i < 0) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo - i],
        lineEnds[foundLineNo - i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
        maxLineLength
      );
      result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +
        ' | ' + line.str + '\n' + result;
    }

    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
    result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +
      ' | ' + line.str + '\n';
    result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\n';

    for (i = 1; i <= options.linesAfter; i++) {
      if (foundLineNo + i >= lineEnds.length) break;
      line = getLine(
        mark.buffer,
        lineStarts[foundLineNo + i],
        lineEnds[foundLineNo + i],
        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
        maxLineLength
      );
      result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +
        ' | ' + line.str + '\n';
    }

    return result.replace(/\n$/, '');
  }


  var snippet = makeSnippet;

  var TYPE_CONSTRUCTOR_OPTIONS = [
    'kind',
    'multi',
    'resolve',
    'construct',
    'instanceOf',
    'predicate',
    'represent',
    'representName',
    'defaultStyle',
    'styleAliases'
  ];

  var YAML_NODE_KINDS = [
    'scalar',
    'sequence',
    'mapping'
  ];

  function compileStyleAliases(map) {
    var result = {};

    if (map !== null) {
      Object.keys(map).forEach(function (style) {
        map[style].forEach(function (alias) {
          result[String(alias)] = style;
        });
      });
    }

    return result;
  }

  function Type$1(tag, options) {
    options = options || {};

    Object.keys(options).forEach(function (name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception$1('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });

    // TODO: Add tag format check.
    this.options       = options; // keep original options in case user wants to extend this type later
    this.tag           = tag;
    this.kind          = options['kind']          || null;
    this.resolve       = options['resolve']       || function () { return true; };
    this.construct     = options['construct']     || function (data) { return data; };
    this.instanceOf    = options['instanceOf']    || null;
    this.predicate     = options['predicate']     || null;
    this.represent     = options['represent']     || null;
    this.representName = options['representName'] || null;
    this.defaultStyle  = options['defaultStyle']  || null;
    this.multi         = options['multi']         || false;
    this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);

    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception$1('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }

  var type = Type$1;

  /*eslint-disable max-len*/





  function compileList(schema, name) {
    var result = [];

    schema[name].forEach(function (currentType) {
      var newIndex = result.length;

      result.forEach(function (previousType, previousIndex) {
        if (previousType.tag === currentType.tag &&
            previousType.kind === currentType.kind &&
            previousType.multi === currentType.multi) {

          newIndex = previousIndex;
        }
      });

      result[newIndex] = currentType;
    });

    return result;
  }


  function compileMap(/* lists... */) {
    var result = {
          scalar: {},
          sequence: {},
          mapping: {},
          fallback: {},
          multi: {
            scalar: [],
            sequence: [],
            mapping: [],
            fallback: []
          }
        }, index, length;

    function collectType(type) {
      if (type.multi) {
        result.multi[type.kind].push(type);
        result.multi['fallback'].push(type);
      } else {
        result[type.kind][type.tag] = result['fallback'][type.tag] = type;
      }
    }

    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }


  function Schema$1(definition) {
    return this.extend(definition);
  }


  Schema$1.prototype.extend = function extend(definition) {
    var implicit = [];
    var explicit = [];

    if (definition instanceof type) {
      // Schema.extend(type)
      explicit.push(definition);

    } else if (Array.isArray(definition)) {
      // Schema.extend([ type1, type2, ... ])
      explicit = explicit.concat(definition);

    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
      // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })
      if (definition.implicit) implicit = implicit.concat(definition.implicit);
      if (definition.explicit) explicit = explicit.concat(definition.explicit);

    } else {
      throw new exception$1('Schema.extend argument should be a Type, [ Type ], ' +
        'or a schema definition ({ implicit: [...], explicit: [...] })');
    }

    implicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception$1('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }

      if (type$1.loadKind && type$1.loadKind !== 'scalar') {
        throw new exception$1('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
      }

      if (type$1.multi) {
        throw new exception$1('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');
      }
    });

    explicit.forEach(function (type$1) {
      if (!(type$1 instanceof type)) {
        throw new exception$1('Specified list of YAML types (or a single Type object) contains a non-Type object.');
      }
    });

    var result = Object.create(Schema$1.prototype);

    result.implicit = (this.implicit || []).concat(implicit);
    result.explicit = (this.explicit || []).concat(explicit);

    result.compiledImplicit = compileList(result, 'implicit');
    result.compiledExplicit = compileList(result, 'explicit');
    result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);

    return result;
  };


  var schema = Schema$1;

  var str = new type('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function (data) { return data !== null ? data : ''; }
  });

  var seq = new type('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function (data) { return data !== null ? data : []; }
  });

  var map = new type('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function (data) { return data !== null ? data : {}; }
  });

  var failsafe = new schema({
    explicit: [
      str,
      seq,
      map
    ]
  });

  function resolveYamlNull(data) {
    if (data === null) return true;

    var max = data.length;

    return (max === 1 && data === '~') ||
           (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
  }

  function constructYamlNull() {
    return null;
  }

  function isNull(object) {
    return object === null;
  }

  var _null = new type('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function () { return '~';    },
      lowercase: function () { return 'null'; },
      uppercase: function () { return 'NULL'; },
      camelcase: function () { return 'Null'; },
      empty:     function () { return '';     }
    },
    defaultStyle: 'lowercase'
  });

  function resolveYamlBoolean(data) {
    if (data === null) return false;

    var max = data.length;

    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
           (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
  }

  function constructYamlBoolean(data) {
    return data === 'true' ||
           data === 'True' ||
           data === 'TRUE';
  }

  function isBoolean(object) {
    return Object.prototype.toString.call(object) === '[object Boolean]';
  }

  var bool = new type('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function (object) { return object ? 'true' : 'false'; },
      uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
      camelcase: function (object) { return object ? 'True' : 'False'; }
    },
    defaultStyle: 'lowercase'
  });

  function isHexCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
           ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
           ((0x61/* a */ <= c) && (c <= 0x66/* f */));
  }

  function isOctCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
  }

  function isDecCode(c) {
    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
  }

  function resolveYamlInteger(data) {
    if (data === null) return false;

    var max = data.length,
        index = 0,
        hasDigits = false,
        ch;

    if (!max) return false;

    ch = data[index];

    // sign
    if (ch === '-' || ch === '+') {
      ch = data[++index];
    }

    if (ch === '0') {
      // 0
      if (index + 1 === max) return true;
      ch = data[++index];

      // base 2, base 8, base 16

      if (ch === 'b') {
        // base 2
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (ch !== '0' && ch !== '1') return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }


      if (ch === 'x') {
        // base 16
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }


      if (ch === 'o') {
        // base 8
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== '_';
      }
    }

    // base 10 (except 0)

    // value should not start with `_`;
    if (ch === '_') return false;

    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }

    // Should have digits and should not end with `_`
    if (!hasDigits || ch === '_') return false;

    return true;
  }

  function constructYamlInteger(data) {
    var value = data, sign = 1, ch;

    if (value.indexOf('_') !== -1) {
      value = value.replace(/_/g, '');
    }

    ch = value[0];

    if (ch === '-' || ch === '+') {
      if (ch === '-') sign = -1;
      value = value.slice(1);
      ch = value[0];
    }

    if (value === '0') return 0;

    if (ch === '0') {
      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
      if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);
      if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);
    }

    return sign * parseInt(value, 10);
  }

  function isInteger(object) {
    return (Object.prototype.toString.call(object)) === '[object Number]' &&
           (object % 1 === 0 && !common.isNegativeZero(object));
  }

  var int = new type('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
      octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },
      decimal:     function (obj) { return obj.toString(10); },
      /* eslint-disable max-len */
      hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary:      [ 2,  'bin' ],
      octal:       [ 8,  'oct' ],
      decimal:     [ 10, 'dec' ],
      hexadecimal: [ 16, 'hex' ]
    }
  });

  var YAML_FLOAT_PATTERN = new RegExp(
    // 2.5e4, 2.5 and integers
    '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
    // .2e4, .2
    // special case, seems not from spec
    '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
    // .inf
    '|[-+]?\\.(?:inf|Inf|INF)' +
    // .nan
    '|\\.(?:nan|NaN|NAN))$');

  function resolveYamlFloat(data) {
    if (data === null) return false;

    if (!YAML_FLOAT_PATTERN.test(data) ||
        // Quick hack to not allow integers end with `_`
        // Probably should update regexp & check speed
        data[data.length - 1] === '_') {
      return false;
    }

    return true;
  }

  function constructYamlFloat(data) {
    var value, sign;

    value  = data.replace(/_/g, '').toLowerCase();
    sign   = value[0] === '-' ? -1 : 1;

    if ('+-'.indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }

    if (value === '.inf') {
      return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

    } else if (value === '.nan') {
      return NaN;
    }
    return sign * parseFloat(value, 10);
  }


  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

  function representYamlFloat(object, style) {
    var res;

    if (isNaN(object)) {
      switch (style) {
        case 'lowercase': return '.nan';
        case 'uppercase': return '.NAN';
        case 'camelcase': return '.NaN';
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '.inf';
        case 'uppercase': return '.INF';
        case 'camelcase': return '.Inf';
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase': return '-.inf';
        case 'uppercase': return '-.INF';
        case 'camelcase': return '-.Inf';
      }
    } else if (common.isNegativeZero(object)) {
      return '-0.0';
    }

    res = object.toString(10);

    // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack

    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
  }

  function isFloat(object) {
    return (Object.prototype.toString.call(object) === '[object Number]') &&
           (object % 1 !== 0 || common.isNegativeZero(object));
  }

  var float = new type('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase'
  });

  var json = failsafe.extend({
    implicit: [
      _null,
      bool,
      int,
      float
    ]
  });

  var core = json;

  var YAML_DATE_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9])'                    + // [2] month
    '-([0-9][0-9])$');                   // [3] day

  var YAML_TIMESTAMP_REGEXP = new RegExp(
    '^([0-9][0-9][0-9][0-9])'          + // [1] year
    '-([0-9][0-9]?)'                   + // [2] month
    '-([0-9][0-9]?)'                   + // [3] day
    '(?:[Tt]|[ \\t]+)'                 + // ...
    '([0-9][0-9]?)'                    + // [4] hour
    ':([0-9][0-9])'                    + // [5] minute
    ':([0-9][0-9])'                    + // [6] second
    '(?:\\.([0-9]*))?'                 + // [7] fraction
    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
    '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }

  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0,
        delta = null, tz_hour, tz_minute, date;

    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

    if (match === null) throw new Error('Date resolve error');

    // match: [1] year [2] month [3] day

    year = +(match[1]);
    month = +(match[2]) - 1; // JS month starts with 0
    day = +(match[3]);

    if (!match[4]) { // no hour
      return new Date(Date.UTC(year, month, day));
    }

    // match: [4] hour [5] minute [6] second [7] fraction

    hour = +(match[4]);
    minute = +(match[5]);
    second = +(match[6]);

    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) { // milli-seconds
        fraction += '0';
      }
      fraction = +fraction;
    }

    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

    if (match[9]) {
      tz_hour = +(match[10]);
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
      if (match[9] === '-') delta = -delta;
    }

    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

    if (delta) date.setTime(date.getTime() - delta);

    return date;
  }

  function representYamlTimestamp(object /*, style*/) {
    return object.toISOString();
  }

  var timestamp = new type('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });

  function resolveYamlMerge(data) {
    return data === '<<' || data === null;
  }

  var merge = new type('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge
  });

  /*eslint-disable no-bitwise*/





  // [ 64, 65, 66 ] -> [ padding, CR, LF ]
  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


  function resolveYamlBinary(data) {
    if (data === null) return false;

    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

    // Convert one by one.
    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));

      // Skip CR/LF
      if (code > 64) continue;

      // Fail on illegal characters
      if (code < 0) return false;

      bitlen += 6;
    }

    // If there are any bits left, source was corrupted
    return (bitlen % 8) === 0;
  }

  function constructYamlBinary(data) {
    var idx, tailbits,
        input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
        max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = [];

    // Collect by 6*4 bits (3 bytes)

    for (idx = 0; idx < max; idx++) {
      if ((idx % 4 === 0) && idx) {
        result.push((bits >> 16) & 0xFF);
        result.push((bits >> 8) & 0xFF);
        result.push(bits & 0xFF);
      }

      bits = (bits << 6) | map.indexOf(input.charAt(idx));
    }

    // Dump tail

    tailbits = (max % 4) * 6;

    if (tailbits === 0) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    } else if (tailbits === 18) {
      result.push((bits >> 10) & 0xFF);
      result.push((bits >> 2) & 0xFF);
    } else if (tailbits === 12) {
      result.push((bits >> 4) & 0xFF);
    }

    return new Uint8Array(result);
  }

  function representYamlBinary(object /*, style*/) {
    var result = '', bits = 0, idx, tail,
        max = object.length,
        map = BASE64_MAP;

    // Convert every three bytes to 4 ASCII characters.

    for (idx = 0; idx < max; idx++) {
      if ((idx % 3 === 0) && idx) {
        result += map[(bits >> 18) & 0x3F];
        result += map[(bits >> 12) & 0x3F];
        result += map[(bits >> 6) & 0x3F];
        result += map[bits & 0x3F];
      }

      bits = (bits << 8) + object[idx];
    }

    // Dump tail

    tail = max % 3;

    if (tail === 0) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    } else if (tail === 2) {
      result += map[(bits >> 10) & 0x3F];
      result += map[(bits >> 4) & 0x3F];
      result += map[(bits << 2) & 0x3F];
      result += map[64];
    } else if (tail === 1) {
      result += map[(bits >> 2) & 0x3F];
      result += map[(bits << 4) & 0x3F];
      result += map[64];
      result += map[64];
    }

    return result;
  }

  function isBinary(obj) {
    return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';
  }

  var binary = new type('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });

  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var _toString$2       = Object.prototype.toString;

  function resolveYamlOmap(data) {
    if (data === null) return true;

    var objectKeys = [], index, length, pair, pairKey, pairHasKey,
        object = data;

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;

      if (_toString$2.call(pair) !== '[object Object]') return false;

      for (pairKey in pair) {
        if (_hasOwnProperty$3.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;
          else return false;
        }
      }

      if (!pairHasKey) return false;

      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
      else return false;
    }

    return true;
  }

  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }

  var omap = new type('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });

  var _toString$1 = Object.prototype.toString;

  function resolveYamlPairs(data) {
    if (data === null) return true;

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      if (_toString$1.call(pair) !== '[object Object]') return false;

      keys = Object.keys(pair);

      if (keys.length !== 1) return false;

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return true;
  }

  function constructYamlPairs(data) {
    if (data === null) return [];

    var index, length, pair, keys, result,
        object = data;

    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];

      keys = Object.keys(pair);

      result[index] = [ keys[0], pair[keys[0]] ];
    }

    return result;
  }

  var pairs = new type('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });

  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;

  function resolveYamlSet(data) {
    if (data === null) return true;

    var key, object = data;

    for (key in object) {
      if (_hasOwnProperty$2.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }

    return true;
  }

  function constructYamlSet(data) {
    return data !== null ? data : {};
  }

  var set = new type('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });

  var _default = core.extend({
    implicit: [
      timestamp,
      merge
    ],
    explicit: [
      binary,
      omap,
      pairs,
      set
    ]
  });

  /*eslint-disable max-len,no-use-before-define*/







  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;


  var CONTEXT_FLOW_IN   = 1;
  var CONTEXT_FLOW_OUT  = 2;
  var CONTEXT_BLOCK_IN  = 3;
  var CONTEXT_BLOCK_OUT = 4;


  var CHOMPING_CLIP  = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP  = 3;


  var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


  function _class(obj) { return Object.prototype.toString.call(obj); }

  function is_EOL(c) {
    return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
  }

  function is_WHITE_SPACE(c) {
    return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
  }

  function is_WS_OR_EOL(c) {
    return (c === 0x09/* Tab */) ||
           (c === 0x20/* Space */) ||
           (c === 0x0A/* LF */) ||
           (c === 0x0D/* CR */);
  }

  function is_FLOW_INDICATOR(c) {
    return c === 0x2C/* , */ ||
           c === 0x5B/* [ */ ||
           c === 0x5D/* ] */ ||
           c === 0x7B/* { */ ||
           c === 0x7D/* } */;
  }

  function fromHexCode(c) {
    var lc;

    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    /*eslint-disable no-bitwise*/
    lc = c | 0x20;

    if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
      return lc - 0x61 + 10;
    }

    return -1;
  }

  function escapedHexLen(c) {
    if (c === 0x78/* x */) { return 2; }
    if (c === 0x75/* u */) { return 4; }
    if (c === 0x55/* U */) { return 8; }
    return 0;
  }

  function fromDecimalCode(c) {
    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
      return c - 0x30;
    }

    return -1;
  }

  function simpleEscapeSequence(c) {
    /* eslint-disable indent */
    return (c === 0x30/* 0 */) ? '\x00' :
          (c === 0x61/* a */) ? '\x07' :
          (c === 0x62/* b */) ? '\x08' :
          (c === 0x74/* t */) ? '\x09' :
          (c === 0x09/* Tab */) ? '\x09' :
          (c === 0x6E/* n */) ? '\x0A' :
          (c === 0x76/* v */) ? '\x0B' :
          (c === 0x66/* f */) ? '\x0C' :
          (c === 0x72/* r */) ? '\x0D' :
          (c === 0x65/* e */) ? '\x1B' :
          (c === 0x20/* Space */) ? ' ' :
          (c === 0x22/* " */) ? '\x22' :
          (c === 0x2F/* / */) ? '/' :
          (c === 0x5C/* \ */) ? '\x5C' :
          (c === 0x4E/* N */) ? '\x85' :
          (c === 0x5F/* _ */) ? '\xA0' :
          (c === 0x4C/* L */) ? '\u2028' :
          (c === 0x50/* P */) ? '\u2029' : '';
  }

  function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
      return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode(
      ((c - 0x010000) >> 10) + 0xD800,
      ((c - 0x010000) & 0x03FF) + 0xDC00
    );
  }

  var simpleEscapeCheck = new Array(256); // integer, for fast access
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }


  function State$1(input, options) {
    this.input = input;

    this.filename  = options['filename']  || null;
    this.schema    = options['schema']    || _default;
    this.onWarning = options['onWarning'] || null;
    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents
    // if such documents have no explicit %YAML directive
    this.legacy    = options['legacy']    || false;

    this.json      = options['json']      || false;
    this.listener  = options['listener']  || null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap       = this.schema.compiledTypeMap;

    this.length     = input.length;
    this.position   = 0;
    this.line       = 0;
    this.lineStart  = 0;
    this.lineIndent = 0;

    // position of first leading tab in the current line,
    // used to make sure there are no tabs in the indentation
    this.firstTabInLine = -1;

    this.documents = [];

    /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/

  }


  function generateError(state, message) {
    var mark = {
      name:     state.filename,
      buffer:   state.input.slice(0, -1), // omit trailing \0
      position: state.position,
      line:     state.line,
      column:   state.position - state.lineStart
    };

    mark.snippet = snippet(mark);

    return new exception$1(message, mark);
  }

  function throwError(state, message) {
    throw generateError(state, message);
  }

  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }


  var directiveHandlers = {

    YAML: function handleYamlDirective(state, name, args) {

      var match, major, minor;

      if (state.version !== null) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (args.length !== 1) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (match === null) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (major !== 1) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = (minor < 2);

      if (minor !== 1 && minor !== 2) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },

    TAG: function handleTagDirective(state, name, args) {

      var handle, prefix;

      if (args.length !== 2) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty$1.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      try {
        prefix = decodeURIComponent(prefix);
      } catch (err) {
        throwError(state, 'tag prefix is malformed: ' + prefix);
      }

      state.tagMap[handle] = prefix;
    }
  };


  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;

    if (start < end) {
      _result = state.input.slice(start, end);

      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 0x09 ||
                (0x20 <= _character && _character <= 0x10FFFF))) {
            throwError(state, 'expected valid JSON character');
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, 'the stream contains non-printable characters');
      }

      state.result += _result;
    }
  }

  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;

    if (!common.isObject(source)) {
      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
    }

    sourceKeys = Object.keys(source);

    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];

      if (!_hasOwnProperty$1.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }

  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,
    startLine, startLineStart, startPos) {

    var index, quantity;

    // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);

      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, 'nested arrays are not supported inside keys');
        }

        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
          keyNode[index] = '[object Object]';
        }
      }
    }

    // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)
    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
      keyNode = '[object Object]';
    }


    keyNode = String(keyNode);

    if (_result === null) {
      _result = {};
    }

    if (keyTag === 'tag:yaml.org,2002:merge') {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json &&
          !_hasOwnProperty$1.call(overridableKeys, keyNode) &&
          _hasOwnProperty$1.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.lineStart = startLineStart || state.lineStart;
        state.position = startPos || state.position;
        throwError(state, 'duplicated mapping key');
      }

      // used for this specific key only because Object.defineProperty is slow
      if (keyNode === '__proto__') {
        Object.defineProperty(_result, keyNode, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: valueNode
        });
      } else {
        _result[keyNode] = valueNode;
      }
      delete overridableKeys[keyNode];
    }

    return _result;
  }

  function readLineBreak(state) {
    var ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x0A/* LF */) {
      state.position++;
    } else if (ch === 0x0D/* CR */) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
        state.position++;
      }
    } else {
      throwError(state, 'a line break is expected');
    }

    state.line += 1;
    state.lineStart = state.position;
    state.firstTabInLine = -1;
  }

  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {
          state.firstTabInLine = state.position;
        }
        ch = state.input.charCodeAt(++state.position);
      }

      if (allowComments && ch === 0x23/* # */) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
      }

      if (is_EOL(ch)) {
        readLineBreak(state);

        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;

        while (ch === 0x20/* Space */) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }

    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, 'deficient indentation');
    }

    return lineBreaks;
  }

  function testDocumentSeparator(state) {
    var _position = state.position,
        ch;

    ch = state.input.charCodeAt(_position);

    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
        ch === state.input.charCodeAt(_position + 1) &&
        ch === state.input.charCodeAt(_position + 2)) {

      _position += 3;

      ch = state.input.charCodeAt(_position);

      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }

    return false;
  }

  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += ' ';
    } else if (count > 1) {
      state.result += common.repeat('\n', count - 1);
    }
  }


  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (is_WS_OR_EOL(ch)      ||
        is_FLOW_INDICATOR(ch) ||
        ch === 0x23/* # */    ||
        ch === 0x26/* & */    ||
        ch === 0x2A/* * */    ||
        ch === 0x21/* ! */    ||
        ch === 0x7C/* | */    ||
        ch === 0x3E/* > */    ||
        ch === 0x27/* ' */    ||
        ch === 0x22/* " */    ||
        ch === 0x25/* % */    ||
        ch === 0x40/* @ */    ||
        ch === 0x60/* ` */) {
      return false;
    }

    if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }

    state.kind = 'scalar';
    state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;

    while (ch !== 0) {
      if (ch === 0x3A/* : */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) ||
            withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }

      } else if (ch === 0x23/* # */) {
        preceding = state.input.charCodeAt(state.position - 1);

        if (is_WS_OR_EOL(preceding)) {
          break;
        }

      } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
                 withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;

      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);

        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }

      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }

      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }

      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, captureEnd, false);

    if (state.result) {
      return true;
    }

    state.kind = _kind;
    state.result = _result;
    return false;
  }

  function readSingleQuotedScalar(state, nodeIndent) {
    var ch,
        captureStart, captureEnd;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x27/* ' */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x27/* ' */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (ch === 0x27/* ' */) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a single quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a single quoted scalar');
  }

  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart,
        captureEnd,
        hexLength,
        hexResult,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x22/* " */) {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x22/* " */) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;

      } else if (ch === 0x5C/* \ */) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);

        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);

          // TODO: rework to inline fn with no type cast?
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;

        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;

          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);

            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;

            } else {
              throwError(state, 'expected hexadecimal character');
            }
          }

          state.result += charFromCodepoint(hexResult);

          state.position++;

        } else {
          throwError(state, 'unknown escape sequence');
        }

        captureStart = captureEnd = state.position;

      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;

      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a double quoted scalar');

      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a double quoted scalar');
  }

  function readFlowCollection(state, nodeIndent) {
    var readNext = true,
        _line,
        _lineStart,
        _pos,
        _tag     = state.tag,
        _result,
        _anchor  = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = Object.create(null),
        keyNode,
        keyTag,
        valueNode,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x5B/* [ */) {
      terminator = 0x5D;/* ] */
      isMapping = false;
      _result = [];
    } else if (ch === 0x7B/* { */) {
      terminator = 0x7D;/* } */
      isMapping = true;
      _result = {};
    } else {
      return false;
    }

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(++state.position);

    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? 'mapping' : 'sequence';
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, 'missed comma between flow collection entries');
      } else if (ch === 0x2C/* , */) {
        // "flow collection entries can never be completely empty", as per YAML 1.2, section 7.4
        throwError(state, "expected the node content, but found ','");
      }

      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;

      if (ch === 0x3F/* ? */) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }

      _line = state.line; // Save the current line.
      _lineStart = state.lineStart;
      _pos = state.position;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }

      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
      } else {
        _result.push(keyNode);
      }

      skipSeparationSpace(state, true, nodeIndent);

      ch = state.input.charCodeAt(state.position);

      if (ch === 0x2C/* , */) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }

    throwError(state, 'unexpected end of the stream within a flow collection');
  }

  function readBlockScalar(state, nodeIndent) {
    var captureStart,
        folding,
        chomping       = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent     = nodeIndent,
        emptyLines     = 0,
        atMoreIndented = false,
        tmp,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x7C/* | */) {
      folding = false;
    } else if (ch === 0x3E/* > */) {
      folding = true;
    } else {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';

    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
        if (CHOMPING_CLIP === chomping) {
          chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, 'repeat of a chomping mode identifier');
        }

      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, 'repeat of an indentation width identifier');
        }

      } else {
        break;
      }
    }

    if (is_WHITE_SPACE(ch)) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (is_WHITE_SPACE(ch));

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (!is_EOL(ch) && (ch !== 0));
      }
    }

    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;

      ch = state.input.charCodeAt(state.position);

      while ((!detectedIndent || state.lineIndent < textIndent) &&
             (ch === 0x20/* Space */)) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }

      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }

      // End of the scalar.
      if (state.lineIndent < textIndent) {

        // Perform the chomping.
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) { // i.e. only if the scalar is not empty.
            state.result += '\n';
          }
        }

        // Break this `while` cycle and go to the funciton's epilogue.
        break;
      }

      // Folded style: use fancy rules to handle line breaks.
      if (folding) {

        // Lines starting with white space characters (more-indented lines) are not folded.
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          // except for the first content line (cf. Example 8.1)
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

        // End of more-indented block.
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat('\n', emptyLines + 1);

        // Just one line break - perceive as the same line.
        } else if (emptyLines === 0) {
          if (didReadContent) { // i.e. only if we have already read some scalar content.
            state.result += ' ';
          }

        // Several line breaks - perceive as different lines.
        } else {
          state.result += common.repeat('\n', emptyLines);
        }

      // Literal style: just add exact number of line breaks between content lines.
      } else {
        // Keep all line breaks except the header line break.
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      }

      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;

      while (!is_EOL(ch) && (ch !== 0)) {
        ch = state.input.charCodeAt(++state.position);
      }

      captureSegment(state, captureStart, state.position, false);
    }

    return true;
  }

  function readBlockSequence(state, nodeIndent) {
    var _line,
        _tag      = state.tag,
        _anchor   = state.anchor,
        _result   = [],
        following,
        detected  = false,
        ch;

    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, 'tab characters must not be used in indentation');
      }

      if (ch !== 0x2D/* - */) {
        break;
      }

      following = state.input.charCodeAt(state.position + 1);

      if (!is_WS_OR_EOL(following)) {
        break;
      }

      detected = true;
      state.position++;

      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
        throwError(state, 'bad indentation of a sequence entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'sequence';
      state.result = _result;
      return true;
    }
    return false;
  }

  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following,
        allowCompact,
        _line,
        _keyLine,
        _keyLineStart,
        _keyPos,
        _tag          = state.tag,
        _anchor       = state.anchor,
        _result       = {},
        overridableKeys = Object.create(null),
        keyTag        = null,
        keyNode       = null,
        valueNode     = null,
        atExplicitKey = false,
        detected      = false,
        ch;

    // there is a leading tab before this token, so it can't be a block sequence/mapping;
    // it can still be flow sequence/mapping or a scalar
    if (state.firstTabInLine !== -1) return false;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (!atExplicitKey && state.firstTabInLine !== -1) {
        state.position = state.firstTabInLine;
        throwError(state, 'tab characters must not be used in indentation');
      }

      following = state.input.charCodeAt(state.position + 1);
      _line = state.line; // Save the current line.

      //
      // Explicit notation case. There are two separate blocks:
      // first for the key (denoted by "?") and second for the value (denoted by ":")
      //
      if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

        if (ch === 0x3F/* ? */) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = true;
          allowCompact = true;

        } else if (atExplicitKey) {
          // i.e. 0x3A/* : */ === character after the explicit key.
          atExplicitKey = false;
          allowCompact = true;

        } else {
          throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
        }

        state.position += 1;
        ch = following;

      //
      // Implicit notation case. Flow-style node as the key first, then ":", and the value.
      //
      } else {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;

        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          // Neither implicit nor explicit notation.
          // Reading is done. Go to the epilogue.
          break;
        }

        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);

          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (ch === 0x3A/* : */) {
            ch = state.input.charCodeAt(++state.position);

            if (!is_WS_OR_EOL(ch)) {
              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
            }

            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;

          } else if (detected) {
            throwError(state, 'can not read an implicit mapping pair; a colon is missed');

          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true; // Keep the result of `composeNode`.
          }

        } else if (detected) {
          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      }

      //
      // Common reading code for both explicit and implicit notations.
      //
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (atExplicitKey) {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
        }

        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }

        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }

        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }

      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
        throwError(state, 'bad indentation of a mapping entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    //
    // Epilogue.
    //

    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
    }

    // Expose the resulting mapping.
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'mapping';
      state.result = _result;
    }

    return detected;
  }

  function readTagProperty(state) {
    var _position,
        isVerbatim = false,
        isNamed    = false,
        tagHandle,
        tagName,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x21/* ! */) return false;

    if (state.tag !== null) {
      throwError(state, 'duplication of a tag property');
    }

    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x3C/* < */) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);

    } else if (ch === 0x21/* ! */) {
      isNamed = true;
      tagHandle = '!!';
      ch = state.input.charCodeAt(++state.position);

    } else {
      tagHandle = '!';
    }

    _position = state.position;

    if (isVerbatim) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (ch !== 0 && ch !== 0x3E/* > */);

      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, 'unexpected end of the stream within a verbatim tag');
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {

        if (ch === 0x21/* ! */) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);

            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, 'named tag handle cannot contain such characters');
            }

            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, 'tag suffix cannot contain exclamation marks');
          }
        }

        ch = state.input.charCodeAt(++state.position);
      }

      tagName = state.input.slice(_position, state.position);

      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, 'tag suffix cannot contain flow indicator characters');
      }
    }

    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, 'tag name cannot contain such characters: ' + tagName);
    }

    try {
      tagName = decodeURIComponent(tagName);
    } catch (err) {
      throwError(state, 'tag name is malformed: ' + tagName);
    }

    if (isVerbatim) {
      state.tag = tagName;

    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;

    } else if (tagHandle === '!') {
      state.tag = '!' + tagName;

    } else if (tagHandle === '!!') {
      state.tag = 'tag:yaml.org,2002:' + tagName;

    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }

    return true;
  }

  function readAnchorProperty(state) {
    var _position,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x26/* & */) return false;

    if (state.anchor !== null) {
      throwError(state, 'duplication of an anchor property');
    }

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an anchor node must contain at least one character');
    }

    state.anchor = state.input.slice(_position, state.position);
    return true;
  }

  function readAlias(state) {
    var _position, alias,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x2A/* * */) return false;

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an alias node must contain at least one character');
    }

    alias = state.input.slice(_position, state.position);

    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }

    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }

  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
        atNewLine  = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        typeList,
        type,
        flowIndent,
        blockIndent;

    if (state.listener !== null) {
      state.listener('open', state);
    }

    state.tag    = null;
    state.anchor = null;
    state.kind   = null;
    state.result = null;

    allowBlockStyles = allowBlockScalars = allowBlockCollections =
      CONTEXT_BLOCK_OUT === nodeContext ||
      CONTEXT_BLOCK_IN  === nodeContext;

    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }

    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;

          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }

    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }

    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }

      blockIndent = state.position - state.lineStart;

      if (indentStatus === 1) {
        if (allowBlockCollections &&
            (readBlockSequence(state, blockIndent) ||
             readBlockMapping(state, blockIndent, flowIndent)) ||
            readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
              readSingleQuotedScalar(state, flowIndent) ||
              readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;

          } else if (readAlias(state)) {
            hasContent = true;

            if (state.tag !== null || state.anchor !== null) {
              throwError(state, 'alias node should not have any properties');
            }

          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;

            if (state.tag === null) {
              state.tag = '?';
            }
          }

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }

    if (state.tag === null) {
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }

    } else if (state.tag === '?') {
      // Implicit resolving is not allowed for non-scalar types, and '?'
      // non-specific tag is only automatically assigned to plain scalars.
      //
      // We only need to check kind conformity in case user explicitly assigns '?'
      // tag, for example like this: "!<?> [0]"
      //
      if (state.result !== null && state.kind !== 'scalar') {
        throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
      }

      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (state.tag !== '!') {
      if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
        type = state.typeMap[state.kind || 'fallback'][state.tag];
      } else {
        // looking for multi type
        type = null;
        typeList = state.typeMap.multi[state.kind || 'fallback'];

        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
            type = typeList[typeIndex];
            break;
          }
        }
      }

      if (!type) {
        throwError(state, 'unknown tag !<' + state.tag + '>');
      }

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result, state.tag);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    }

    if (state.listener !== null) {
      state.listener('close', state);
    }
    return state.tag !== null ||  state.anchor !== null || hasContent;
  }

  function readDocument(state) {
    var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;

    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = Object.create(null);
    state.anchorMap = Object.create(null);

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);

      ch = state.input.charCodeAt(state.position);

      if (state.lineIndent > 0 || ch !== 0x25/* % */) {
        break;
      }

      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];

      if (directiveName.length < 1) {
        throwError(state, 'directive name must not be less than one character in length');
      }

      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x23/* # */) {
          do { ch = state.input.charCodeAt(++state.position); }
          while (ch !== 0 && !is_EOL(ch));
          break;
        }

        if (is_EOL(ch)) break;

        _position = state.position;

        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        directiveArgs.push(state.input.slice(_position, state.position));
      }

      if (ch !== 0) readLineBreak(state);

      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }

    skipSeparationSpace(state, true, -1);

    if (state.lineIndent === 0 &&
        state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
        state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);

    } else if (hasDirectives) {
      throwError(state, 'directives end mark is expected');
    }

    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);

    if (state.checkLineBreaks &&
        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }

    state.documents.push(state.result);

    if (state.position === state.lineStart && testDocumentSeparator(state)) {

      if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }

    if (state.position < (state.length - 1)) {
      throwError(state, 'end of the stream or a document separator is expected');
    } else {
      return;
    }
  }


  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};

    if (input.length !== 0) {

      // Add tailing `\n` if not exists
      if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
          input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
        input += '\n';
      }

      // Strip BOM
      if (input.charCodeAt(0) === 0xFEFF) {
        input = input.slice(1);
      }
    }

    var state = new State$1(input, options);

    var nullpos = input.indexOf('\0');

    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, 'null byte is not allowed in input');
    }

    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += '\0';

    while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
      state.lineIndent += 1;
      state.position += 1;
    }

    while (state.position < (state.length - 1)) {
      readDocument(state);
    }

    return state.documents;
  }


  function loadAll$1(input, iterator, options) {
    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
      options = iterator;
      iterator = null;
    }

    var documents = loadDocuments(input, options);

    if (typeof iterator !== 'function') {
      return documents;
    }

    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }


  function load$1(input, options) {
    var documents = loadDocuments(input, options);

    if (documents.length === 0) {
      /*eslint-disable no-undefined*/
      return undefined;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new exception$1('expected a single document in the stream, but found more');
  }


  var loadAll_1 = loadAll$1;
  var load_1    = load$1;

  var loader = {
  	loadAll: loadAll_1,
  	load: load_1
  };

  /*eslint-disable no-use-before-define*/





  var _toString       = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;

  var CHAR_BOM                  = 0xFEFF;
  var CHAR_TAB                  = 0x09; /* Tab */
  var CHAR_LINE_FEED            = 0x0A; /* LF */
  var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */
  var CHAR_SPACE                = 0x20; /* Space */
  var CHAR_EXCLAMATION          = 0x21; /* ! */
  var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
  var CHAR_SHARP                = 0x23; /* # */
  var CHAR_PERCENT              = 0x25; /* % */
  var CHAR_AMPERSAND            = 0x26; /* & */
  var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
  var CHAR_ASTERISK             = 0x2A; /* * */
  var CHAR_COMMA                = 0x2C; /* , */
  var CHAR_MINUS                = 0x2D; /* - */
  var CHAR_COLON                = 0x3A; /* : */
  var CHAR_EQUALS               = 0x3D; /* = */
  var CHAR_GREATER_THAN         = 0x3E; /* > */
  var CHAR_QUESTION             = 0x3F; /* ? */
  var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
  var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
  var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
  var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
  var CHAR_VERTICAL_LINE        = 0x7C; /* | */
  var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

  var ESCAPE_SEQUENCES = {};

  ESCAPE_SEQUENCES[0x00]   = '\\0';
  ESCAPE_SEQUENCES[0x07]   = '\\a';
  ESCAPE_SEQUENCES[0x08]   = '\\b';
  ESCAPE_SEQUENCES[0x09]   = '\\t';
  ESCAPE_SEQUENCES[0x0A]   = '\\n';
  ESCAPE_SEQUENCES[0x0B]   = '\\v';
  ESCAPE_SEQUENCES[0x0C]   = '\\f';
  ESCAPE_SEQUENCES[0x0D]   = '\\r';
  ESCAPE_SEQUENCES[0x1B]   = '\\e';
  ESCAPE_SEQUENCES[0x22]   = '\\"';
  ESCAPE_SEQUENCES[0x5C]   = '\\\\';
  ESCAPE_SEQUENCES[0x85]   = '\\N';
  ESCAPE_SEQUENCES[0xA0]   = '\\_';
  ESCAPE_SEQUENCES[0x2028] = '\\L';
  ESCAPE_SEQUENCES[0x2029] = '\\P';

  var DEPRECATED_BOOLEANS_SYNTAX = [
    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
  ];

  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;

  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;

    if (map === null) return {};

    result = {};
    keys = Object.keys(map);

    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);

      if (tag.slice(0, 2) === '!!') {
        tag = 'tag:yaml.org,2002:' + tag.slice(2);
      }
      type = schema.compiledTypeMap['fallback'][tag];

      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }

      result[tag] = style;
    }

    return result;
  }

  function encodeHex(character) {
    var string, handle, length;

    string = character.toString(16).toUpperCase();

    if (character <= 0xFF) {
      handle = 'x';
      length = 2;
    } else if (character <= 0xFFFF) {
      handle = 'u';
      length = 4;
    } else if (character <= 0xFFFFFFFF) {
      handle = 'U';
      length = 8;
    } else {
      throw new exception$1('code point within a string may not be greater than 0xFFFFFFFF');
    }

    return '\\' + handle + common.repeat('0', length - string.length) + string;
  }


  var QUOTING_TYPE_SINGLE = 1,
      QUOTING_TYPE_DOUBLE = 2;

  function State$2(options) {
    this.schema        = options['schema'] || _default;
    this.indent        = Math.max(1, (options['indent'] || 2));
    this.noArrayIndent = options['noArrayIndent'] || false;
    this.skipInvalid   = options['skipInvalid'] || false;
    this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
    this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
    this.sortKeys      = options['sortKeys'] || false;
    this.lineWidth     = options['lineWidth'] || 80;
    this.noRefs        = options['noRefs'] || false;
    this.noCompatMode  = options['noCompatMode'] || false;
    this.condenseFlow  = options['condenseFlow'] || false;
    this.quotingType   = options['quotingType'] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
    this.forceQuotes   = options['forceQuotes'] || false;
    this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;

    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;

    this.tag = null;
    this.result = '';

    this.duplicates = [];
    this.usedDuplicates = null;
  }

  // Indents every line in a string. Empty lines (\n only) are not indented.
  function indentString(string, spaces) {
    var ind = common.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;

    while (position < length) {
      next = string.indexOf('\n', position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }

      if (line.length && line !== '\n') result += ind;

      result += line;
    }

    return result;
  }

  function generateNextLine(state, level) {
    return '\n' + common.repeat(' ', state.indent * level);
  }

  function testImplicitResolving(state, str) {
    var index, length, type;

    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];

      if (type.resolve(str)) {
        return true;
      }
    }

    return false;
  }

  // [33] s-white ::= s-space | s-tab
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }

  // Returns true if the character can be printed without escaping.
  // From YAML 1.2: "any allowed characters known to be non-printable
  // should also be escaped. [However,] This isn’t mandatory"
  // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
  function isPrintable(c) {
    return  (0x00020 <= c && c <= 0x00007E)
        || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
        || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)
        ||  (0x10000 <= c && c <= 0x10FFFF);
  }

  // [34] ns-char ::= nb-char - s-white
  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
  // [26] b-char  ::= b-line-feed | b-carriage-return
  // Including s-white (for some reason, examples doesn't match specs in this aspect)
  // ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark
  function isNsCharOrWhitespace(c) {
    return isPrintable(c)
      && c !== CHAR_BOM
      // - b-char
      && c !== CHAR_CARRIAGE_RETURN
      && c !== CHAR_LINE_FEED;
  }

  // [127]  ns-plain-safe(c) ::= c = flow-out  ⇒ ns-plain-safe-out
  //                             c = flow-in   ⇒ ns-plain-safe-in
  //                             c = block-key ⇒ ns-plain-safe-out
  //                             c = flow-key  ⇒ ns-plain-safe-in
  // [128] ns-plain-safe-out ::= ns-char
  // [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator
  // [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - “:” - “#” )
  //                            | ( /* An ns-char preceding */ “#” )
  //                            | ( “:” /* Followed by an ns-plain-safe(c) */ )
  function isPlainSafe(c, prev, inblock) {
    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
    return (
      // ns-plain-safe
      inblock ? // c = flow-in
        cIsNsCharOrWhitespace
        : cIsNsCharOrWhitespace
          // - c-flow-indicator
          && c !== CHAR_COMMA
          && c !== CHAR_LEFT_SQUARE_BRACKET
          && c !== CHAR_RIGHT_SQUARE_BRACKET
          && c !== CHAR_LEFT_CURLY_BRACKET
          && c !== CHAR_RIGHT_CURLY_BRACKET
    )
      // ns-plain-char
      && c !== CHAR_SHARP // false on '#'
      && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '
      || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'
      || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'
  }

  // Simplified test for values allowed as the first character in plain style.
  function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    // No support of ( ( “?” | “:” | “-” ) /* Followed by an ns-plain-safe(c)) */ ) part
    return isPrintable(c) && c !== CHAR_BOM
      && !isWhitespace(c) // - s-white
      // - (c-indicator ::=
      // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
      && c !== CHAR_MINUS
      && c !== CHAR_QUESTION
      && c !== CHAR_COLON
      && c !== CHAR_COMMA
      && c !== CHAR_LEFT_SQUARE_BRACKET
      && c !== CHAR_RIGHT_SQUARE_BRACKET
      && c !== CHAR_LEFT_CURLY_BRACKET
      && c !== CHAR_RIGHT_CURLY_BRACKET
      // | “#” | “&” | “*” | “!” | “|” | “=” | “>” | “'” | “"”
      && c !== CHAR_SHARP
      && c !== CHAR_AMPERSAND
      && c !== CHAR_ASTERISK
      && c !== CHAR_EXCLAMATION
      && c !== CHAR_VERTICAL_LINE
      && c !== CHAR_EQUALS
      && c !== CHAR_GREATER_THAN
      && c !== CHAR_SINGLE_QUOTE
      && c !== CHAR_DOUBLE_QUOTE
      // | “%” | “@” | “`”)
      && c !== CHAR_PERCENT
      && c !== CHAR_COMMERCIAL_AT
      && c !== CHAR_GRAVE_ACCENT;
  }

  // Simplified test for values allowed as the last character in plain style.
  function isPlainSafeLast(c) {
    // just not whitespace or colon, it will be checked to be plain character later
    return !isWhitespace(c) && c !== CHAR_COLON;
  }

  // Same as 'string'.codePointAt(pos), but works in older browsers.
  function codePointAt(string, pos) {
    var first = string.charCodeAt(pos), second;
    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {
      second = string.charCodeAt(pos + 1);
      if (second >= 0xDC00 && second <= 0xDFFF) {
        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
      }
    }
    return first;
  }

  // Determines whether block indentation indicator is required.
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }

  var STYLE_PLAIN   = 1,
      STYLE_SINGLE  = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED  = 4,
      STYLE_DOUBLE  = 5;

  // Determines which scalar styles are possible and returns the preferred style.
  // lineWidth = -1 => no limit.
  // Pre-conditions: str.length > 0.
  // Post-conditions:
  //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,
    testAmbiguousType, quotingType, forceQuotes, inblock) {

    var i;
    var char = 0;
    var prevChar = null;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly
    var plain = isPlainSafeFirst(codePointAt(string, 0))
            && isPlainSafeLast(codePointAt(string, string.length - 1));

    if (singleLineOnly || forceQuotes) {
      // Case: no block styles.
      // Check for disallowed characters to rule out plain and single.
      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
    } else {
      // Case: block styles permitted.
      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
        char = codePointAt(string, i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          // Check if any line can be folded.
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine ||
              // Foldable line = too long, and not more-indented.
              (i - previousLineBreak - 1 > lineWidth &&
               string[previousLineBreak + 1] !== ' ');
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char, prevChar, inblock);
        prevChar = char;
      }
      // in case the end is missing a \n
      hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
        (i - previousLineBreak - 1 > lineWidth &&
         string[previousLineBreak + 1] !== ' '));
    }
    // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.
    if (!hasLineBreak && !hasFoldableLine) {
      // Strings interpretable as another type have to be quoted;
      // e.g. the string 'true' vs. the boolean true.
      if (plain && !forceQuotes && !testAmbiguousType(string)) {
        return STYLE_PLAIN;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    // Edge case: block indentation indicator can only have one digit.
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.
    if (!forceQuotes) {
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }

  // Note: line breaking/folding is implemented for only the folded style.
  // NB. We drop the last trailing newline (if any) of a returned block scalar
  //  since the dumper adds its own newline. This always works:
  //    • No ending newline => unaffected; already using strip "-" chomping.
  //    • Ending newline    => removed then restored.
  //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
  function writeScalar(state, string, level, iskey, inblock) {
    state.dump = (function () {
      if (string.length === 0) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
      }
      if (!state.noCompatMode) {
        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? ('"' + string + '"') : ("'" + string + "'");
        }
      }

      var indent = state.indent * Math.max(1, level); // no 0-indent scalars
      // As indentation gets deeper, let the width decrease monotonically
      // to the lower bound min(state.lineWidth, 40).
      // Note that this implies
      //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
      // This behaves better than a constant minimum width which disallows narrower options,
      // or an indent threshold which causes the width to suddenly increase.
      var lineWidth = state.lineWidth === -1
        ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

      // Without knowing if keys are implicit/explicit, assume implicit for safety.
      var singleLineOnly = iskey
        // No block styles in flow mode.
        || (state.flowLevel > -1 && level >= state.flowLevel);
      function testAmbiguity(string) {
        return testImplicitResolving(state, string);
      }

      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,
        testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {

        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return '|' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return '>' + blockHeader(string, state.indent)
            + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';
        default:
          throw new exception$1('impossible error: invalid scalar style');
      }
    }());
  }

  // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

    // note the special case: the string '\n' counts as a "trailing" empty line.
    var clip =          string[string.length - 1] === '\n';
    var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
    var chomp = keep ? '+' : (clip ? '' : '-');

    return indentIndicator + chomp + '\n';
  }

  // (See the note for writeScalar.)
  function dropEndingNewline(string) {
    return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
  }

  // Note: a long line without a suitable break point will exceed the width limit.
  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
  function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g;

    // first line (possibly an empty line)
    var result = (function () {
      var nextLF = string.indexOf('\n');
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }());
    // If we haven't reached the first content line yet, don't add an extra \n.
    var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
    var moreIndented;

    // rest of the lines
    var match;
    while ((match = lineRe.exec(string))) {
      var prefix = match[1], line = match[2];
      moreIndented = (line[0] === ' ');
      result += prefix
        + (!prevMoreIndented && !moreIndented && line !== ''
          ? '\n' : '')
        + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }

    return result;
  }

  // Greedy line breaking.
  // Picks the longest line under the limit each time,
  // otherwise settles for the shortest line over the limit.
  // NB. More-indented lines *cannot* be folded, as that would add an extra \n.
  function foldLine(line, width) {
    if (line === '' || line[0] === ' ') return line;

    // Since a more-indented line adds a \n, breaks can't be followed by a space.
    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
    var match;
    // start is an inclusive index. end, curr, and next are exclusive.
    var start = 0, end, curr = 0, next = 0;
    var result = '';

    // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.
    while ((match = breakRe.exec(line))) {
      next = match.index;
      // maintain invariant: curr - start <= width
      if (next - start > width) {
        end = (curr > start) ? curr : next; // derive end <= length-2
        result += '\n' + line.slice(start, end);
        // skip the space that was output as \n
        start = end + 1;                    // derive start <= length-1
      }
      curr = next;
    }

    // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.
    result += '\n';
    // Insert a break if the remainder is too long and there is a break available.
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }

    return result.slice(1); // drop extra \n joiner
  }

  // Escapes a double-quoted string.
  function escapeString(string) {
    var result = '';
    var char = 0;
    var escapeSeq;

    for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {
      char = codePointAt(string, i);
      escapeSeq = ESCAPE_SEQUENCES[char];

      if (!escapeSeq && isPrintable(char)) {
        result += string[i];
        if (char >= 0x10000) result += string[i + 1];
      } else {
        result += escapeSeq || encodeHex(char);
      }
    }

    return result;
  }

  function writeFlowSequence(state, level, object) {
    var _result = '',
        _tag    = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }

      // Write only valid elements, put null instead of invalid elements.
      if (writeNode(state, level, value, false, false) ||
          (typeof value === 'undefined' &&
           writeNode(state, level, null, false, false))) {

        if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');
        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = '[' + _result + ']';
  }

  function writeBlockSequence(state, level, object, compact) {
    var _result = '',
        _tag    = state.tag,
        index,
        length,
        value;

    for (index = 0, length = object.length; index < length; index += 1) {
      value = object[index];

      if (state.replacer) {
        value = state.replacer.call(object, String(index), value);
      }

      // Write only valid elements, put null instead of invalid elements.
      if (writeNode(state, level + 1, value, true, true, false, true) ||
          (typeof value === 'undefined' &&
           writeNode(state, level + 1, null, true, true, false, true))) {

        if (!compact || _result !== '') {
          _result += generateNextLine(state, level);
        }

        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += '-';
        } else {
          _result += '- ';
        }

        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = _result || '[]'; // Empty sequence if no valid values.
  }

  function writeFlowMapping(state, level, object) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {

      pairBuffer = '';
      if (_result !== '') pairBuffer += ', ';

      if (state.condenseFlow) pairBuffer += '"';

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level, objectKey, false, false)) {
        continue; // Skip this pair because of invalid key;
      }

      if (state.dump.length > 1024) pairBuffer += '? ';

      pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

      if (!writeNode(state, level, objectValue, false, false)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = '{' + _result + '}';
  }

  function writeBlockMapping(state, level, object, compact) {
    var _result       = '',
        _tag          = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer;

    // Allow sorting keys so that the output file is deterministic
    if (state.sortKeys === true) {
      // Default sorting
      objectKeyList.sort();
    } else if (typeof state.sortKeys === 'function') {
      // Custom sort function
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      // Something is wrong
      throw new exception$1('sortKeys must be a boolean or a function');
    }

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';

      if (!compact || _result !== '') {
        pairBuffer += generateNextLine(state, level);
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (state.replacer) {
        objectValue = state.replacer.call(object, objectKey, objectValue);
      }

      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue; // Skip this pair because of invalid key.
      }

      explicitPair = (state.tag !== null && state.tag !== '?') ||
                     (state.dump && state.dump.length > 1024);

      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += '?';
        } else {
          pairBuffer += '? ';
        }
      }

      pairBuffer += state.dump;

      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }

      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue; // Skip this pair because of invalid value.
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ':';
      } else {
        pairBuffer += ': ';
      }

      pairBuffer += state.dump;

      // Both key and value are valid.
      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
  }

  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;

    typeList = explicit ? state.explicitTypes : state.implicitTypes;

    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];

      if ((type.instanceOf  || type.predicate) &&
          (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
          (!type.predicate  || type.predicate(object))) {

        if (explicit) {
          if (type.multi && type.representName) {
            state.tag = type.representName(object);
          } else {
            state.tag = type.tag;
          }
        } else {
          state.tag = '?';
        }

        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;

          if (_toString.call(type.represent) === '[object Function]') {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new exception$1('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
          }

          state.dump = _result;
        }

        return true;
      }
    }

    return false;
  }

  // Serializes `object` and writes it to global `result`.
  // Returns true on success, or false on invalid object.
  //
  function writeNode(state, level, object, block, compact, iskey, isblockseq) {
    state.tag = null;
    state.dump = object;

    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }

    var type = _toString.call(state.dump);
    var inblock = block;
    var tagStr;

    if (block) {
      block = (state.flowLevel < 0 || state.flowLevel > level);
    }

    var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;

    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }

    if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
      compact = false;
    }

    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = '*ref_' + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === '[object Object]') {
        if (block && (Object.keys(state.dump).length !== 0)) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object Array]') {
        if (block && (state.dump.length !== 0)) {
          if (state.noArrayIndent && !isblockseq && level > 0) {
            writeBlockSequence(state, level - 1, state.dump, compact);
          } else {
            writeBlockSequence(state, level, state.dump, compact);
          }
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, level, state.dump);
          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object String]') {
        if (state.tag !== '?') {
          writeScalar(state, state.dump, level, iskey, inblock);
        }
      } else if (type === '[object Undefined]') {
        return false;
      } else {
        if (state.skipInvalid) return false;
        throw new exception$1('unacceptable kind of an object to dump ' + type);
      }

      if (state.tag !== null && state.tag !== '?') {
        // Need to encode all characters except those allowed by the spec:
        //
        // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */
        // [36] ns-hex-digit    ::=  ns-dec-digit
        //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */
        // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */
        // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | “-”
        // [39] ns-uri-char     ::=  “%” ns-hex-digit ns-hex-digit | ns-word-char | “#”
        //                         | “;” | “/” | “?” | “:” | “@” | “&” | “=” | “+” | “$” | “,”
        //                         | “_” | “.” | “!” | “~” | “*” | “'” | “(” | “)” | “[” | “]”
        //
        // Also need to encode '!' because it has special meaning (end of tag prefix).
        //
        tagStr = encodeURI(
          state.tag[0] === '!' ? state.tag.slice(1) : state.tag
        ).replace(/!/g, '%21');

        if (state.tag[0] === '!') {
          tagStr = '!' + tagStr;
        } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {
          tagStr = '!!' + tagStr.slice(18);
        } else {
          tagStr = '!<' + tagStr + '>';
        }

        state.dump = tagStr + ' ' + state.dump;
      }
    }

    return true;
  }

  function getDuplicateReferences(object, state) {
    var objects = [],
        duplicatesIndexes = [],
        index,
        length;

    inspectNode(object, objects, duplicatesIndexes);

    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }

  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList,
        index,
        length;

    if (object !== null && typeof object === 'object') {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);

        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);

          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }

  function dump$1(input, options) {
    options = options || {};

    var state = new State$2(options);

    if (!state.noRefs) getDuplicateReferences(input, state);

    var value = input;

    if (state.replacer) {
      value = state.replacer.call({ '': value }, '', value);
    }

    if (writeNode(state, 0, value, true, true)) return state.dump + '\n';

    return '';
  }

  var dump_1 = dump$1;

  var dumper = {
  	dump: dump_1
  };

  function renamed(from, to) {
    return function () {
      throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +
        'Use yaml.' + to + ' instead, which is now safe by default.');
    };
  }


  var Type                = type;
  var Schema              = schema;
  var FAILSAFE_SCHEMA     = failsafe;
  var JSON_SCHEMA         = json;
  var CORE_SCHEMA         = core;
  var DEFAULT_SCHEMA      = _default;
  var load                = loader.load;
  var loadAll             = loader.loadAll;
  var dump                = dumper.dump;
  var YAMLException       = exception$1;

  // Re-export all types in case user wants to create custom schema
  var types = {
    binary:    binary,
    float:     float,
    map:       map,
    null:      _null,
    pairs:     pairs,
    set:       set,
    timestamp: timestamp,
    bool:      bool,
    int:       int,
    merge:     merge,
    omap:      omap,
    seq:       seq,
    str:       str
  };

  // Removed functions from JS-YAML 3.0.x
  var safeLoad            = renamed('safeLoad', 'load');
  var safeLoadAll         = renamed('safeLoadAll', 'loadAll');
  var safeDump            = renamed('safeDump', 'dump');

  var jsYaml = {
  	Type: Type,
  	Schema: Schema,
  	FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
  	JSON_SCHEMA: JSON_SCHEMA,
  	CORE_SCHEMA: CORE_SCHEMA,
  	DEFAULT_SCHEMA: DEFAULT_SCHEMA,
  	load: load,
  	loadAll: loadAll,
  	dump: dump,
  	YAMLException: YAMLException,
  	types: types,
  	safeLoad: safeLoad,
  	safeLoadAll: safeLoadAll,
  	safeDump: safeDump
  };

  var ParseYAML = function ParseYAML(s) {
    if (typeof s === 'string') {
      try {
        return jsYaml.load(s);
      } catch (e) {
        console.log(e);
        return undefined;
      }
    }

    return s;
  };

  var MergeStyle = function MergeStyle(data, styles) {
    if (styles === undefined) {
      return data;
    }

    if (data.hasOwnProperty('name')) {
      Merge(data, styles["#".concat(data.name)]);
    }

    if (data.hasOwnProperty('$class')) {
      var clasKeys = data.$class.split(' ');

      for (var i = 0, cnt = clasKeys.length; i < cnt; i++) {
        Merge(data, styles[".".concat(clasKeys[i])]);
      }
    }

    if (data.hasOwnProperty('$type')) {
      Merge(data, styles[data.$type]);
    }

    return data;
  };

  var Merge = function Merge(toObj, fromObj) {
    if (fromObj === undefined) {
      return toObj;
    }

    for (var key in fromObj) {
      if (!toObj.hasOwnProperty(key)) {
        toObj[key] = DeepClone(fromObj[key]);
      } else {
        var value = toObj[key];

        if (value && _typeof(value) === 'object') {
          Merge(value, fromObj[key]);
        }
      }
    }

    return toObj;
  };

  var PhaserImage = Phaser.GameObjects.Image;

  var CreateImage = function CreateImage(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles);
    var gameObject = new PhaserImage(scene, 0, 0, data.key, data.frame);

    if (data.width !== undefined) {
      gameObject.setDisplayWidth(data.width);
    }

    if (data.height !== undefined) {
      gameObject.setDisplayHeight(data.height);
    }

    scene.add.existing(gameObject);
    return gameObject;
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
  }

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  var utils = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.extend = extend;
  exports.indexOf = indexOf;
  exports.escapeExpression = escapeExpression;
  exports.isEmpty = isEmpty;
  exports.createFrame = createFrame;
  exports.blockParams = blockParams;
  exports.appendContextPath = appendContextPath;
  var escape = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;',
    '=': '&#x3D;'
  };

  var badChars = /[&<>"'`=]/g,
      possible = /[&<>"'`=]/;

  function escapeChar(chr) {
    return escape[chr];
  }

  function extend(obj /* , ...source */) {
    for (var i = 1; i < arguments.length; i++) {
      for (var key in arguments[i]) {
        if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
          obj[key] = arguments[i][key];
        }
      }
    }

    return obj;
  }

  var toString = Object.prototype.toString;

  exports.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  /* eslint-disable func-style */
  var isFunction = function isFunction(value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  /* istanbul ignore next */
  if (isFunction(/x/)) {
    exports.isFunction = isFunction = function (value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  exports.isFunction = isFunction;

  /* eslint-enable func-style */

  /* istanbul ignore next */
  var isArray = Array.isArray || function (value) {
    return value && typeof value === 'object' ? toString.call(value) === '[object Array]' : false;
  };

  exports.isArray = isArray;
  // Older IE versions do not directly support indexOf so we must implement our own, sadly.

  function indexOf(array, value) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  }

  function escapeExpression(string) {
    if (typeof string !== 'string') {
      // don't escape SafeStrings, since they're already safe
      if (string && string.toHTML) {
        return string.toHTML();
      } else if (string == null) {
        return '';
      } else if (!string) {
        return string + '';
      }

      // Force a string conversion as this will be done by the append regardless and
      // the regex test will do this transparently behind the scenes, causing issues if
      // an object's to string has escaped characters in it.
      string = '' + string;
    }

    if (!possible.test(string)) {
      return string;
    }
    return string.replace(badChars, escapeChar);
  }

  function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  function createFrame(object) {
    var frame = extend({}, object);
    frame._parent = object;
    return frame;
  }

  function blockParams(params, ids) {
    params.path = ids;
    return params;
  }

  function appendContextPath(contextPath, id) {
    return (contextPath ? contextPath + '.' : '') + id;
  }

  });

  unwrapExports(utils);
  utils.extend;
  utils.indexOf;
  utils.escapeExpression;
  utils.isEmpty;
  utils.createFrame;
  utils.blockParams;
  utils.appendContextPath;
  utils.isFunction;
  utils.isArray;

  var exception = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var errorProps = ['description', 'fileName', 'lineNumber', 'endLineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var loc = node && node.loc,
        line = undefined,
        endLineNumber = undefined,
        column = undefined,
        endColumn = undefined;

    if (loc) {
      line = loc.start.line;
      endLineNumber = loc.end.line;
      column = loc.start.column;
      endColumn = loc.end.column;

      message += ' - ' + line + ':' + column;
    }

    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    /* istanbul ignore else */
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, Exception);
    }

    try {
      if (loc) {
        this.lineNumber = line;
        this.endLineNumber = endLineNumber;

        // Work around issue under safari where we can't directly set the column value
        /* istanbul ignore next */
        if (Object.defineProperty) {
          Object.defineProperty(this, 'column', {
            value: column,
            enumerable: true
          });
          Object.defineProperty(this, 'endColumn', {
            value: endColumn,
            enumerable: true
          });
        } else {
          this.column = column;
          this.endColumn = endColumn;
        }
      }
    } catch (nop) {
      /* Ignore if the browser is very particular */
    }
  }

  Exception.prototype = new Error();

  exports['default'] = Exception;
  module.exports = exports['default'];

  });

  unwrapExports(exception);

  var blockHelperMissing = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  exports['default'] = function (instance) {
    instance.registerHelper('blockHelperMissing', function (context, options) {
      var inverse = options.inverse,
          fn = options.fn;

      if (context === true) {
        return fn(this);
      } else if (context === false || context == null) {
        return inverse(this);
      } else if (utils.isArray(context)) {
        if (context.length > 0) {
          if (options.ids) {
            options.ids = [options.name];
          }

          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        if (options.data && options.ids) {
          var data = utils.createFrame(options.data);
          data.contextPath = utils.appendContextPath(options.data.contextPath, options.name);
          options = { data: data };
        }

        return fn(context, options);
      }
    });
  };

  module.exports = exports['default'];

  });

  unwrapExports(blockHelperMissing);

  var each = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





  var _exception2 = _interopRequireDefault(exception);

  exports['default'] = function (instance) {
    instance.registerHelper('each', function (context, options) {
      if (!options) {
        throw new _exception2['default']('Must pass iterator to #each');
      }

      var fn = options.fn,
          inverse = options.inverse,
          i = 0,
          ret = '',
          data = undefined,
          contextPath = undefined;

      if (options.data && options.ids) {
        contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]) + '.';
      }

      if (utils.isFunction(context)) {
        context = context.call(this);
      }

      if (options.data) {
        data = utils.createFrame(options.data);
      }

      function execIteration(field, index, last) {
        if (data) {
          data.key = field;
          data.index = index;
          data.first = index === 0;
          data.last = !!last;

          if (contextPath) {
            data.contextPath = contextPath + field;
          }
        }

        ret = ret + fn(context[field], {
          data: data,
          blockParams: utils.blockParams([context[field], field], [contextPath + field, null])
        });
      }

      if (context && typeof context === 'object') {
        if (utils.isArray(context)) {
          for (var j = context.length; i < j; i++) {
            if (i in context) {
              execIteration(i, i, i === context.length - 1);
            }
          }
        } else if (commonjsGlobal.Symbol && context[commonjsGlobal.Symbol.iterator]) {
          var newContext = [];
          var iterator = context[commonjsGlobal.Symbol.iterator]();
          for (var it = iterator.next(); !it.done; it = iterator.next()) {
            newContext.push(it.value);
          }
          context = newContext;
          for (var j = context.length; i < j; i++) {
            execIteration(i, i, i === context.length - 1);
          }
        } else {
          (function () {
            var priorKey = undefined;

            Object.keys(context).forEach(function (key) {
              // We're running the iterations one step out of sync so we can detect
              // the last iteration without have to scan the object twice and create
              // an itermediate keys array.
              if (priorKey !== undefined) {
                execIteration(priorKey, i - 1);
              }
              priorKey = key;
              i++;
            });
            if (priorKey !== undefined) {
              execIteration(priorKey, i - 1, true);
            }
          })();
        }
      }

      if (i === 0) {
        ret = inverse(this);
      }

      return ret;
    });
  };

  module.exports = exports['default'];

  });

  unwrapExports(each);

  var helperMissing = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _exception2 = _interopRequireDefault(exception);

  exports['default'] = function (instance) {
    instance.registerHelper('helperMissing', function () /* [args, ]options */{
      if (arguments.length === 1) {
        // A missing field in a {{foo}} construct.
        return undefined;
      } else {
        // Someone is actually trying to call something, blow up.
        throw new _exception2['default']('Missing helper: "' + arguments[arguments.length - 1].name + '"');
      }
    });
  };

  module.exports = exports['default'];

  });

  unwrapExports(helperMissing);

  var _if = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





  var _exception2 = _interopRequireDefault(exception);

  exports['default'] = function (instance) {
    instance.registerHelper('if', function (conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2['default']('#if requires exactly one argument');
      }
      if (utils.isFunction(conditional)) {
        conditional = conditional.call(this);
      }

      // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
      if (!options.hash.includeZero && !conditional || utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });

    instance.registerHelper('unless', function (conditional, options) {
      if (arguments.length != 2) {
        throw new _exception2['default']('#unless requires exactly one argument');
      }
      return instance.helpers['if'].call(this, conditional, {
        fn: options.inverse,
        inverse: options.fn,
        hash: options.hash
      });
    });
  };

  module.exports = exports['default'];

  });

  unwrapExports(_if);

  var log = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports['default'] = function (instance) {
    instance.registerHelper('log', function () /* message, options */{
      var args = [undefined],
          options = arguments[arguments.length - 1];
      for (var i = 0; i < arguments.length - 1; i++) {
        args.push(arguments[i]);
      }

      var level = 1;
      if (options.hash.level != null) {
        level = options.hash.level;
      } else if (options.data && options.data.level != null) {
        level = options.data.level;
      }
      args[0] = level;

      instance.log.apply(instance, args);
    });
  };

  module.exports = exports['default'];

  });

  unwrapExports(log);

  var lookup = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports['default'] = function (instance) {
    instance.registerHelper('lookup', function (obj, field, options) {
      if (!obj) {
        // Note for 5.0: Change to "obj == null" in 5.0
        return obj;
      }
      return options.lookupProperty(obj, field);
    });
  };

  module.exports = exports['default'];

  });

  unwrapExports(lookup);

  var _with = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





  var _exception2 = _interopRequireDefault(exception);

  exports['default'] = function (instance) {
    instance.registerHelper('with', function (context, options) {
      if (arguments.length != 2) {
        throw new _exception2['default']('#with requires exactly one argument');
      }
      if (utils.isFunction(context)) {
        context = context.call(this);
      }

      var fn = options.fn;

      if (!utils.isEmpty(context)) {
        var data = options.data;
        if (options.data && options.ids) {
          data = utils.createFrame(options.data);
          data.contextPath = utils.appendContextPath(options.data.contextPath, options.ids[0]);
        }

        return fn(context, {
          data: data,
          blockParams: utils.blockParams([context], [data && data.contextPath])
        });
      } else {
        return options.inverse(this);
      }
    });
  };

  module.exports = exports['default'];

  });

  unwrapExports(_with);

  var helpers$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.registerDefaultHelpers = registerDefaultHelpers;
  exports.moveHelperToHooks = moveHelperToHooks;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _helpersBlockHelperMissing2 = _interopRequireDefault(blockHelperMissing);



  var _helpersEach2 = _interopRequireDefault(each);



  var _helpersHelperMissing2 = _interopRequireDefault(helperMissing);



  var _helpersIf2 = _interopRequireDefault(_if);



  var _helpersLog2 = _interopRequireDefault(log);



  var _helpersLookup2 = _interopRequireDefault(lookup);



  var _helpersWith2 = _interopRequireDefault(_with);

  function registerDefaultHelpers(instance) {
    _helpersBlockHelperMissing2['default'](instance);
    _helpersEach2['default'](instance);
    _helpersHelperMissing2['default'](instance);
    _helpersIf2['default'](instance);
    _helpersLog2['default'](instance);
    _helpersLookup2['default'](instance);
    _helpersWith2['default'](instance);
  }

  function moveHelperToHooks(instance, helperName, keepHelper) {
    if (instance.helpers[helperName]) {
      instance.hooks[helperName] = instance.helpers[helperName];
      if (!keepHelper) {
        delete instance.helpers[helperName];
      }
    }
  }

  });

  unwrapExports(helpers$1);
  helpers$1.registerDefaultHelpers;
  helpers$1.moveHelperToHooks;

  var inline = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  exports['default'] = function (instance) {
    instance.registerDecorator('inline', function (fn, props, container, options) {
      var ret = fn;
      if (!props.partials) {
        props.partials = {};
        ret = function (context, options) {
          // Create a new partials stack frame prior to exec.
          var original = container.partials;
          container.partials = utils.extend({}, original, props.partials);
          var ret = fn(context, options);
          container.partials = original;
          return ret;
        };
      }

      props.partials[options.args[0]] = options.fn;

      return ret;
    });
  };

  module.exports = exports['default'];

  });

  unwrapExports(inline);

  var decorators = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.registerDefaultDecorators = registerDefaultDecorators;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _decoratorsInline2 = _interopRequireDefault(inline);

  function registerDefaultDecorators(instance) {
    _decoratorsInline2['default'](instance);
  }

  });

  unwrapExports(decorators);
  decorators.registerDefaultDecorators;

  var logger_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var logger = {
    methodMap: ['debug', 'info', 'warn', 'error'],
    level: 'info',

    // Maps a given level value to the `methodMap` indexes above.
    lookupLevel: function lookupLevel(level) {
      if (typeof level === 'string') {
        var levelMap = utils.indexOf(logger.methodMap, level.toLowerCase());
        if (levelMap >= 0) {
          level = levelMap;
        } else {
          level = parseInt(level, 10);
        }
      }

      return level;
    },

    // Can be overridden in the host environment
    log: function log(level) {
      level = logger.lookupLevel(level);

      if (typeof console !== 'undefined' && logger.lookupLevel(logger.level) <= level) {
        var method = logger.methodMap[level];
        // eslint-disable-next-line no-console
        if (!console[method]) {
          method = 'log';
        }

        for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          message[_key - 1] = arguments[_key];
        }

        console[method].apply(console, message); // eslint-disable-line no-console
      }
    }
  };

  exports['default'] = logger;
  module.exports = exports['default'];

  });

  unwrapExports(logger_1);

  var createNewLookupObject_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.createNewLookupObject = createNewLookupObject;



  /**
   * Create a new object with "null"-prototype to avoid truthy results on prototype properties.
   * The resulting object can be used with "object[property]" to check if a property exists
   * @param {...object} sources a varargs parameter of source objects that will be merged
   * @returns {object}
   */

  function createNewLookupObject() {
    for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }

    return utils.extend.apply(undefined, [Object.create(null)].concat(sources));
  }

  });

  unwrapExports(createNewLookupObject_1);
  createNewLookupObject_1.createNewLookupObject;

  var protoAccess = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.createProtoAccessControl = createProtoAccessControl;
  exports.resultIsAllowed = resultIsAllowed;
  exports.resetLoggedProperties = resetLoggedProperties;
  // istanbul ignore next

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }





  var logger = _interopRequireWildcard(logger_1);

  var loggedProperties = Object.create(null);

  function createProtoAccessControl(runtimeOptions) {
    var defaultMethodWhiteList = Object.create(null);
    defaultMethodWhiteList['constructor'] = false;
    defaultMethodWhiteList['__defineGetter__'] = false;
    defaultMethodWhiteList['__defineSetter__'] = false;
    defaultMethodWhiteList['__lookupGetter__'] = false;

    var defaultPropertyWhiteList = Object.create(null);
    // eslint-disable-next-line no-proto
    defaultPropertyWhiteList['__proto__'] = false;

    return {
      properties: {
        whitelist: createNewLookupObject_1.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
        defaultValue: runtimeOptions.allowProtoPropertiesByDefault
      },
      methods: {
        whitelist: createNewLookupObject_1.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
        defaultValue: runtimeOptions.allowProtoMethodsByDefault
      }
    };
  }

  function resultIsAllowed(result, protoAccessControl, propertyName) {
    if (typeof result === 'function') {
      return checkWhiteList(protoAccessControl.methods, propertyName);
    } else {
      return checkWhiteList(protoAccessControl.properties, propertyName);
    }
  }

  function checkWhiteList(protoAccessControlForType, propertyName) {
    if (protoAccessControlForType.whitelist[propertyName] !== undefined) {
      return protoAccessControlForType.whitelist[propertyName] === true;
    }
    if (protoAccessControlForType.defaultValue !== undefined) {
      return protoAccessControlForType.defaultValue;
    }
    logUnexpecedPropertyAccessOnce(propertyName);
    return false;
  }

  function logUnexpecedPropertyAccessOnce(propertyName) {
    if (loggedProperties[propertyName] !== true) {
      loggedProperties[propertyName] = true;
      logger.log('error', 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\n' + 'You can add a runtime option to disable the check or this warning:\n' + 'See https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
    }
  }

  function resetLoggedProperties() {
    Object.keys(loggedProperties).forEach(function (propertyName) {
      delete loggedProperties[propertyName];
    });
  }

  });

  unwrapExports(protoAccess);
  protoAccess.createProtoAccessControl;
  protoAccess.resultIsAllowed;
  protoAccess.resetLoggedProperties;

  var base$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.HandlebarsEnvironment = HandlebarsEnvironment;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





  var _exception2 = _interopRequireDefault(exception);







  var _logger2 = _interopRequireDefault(logger_1);



  var VERSION = '4.7.7';
  exports.VERSION = VERSION;
  var COMPILER_REVISION = 8;
  exports.COMPILER_REVISION = COMPILER_REVISION;
  var LAST_COMPATIBLE_COMPILER_REVISION = 7;

  exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '== 1.0.0-rc.3',
    3: '== 1.0.0-rc.4',
    4: '== 1.x.x',
    5: '== 2.0.0-alpha.x',
    6: '>= 2.0.0-beta.1',
    7: '>= 4.0.0 <4.3.0',
    8: '>= 4.3.0'
  };

  exports.REVISION_CHANGES = REVISION_CHANGES;
  var objectType = '[object Object]';

  function HandlebarsEnvironment(helpers, partials, decorators$1) {
    this.helpers = helpers || {};
    this.partials = partials || {};
    this.decorators = decorators$1 || {};

    helpers$1.registerDefaultHelpers(this);
    decorators.registerDefaultDecorators(this);
  }

  HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,

    logger: _logger2['default'],
    log: _logger2['default'].log,

    registerHelper: function registerHelper(name, fn) {
      if (utils.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2['default']('Arg not supported with multiple helpers');
        }
        utils.extend(this.helpers, name);
      } else {
        this.helpers[name] = fn;
      }
    },
    unregisterHelper: function unregisterHelper(name) {
      delete this.helpers[name];
    },

    registerPartial: function registerPartial(name, partial) {
      if (utils.toString.call(name) === objectType) {
        utils.extend(this.partials, name);
      } else {
        if (typeof partial === 'undefined') {
          throw new _exception2['default']('Attempting to register a partial called "' + name + '" as undefined');
        }
        this.partials[name] = partial;
      }
    },
    unregisterPartial: function unregisterPartial(name) {
      delete this.partials[name];
    },

    registerDecorator: function registerDecorator(name, fn) {
      if (utils.toString.call(name) === objectType) {
        if (fn) {
          throw new _exception2['default']('Arg not supported with multiple decorators');
        }
        utils.extend(this.decorators, name);
      } else {
        this.decorators[name] = fn;
      }
    },
    unregisterDecorator: function unregisterDecorator(name) {
      delete this.decorators[name];
    },
    /**
     * Reset the memory of illegal property accesses that have already been logged.
     * @deprecated should only be used in handlebars test-cases
     */
    resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
      protoAccess.resetLoggedProperties();
    }
  };

  var log = _logger2['default'].log;

  exports.log = log;
  exports.createFrame = utils.createFrame;
  exports.logger = _logger2['default'];

  });

  unwrapExports(base$1);
  base$1.HandlebarsEnvironment;
  base$1.VERSION;
  base$1.COMPILER_REVISION;
  base$1.LAST_COMPATIBLE_COMPILER_REVISION;
  base$1.REVISION_CHANGES;
  base$1.log;
  base$1.createFrame;
  base$1.logger;

  var safeString = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = SafeString.prototype.toHTML = function () {
    return '' + this.string;
  };

  exports['default'] = SafeString;
  module.exports = exports['default'];

  });

  unwrapExports(safeString);

  var wrapHelper_1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.wrapHelper = wrapHelper;

  function wrapHelper(helper, transformOptionsFn) {
    if (typeof helper !== 'function') {
      // This should not happen, but apparently it does in https://github.com/wycats/handlebars.js/issues/1639
      // We try to make the wrapper least-invasive by not wrapping it, if the helper is not a function.
      return helper;
    }
    var wrapper = function wrapper() /* dynamic arguments */{
      var options = arguments[arguments.length - 1];
      arguments[arguments.length - 1] = transformOptionsFn(options);
      return helper.apply(this, arguments);
    };
    return wrapper;
  }

  });

  unwrapExports(wrapHelper_1);
  wrapHelper_1.wrapHelper;

  var runtime = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.checkRevision = checkRevision;
  exports.template = template;
  exports.wrapProgram = wrapProgram;
  exports.resolvePartial = resolvePartial;
  exports.invokePartial = invokePartial;
  exports.noop = noop;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  // istanbul ignore next

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }



  var Utils = _interopRequireWildcard(utils);



  var _exception2 = _interopRequireDefault(exception);









  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = base$1.COMPILER_REVISION;

    if (compilerRevision >= base$1.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= base$1.COMPILER_REVISION) {
      return;
    }

    if (compilerRevision < base$1.LAST_COMPATIBLE_COMPILER_REVISION) {
      var runtimeVersions = base$1.REVISION_CHANGES[currentRevision],
          compilerVersions = base$1.REVISION_CHANGES[compilerRevision];
      throw new _exception2['default']('Template was precompiled with an older version of Handlebars than the current runtime. ' + 'Please update your precompiler to a newer version (' + runtimeVersions + ') or downgrade your runtime to an older version (' + compilerVersions + ').');
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new _exception2['default']('Template was precompiled with a newer version of Handlebars than the current runtime. ' + 'Please update your runtime to a newer version (' + compilerInfo[1] + ').');
    }
  }

  function template(templateSpec, env) {
    /* istanbul ignore next */
    if (!env) {
      throw new _exception2['default']('No environment passed to template');
    }
    if (!templateSpec || !templateSpec.main) {
      throw new _exception2['default']('Unknown template object: ' + typeof templateSpec);
    }

    templateSpec.main.decorator = templateSpec.main_d;

    // Note: Using env.VM references rather than local var references throughout this section to allow
    // for external users to override these as pseudo-supported APIs.
    env.VM.checkRevision(templateSpec.compiler);

    // backwards compatibility for precompiled templates with compiler-version 7 (<4.3.0)
    var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;

    function invokePartialWrapper(partial, context, options) {
      if (options.hash) {
        context = Utils.extend({}, context, options.hash);
        if (options.ids) {
          options.ids[0] = true;
        }
      }
      partial = env.VM.resolvePartial.call(this, partial, context, options);

      var extendedOptions = Utils.extend({}, options, {
        hooks: this.hooks,
        protoAccessControl: this.protoAccessControl
      });

      var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);

      if (result == null && env.compile) {
        options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
        result = options.partials[options.name](context, extendedOptions);
      }
      if (result != null) {
        if (options.indent) {
          var lines = result.split('\n');
          for (var i = 0, l = lines.length; i < l; i++) {
            if (!lines[i] && i + 1 === l) {
              break;
            }

            lines[i] = options.indent + lines[i];
          }
          result = lines.join('\n');
        }
        return result;
      } else {
        throw new _exception2['default']('The partial ' + options.name + ' could not be compiled when running in runtime-only mode');
      }
    }

    // Just add water
    var container = {
      strict: function strict(obj, name, loc) {
        if (!obj || !(name in obj)) {
          throw new _exception2['default']('"' + name + '" not defined in ' + obj, {
            loc: loc
          });
        }
        return container.lookupProperty(obj, name);
      },
      lookupProperty: function lookupProperty(parent, propertyName) {
        var result = parent[propertyName];
        if (result == null) {
          return result;
        }
        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
          return result;
        }

        if (protoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
          return result;
        }
        return undefined;
      },
      lookup: function lookup(depths, name) {
        var len = depths.length;
        for (var i = 0; i < len; i++) {
          var result = depths[i] && container.lookupProperty(depths[i], name);
          if (result != null) {
            return depths[i][name];
          }
        }
      },
      lambda: function lambda(current, context) {
        return typeof current === 'function' ? current.call(context) : current;
      },

      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,

      fn: function fn(i) {
        var ret = templateSpec[i];
        ret.decorator = templateSpec[i + '_d'];
        return ret;
      },

      programs: [],
      program: function program(i, data, declaredBlockParams, blockParams, depths) {
        var programWrapper = this.programs[i],
            fn = this.fn(i);
        if (data || depths || blockParams || declaredBlockParams) {
          programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = wrapProgram(this, i, fn);
        }
        return programWrapper;
      },

      data: function data(value, depth) {
        while (value && depth--) {
          value = value._parent;
        }
        return value;
      },
      mergeIfNeeded: function mergeIfNeeded(param, common) {
        var obj = param || common;

        if (param && common && param !== common) {
          obj = Utils.extend({}, common, param);
        }

        return obj;
      },
      // An empty object to use as replacement for null-contexts
      nullContext: Object.seal({}),

      noop: env.VM.noop,
      compilerInfo: templateSpec.compiler
    };

    function ret(context) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var data = options.data;

      ret._setup(options);
      if (!options.partial && templateSpec.useData) {
        data = initData(context, data);
      }
      var depths = undefined,
          blockParams = templateSpec.useBlockParams ? [] : undefined;
      if (templateSpec.useDepths) {
        if (options.depths) {
          depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
        } else {
          depths = [context];
        }
      }

      function main(context /*, options*/) {
        return '' + templateSpec.main(container, context, container.helpers, container.partials, data, blockParams, depths);
      }

      main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
      return main(context, options);
    }

    ret.isTop = true;

    ret._setup = function (options) {
      if (!options.partial) {
        var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
        wrapHelpersToPassLookupProperty(mergedHelpers, container);
        container.helpers = mergedHelpers;

        if (templateSpec.usePartial) {
          // Use mergeIfNeeded here to prevent compiling global partials multiple times
          container.partials = container.mergeIfNeeded(options.partials, env.partials);
        }
        if (templateSpec.usePartial || templateSpec.useDecorators) {
          container.decorators = Utils.extend({}, env.decorators, options.decorators);
        }

        container.hooks = {};
        container.protoAccessControl = protoAccess.createProtoAccessControl(options);

        var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
        helpers$1.moveHelperToHooks(container, 'helperMissing', keepHelperInHelpers);
        helpers$1.moveHelperToHooks(container, 'blockHelperMissing', keepHelperInHelpers);
      } else {
        container.protoAccessControl = options.protoAccessControl; // internal option
        container.helpers = options.helpers;
        container.partials = options.partials;
        container.decorators = options.decorators;
        container.hooks = options.hooks;
      }
    };

    ret._child = function (i, data, blockParams, depths) {
      if (templateSpec.useBlockParams && !blockParams) {
        throw new _exception2['default']('must pass block params');
      }
      if (templateSpec.useDepths && !depths) {
        throw new _exception2['default']('must pass parent depths');
      }

      return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
    };
    return ret;
  }

  function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
    function prog(context) {
      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      var currentDepths = depths;
      if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
        currentDepths = [context].concat(depths);
      }

      return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
    }

    prog = executeDecorators(fn, prog, container, depths, data, blockParams);

    prog.program = i;
    prog.depth = depths ? depths.length : 0;
    prog.blockParams = declaredBlockParams || 0;
    return prog;
  }

  /**
   * This is currently part of the official API, therefore implementation details should not be changed.
   */

  function resolvePartial(partial, context, options) {
    if (!partial) {
      if (options.name === '@partial-block') {
        partial = options.data['partial-block'];
      } else {
        partial = options.partials[options.name];
      }
    } else if (!partial.call && !options.name) {
      // This is a dynamic partial that returned a string
      options.name = partial;
      partial = options.partials[partial];
    }
    return partial;
  }

  function invokePartial(partial, context, options) {
    // Use the current closure context to save the partial-block if this partial
    var currentPartialBlock = options.data && options.data['partial-block'];
    options.partial = true;
    if (options.ids) {
      options.data.contextPath = options.ids[0] || options.data.contextPath;
    }

    var partialBlock = undefined;
    if (options.fn && options.fn !== noop) {
      (function () {
        options.data = base$1.createFrame(options.data);
        // Wrapper function to get access to currentPartialBlock from the closure
        var fn = options.fn;
        partialBlock = options.data['partial-block'] = function partialBlockWrapper(context) {
          var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

          // Restore the partial-block from the closure for the execution of the block
          // i.e. the part inside the block of the partial call.
          options.data = base$1.createFrame(options.data);
          options.data['partial-block'] = currentPartialBlock;
          return fn(context, options);
        };
        if (fn.partials) {
          options.partials = Utils.extend({}, options.partials, fn.partials);
        }
      })();
    }

    if (partial === undefined && partialBlock) {
      partial = partialBlock;
    }

    if (partial === undefined) {
      throw new _exception2['default']('The partial ' + options.name + ' could not be found');
    } else if (partial instanceof Function) {
      return partial(context, options);
    }
  }

  function noop() {
    return '';
  }

  function initData(context, data) {
    if (!data || !('root' in data)) {
      data = data ? base$1.createFrame(data) : {};
      data.root = context;
    }
    return data;
  }

  function executeDecorators(fn, prog, container, depths, data, blockParams) {
    if (fn.decorator) {
      var props = {};
      prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
      Utils.extend(prog, props);
    }
    return prog;
  }

  function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
    Object.keys(mergedHelpers).forEach(function (helperName) {
      var helper = mergedHelpers[helperName];
      mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
    });
  }

  function passLookupPropertyOption(helper, container) {
    var lookupProperty = container.lookupProperty;
    return wrapHelper_1.wrapHelper(helper, function (options) {
      return Utils.extend({ lookupProperty: lookupProperty }, options);
    });
  }

  });

  unwrapExports(runtime);
  runtime.checkRevision;
  runtime.template;
  runtime.wrapProgram;
  runtime.resolvePartial;
  runtime.invokePartial;
  runtime.noop;

  var noConflict = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;

  exports['default'] = function (Handlebars) {
    /* istanbul ignore next */
    var root = typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : window,
        $Handlebars = root.Handlebars;
    /* istanbul ignore next */
    Handlebars.noConflict = function () {
      if (root.Handlebars === Handlebars) {
        root.Handlebars = $Handlebars;
      }
      return Handlebars;
    };
  };

  module.exports = exports['default'];

  });

  unwrapExports(noConflict);

  var handlebars_runtime = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

  // istanbul ignore next

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }



  var base = _interopRequireWildcard(base$1);

  // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)



  var _handlebarsSafeString2 = _interopRequireDefault(safeString);



  var _handlebarsException2 = _interopRequireDefault(exception);



  var Utils = _interopRequireWildcard(utils);



  var runtime$1 = _interopRequireWildcard(runtime);



  var _handlebarsNoConflict2 = _interopRequireDefault(noConflict);

  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
  function create() {
    var hb = new base.HandlebarsEnvironment();

    Utils.extend(hb, base);
    hb.SafeString = _handlebarsSafeString2['default'];
    hb.Exception = _handlebarsException2['default'];
    hb.Utils = Utils;
    hb.escapeExpression = Utils.escapeExpression;

    hb.VM = runtime$1;
    hb.template = function (spec) {
      return runtime$1.template(spec, hb);
    };

    return hb;
  }

  var inst = create();
  inst.create = create;

  _handlebarsNoConflict2['default'](inst);

  inst['default'] = inst;

  exports['default'] = inst;
  module.exports = exports['default'];

  });

  unwrapExports(handlebars_runtime);

  var ast = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var AST = {
    // Public API used to evaluate derived attributes regarding AST nodes
    helpers: {
      // a mustache is definitely a helper if:
      // * it is an eligible helper, and
      // * it has at least one parameter or hash segment
      helperExpression: function helperExpression(node) {
        return node.type === 'SubExpression' || (node.type === 'MustacheStatement' || node.type === 'BlockStatement') && !!(node.params && node.params.length || node.hash);
      },

      scopedId: function scopedId(path) {
        return (/^\.|this\b/.test(path.original)
        );
      },

      // an ID is simple if it only has one part, and that part is not
      // `..` or `this`.
      simpleId: function simpleId(path) {
        return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
      }
    }
  };

  // Must be exported as an object rather than the root of the module as the jison lexer
  // must modify the object to operate properly.
  exports['default'] = AST;
  module.exports = exports['default'];

  });

  unwrapExports(ast);

  var parser = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  var handlebars = (function () {
      var parser = { trace: function trace() {},
          yy: {},
          symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
          productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {

              var $0 = $$.length - 1;
              switch (yystate) {
                  case 1:
                      return $$[$0 - 1];
                  case 2:
                      this.$ = yy.prepareProgram($$[$0]);
                      break;
                  case 3:
                      this.$ = $$[$0];
                      break;
                  case 4:
                      this.$ = $$[$0];
                      break;
                  case 5:
                      this.$ = $$[$0];
                      break;
                  case 6:
                      this.$ = $$[$0];
                      break;
                  case 7:
                      this.$ = $$[$0];
                      break;
                  case 8:
                      this.$ = $$[$0];
                      break;
                  case 9:
                      this.$ = {
                          type: 'CommentStatement',
                          value: yy.stripComment($$[$0]),
                          strip: yy.stripFlags($$[$0], $$[$0]),
                          loc: yy.locInfo(this._$)
                      };

                      break;
                  case 10:
                      this.$ = {
                          type: 'ContentStatement',
                          original: $$[$0],
                          value: $$[$0],
                          loc: yy.locInfo(this._$)
                      };

                      break;
                  case 11:
                      this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                      break;
                  case 12:
                      this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                      break;
                  case 13:
                      this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                      break;
                  case 14:
                      this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                      break;
                  case 15:
                      this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                      break;
                  case 16:
                      this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                      break;
                  case 17:
                      this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                      break;
                  case 18:
                      this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                      break;
                  case 19:
                      var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$),
                          program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                      program.chained = true;

                      this.$ = { strip: $$[$0 - 2].strip, program: program, chain: true };

                      break;
                  case 20:
                      this.$ = $$[$0];
                      break;
                  case 21:
                      this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                      break;
                  case 22:
                      this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                      break;
                  case 23:
                      this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                      break;
                  case 24:
                      this.$ = {
                          type: 'PartialStatement',
                          name: $$[$0 - 3],
                          params: $$[$0 - 2],
                          hash: $$[$0 - 1],
                          indent: '',
                          strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                          loc: yy.locInfo(this._$)
                      };

                      break;
                  case 25:
                      this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                      break;
                  case 26:
                      this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                      break;
                  case 27:
                      this.$ = $$[$0];
                      break;
                  case 28:
                      this.$ = $$[$0];
                      break;
                  case 29:
                      this.$ = {
                          type: 'SubExpression',
                          path: $$[$0 - 3],
                          params: $$[$0 - 2],
                          hash: $$[$0 - 1],
                          loc: yy.locInfo(this._$)
                      };

                      break;
                  case 30:
                      this.$ = { type: 'Hash', pairs: $$[$0], loc: yy.locInfo(this._$) };
                      break;
                  case 31:
                      this.$ = { type: 'HashPair', key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                      break;
                  case 32:
                      this.$ = yy.id($$[$0 - 1]);
                      break;
                  case 33:
                      this.$ = $$[$0];
                      break;
                  case 34:
                      this.$ = $$[$0];
                      break;
                  case 35:
                      this.$ = { type: 'StringLiteral', value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                      break;
                  case 36:
                      this.$ = { type: 'NumberLiteral', value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                      break;
                  case 37:
                      this.$ = { type: 'BooleanLiteral', value: $$[$0] === 'true', original: $$[$0] === 'true', loc: yy.locInfo(this._$) };
                      break;
                  case 38:
                      this.$ = { type: 'UndefinedLiteral', original: undefined, value: undefined, loc: yy.locInfo(this._$) };
                      break;
                  case 39:
                      this.$ = { type: 'NullLiteral', original: null, value: null, loc: yy.locInfo(this._$) };
                      break;
                  case 40:
                      this.$ = $$[$0];
                      break;
                  case 41:
                      this.$ = $$[$0];
                      break;
                  case 42:
                      this.$ = yy.preparePath(true, $$[$0], this._$);
                      break;
                  case 43:
                      this.$ = yy.preparePath(false, $$[$0], this._$);
                      break;
                  case 44:
                      $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });this.$ = $$[$0 - 2];
                      break;
                  case 45:
                      this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                      break;
                  case 46:
                      this.$ = [];
                      break;
                  case 47:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 48:
                      this.$ = [];
                      break;
                  case 49:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 50:
                      this.$ = [];
                      break;
                  case 51:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 58:
                      this.$ = [];
                      break;
                  case 59:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 64:
                      this.$ = [];
                      break;
                  case 65:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 70:
                      this.$ = [];
                      break;
                  case 71:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 78:
                      this.$ = [];
                      break;
                  case 79:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 82:
                      this.$ = [];
                      break;
                  case 83:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 86:
                      this.$ = [];
                      break;
                  case 87:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 90:
                      this.$ = [];
                      break;
                  case 91:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 94:
                      this.$ = [];
                      break;
                  case 95:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 98:
                      this.$ = [$$[$0]];
                      break;
                  case 99:
                      $$[$0 - 1].push($$[$0]);
                      break;
                  case 100:
                      this.$ = [$$[$0]];
                      break;
                  case 101:
                      $$[$0 - 1].push($$[$0]);
                      break;
              }
          },
          table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
          defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
          parseError: function parseError(str, hash) {
              throw new Error(str);
          },
          parse: function parse(input) {
              var self = this,
                  stack = [0],
                  vstack = [null],
                  lstack = [],
                  table = this.table,
                  yytext = "",
                  yylineno = 0,
                  yyleng = 0;
              this.lexer.setInput(input);
              this.lexer.yy = this.yy;
              this.yy.lexer = this.lexer;
              this.yy.parser = this;
              if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
              var yyloc = this.lexer.yylloc;
              lstack.push(yyloc);
              var ranges = this.lexer.options && this.lexer.options.ranges;
              if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
              function lex() {
                  var token;
                  token = self.lexer.lex() || 1;
                  if (typeof token !== "number") {
                      token = self.symbols_[token] || token;
                  }
                  return token;
              }
              var symbol,
                  state,
                  action,
                  r,
                  yyval = {},
                  p,
                  len,
                  newState,
                  expected;
              while (true) {
                  state = stack[stack.length - 1];
                  if (this.defaultActions[state]) {
                      action = this.defaultActions[state];
                  } else {
                      if (symbol === null || typeof symbol == "undefined") {
                          symbol = lex();
                      }
                      action = table[state] && table[state][symbol];
                  }
                  if (typeof action === "undefined" || !action.length || !action[0]) {
                      var errStr = "";
                      {
                          expected = [];
                          for (p in table[state]) if (this.terminals_[p] && p > 2) {
                              expected.push("'" + this.terminals_[p] + "'");
                          }
                          if (this.lexer.showPosition) {
                              errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                          } else {
                              errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                          }
                          this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected });
                      }
                  }
                  if (action[0] instanceof Array && action.length > 1) {
                      throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                  }
                  switch (action[0]) {
                      case 1:
                          stack.push(symbol);
                          vstack.push(this.lexer.yytext);
                          lstack.push(this.lexer.yylloc);
                          stack.push(action[1]);
                          symbol = null;
                          {
                              yyleng = this.lexer.yyleng;
                              yytext = this.lexer.yytext;
                              yylineno = this.lexer.yylineno;
                              yyloc = this.lexer.yylloc;
                          }
                          break;
                      case 2:
                          len = this.productions_[action[1]][1];
                          yyval.$ = vstack[vstack.length - len];
                          yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                          if (ranges) {
                              yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                          }
                          r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                          if (typeof r !== "undefined") {
                              return r;
                          }
                          if (len) {
                              stack = stack.slice(0, -1 * len * 2);
                              vstack = vstack.slice(0, -1 * len);
                              lstack = lstack.slice(0, -1 * len);
                          }
                          stack.push(this.productions_[action[1]][0]);
                          vstack.push(yyval.$);
                          lstack.push(yyval._$);
                          newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                          stack.push(newState);
                          break;
                      case 3:
                          return true;
                  }
              }
              return true;
          }
      };
      /* Jison generated lexer */
      var lexer = (function () {
          var lexer = { EOF: 1,
              parseError: function parseError(str, hash) {
                  if (this.yy.parser) {
                      this.yy.parser.parseError(str, hash);
                  } else {
                      throw new Error(str);
                  }
              },
              setInput: function setInput(input) {
                  this._input = input;
                  this._more = this._less = this.done = false;
                  this.yylineno = this.yyleng = 0;
                  this.yytext = this.matched = this.match = '';
                  this.conditionStack = ['INITIAL'];
                  this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
                  if (this.options.ranges) this.yylloc.range = [0, 0];
                  this.offset = 0;
                  return this;
              },
              input: function input() {
                  var ch = this._input[0];
                  this.yytext += ch;
                  this.yyleng++;
                  this.offset++;
                  this.match += ch;
                  this.matched += ch;
                  var lines = ch.match(/(?:\r\n?|\n).*/g);
                  if (lines) {
                      this.yylineno++;
                      this.yylloc.last_line++;
                  } else {
                      this.yylloc.last_column++;
                  }
                  if (this.options.ranges) this.yylloc.range[1]++;

                  this._input = this._input.slice(1);
                  return ch;
              },
              unput: function unput(ch) {
                  var len = ch.length;
                  var lines = ch.split(/(?:\r\n?|\n)/g);

                  this._input = ch + this._input;
                  this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                  //this.yyleng -= len;
                  this.offset -= len;
                  var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                  this.match = this.match.substr(0, this.match.length - 1);
                  this.matched = this.matched.substr(0, this.matched.length - 1);

                  if (lines.length - 1) this.yylineno -= lines.length - 1;
                  var r = this.yylloc.range;

                  this.yylloc = { first_line: this.yylloc.first_line,
                      last_line: this.yylineno + 1,
                      first_column: this.yylloc.first_column,
                      last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                  };

                  if (this.options.ranges) {
                      this.yylloc.range = [r[0], r[0] + this.yyleng - len];
                  }
                  return this;
              },
              more: function more() {
                  this._more = true;
                  return this;
              },
              less: function less(n) {
                  this.unput(this.match.slice(n));
              },
              pastInput: function pastInput() {
                  var past = this.matched.substr(0, this.matched.length - this.match.length);
                  return (past.length > 20 ? '...' : '') + past.substr(-20).replace(/\n/g, "");
              },
              upcomingInput: function upcomingInput() {
                  var next = this.match;
                  if (next.length < 20) {
                      next += this._input.substr(0, 20 - next.length);
                  }
                  return (next.substr(0, 20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
              },
              showPosition: function showPosition() {
                  var pre = this.pastInput();
                  var c = new Array(pre.length + 1).join("-");
                  return pre + this.upcomingInput() + "\n" + c + "^";
              },
              next: function next() {
                  if (this.done) {
                      return this.EOF;
                  }
                  if (!this._input) this.done = true;

                  var token, match, tempMatch, index, lines;
                  if (!this._more) {
                      this.yytext = '';
                      this.match = '';
                  }
                  var rules = this._currentRules();
                  for (var i = 0; i < rules.length; i++) {
                      tempMatch = this._input.match(this.rules[rules[i]]);
                      if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                          match = tempMatch;
                          index = i;
                          if (!this.options.flex) break;
                      }
                  }
                  if (match) {
                      lines = match[0].match(/(?:\r\n?|\n).*/g);
                      if (lines) this.yylineno += lines.length;
                      this.yylloc = { first_line: this.yylloc.last_line,
                          last_line: this.yylineno + 1,
                          first_column: this.yylloc.last_column,
                          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length };
                      this.yytext += match[0];
                      this.match += match[0];
                      this.matches = match;
                      this.yyleng = this.yytext.length;
                      if (this.options.ranges) {
                          this.yylloc.range = [this.offset, this.offset += this.yyleng];
                      }
                      this._more = false;
                      this._input = this._input.slice(match[0].length);
                      this.matched += match[0];
                      token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                      if (this.done && this._input) this.done = false;
                      if (token) return token;else return;
                  }
                  if (this._input === "") {
                      return this.EOF;
                  } else {
                      return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), { text: "", token: null, line: this.yylineno });
                  }
              },
              lex: function lex() {
                  var r = this.next();
                  if (typeof r !== 'undefined') {
                      return r;
                  } else {
                      return this.lex();
                  }
              },
              begin: function begin(condition) {
                  this.conditionStack.push(condition);
              },
              popState: function popState() {
                  return this.conditionStack.pop();
              },
              _currentRules: function _currentRules() {
                  return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
              },
              topState: function topState() {
                  return this.conditionStack[this.conditionStack.length - 2];
              },
              pushState: function begin(condition) {
                  this.begin(condition);
              } };
          lexer.options = {};
          lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

              function strip(start, end) {
                  return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
              }
              switch ($avoiding_name_collisions) {
                  case 0:
                      if (yy_.yytext.slice(-2) === "\\\\") {
                          strip(0, 1);
                          this.begin("mu");
                      } else if (yy_.yytext.slice(-1) === "\\") {
                          strip(0, 1);
                          this.begin("emu");
                      } else {
                          this.begin("mu");
                      }
                      if (yy_.yytext) return 15;

                      break;
                  case 1:
                      return 15;
                  case 2:
                      this.popState();
                      return 15;
                  case 3:
                      this.begin('raw');return 15;
                  case 4:
                      this.popState();
                      // Should be using `this.topState()` below, but it currently
                      // returns the second top instead of the first top. Opened an
                      // issue about it at https://github.com/zaach/jison/issues/291
                      if (this.conditionStack[this.conditionStack.length - 1] === 'raw') {
                          return 15;
                      } else {
                          strip(5, 9);
                          return 'END_RAW_BLOCK';
                      }
                  case 5:
                      return 15;
                  case 6:
                      this.popState();
                      return 14;
                  case 7:
                      return 65;
                  case 8:
                      return 68;
                  case 9:
                      return 19;
                  case 10:
                      this.popState();
                      this.begin('raw');
                      return 23;
                  case 11:
                      return 55;
                  case 12:
                      return 60;
                  case 13:
                      return 29;
                  case 14:
                      return 47;
                  case 15:
                      this.popState();return 44;
                  case 16:
                      this.popState();return 44;
                  case 17:
                      return 34;
                  case 18:
                      return 39;
                  case 19:
                      return 51;
                  case 20:
                      return 48;
                  case 21:
                      this.unput(yy_.yytext);
                      this.popState();
                      this.begin('com');

                      break;
                  case 22:
                      this.popState();
                      return 14;
                  case 23:
                      return 48;
                  case 24:
                      return 73;
                  case 25:
                      return 72;
                  case 26:
                      return 72;
                  case 27:
                      return 87;
                  case 28:
                      // ignore whitespace
                      break;
                  case 29:
                      this.popState();return 54;
                  case 30:
                      this.popState();return 33;
                  case 31:
                      yy_.yytext = strip(1, 2).replace(/\\"/g, '"');return 80;
                  case 32:
                      yy_.yytext = strip(1, 2).replace(/\\'/g, "'");return 80;
                  case 33:
                      return 85;
                  case 34:
                      return 82;
                  case 35:
                      return 82;
                  case 36:
                      return 83;
                  case 37:
                      return 84;
                  case 38:
                      return 81;
                  case 39:
                      return 75;
                  case 40:
                      return 77;
                  case 41:
                      return 72;
                  case 42:
                      yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, '$1');return 72;
                  case 43:
                      return 'INVALID';
                  case 44:
                      return 5;
              }
          };
          lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
          lexer.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
          return lexer;
      })();
      parser.lexer = lexer;
      function Parser() {
          this.yy = {};
      }Parser.prototype = parser;parser.Parser = Parser;
      return new Parser();
  })();exports["default"] = handlebars;
  module.exports = exports["default"];

  });

  unwrapExports(parser);

  var visitor = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _exception2 = _interopRequireDefault(exception);

  function Visitor() {
    this.parents = [];
  }

  Visitor.prototype = {
    constructor: Visitor,
    mutating: false,

    // Visits a given value. If mutating, will replace the value if necessary.
    acceptKey: function acceptKey(node, name) {
      var value = this.accept(node[name]);
      if (this.mutating) {
        // Hacky sanity check: This may have a few false positives for type for the helper
        // methods but will generally do the right thing without a lot of overhead.
        if (value && !Visitor.prototype[value.type]) {
          throw new _exception2['default']('Unexpected node type "' + value.type + '" found when accepting ' + name + ' on ' + node.type);
        }
        node[name] = value;
      }
    },

    // Performs an accept operation with added sanity check to ensure
    // required keys are not removed.
    acceptRequired: function acceptRequired(node, name) {
      this.acceptKey(node, name);

      if (!node[name]) {
        throw new _exception2['default'](node.type + ' requires ' + name);
      }
    },

    // Traverses a given array. If mutating, empty respnses will be removed
    // for child elements.
    acceptArray: function acceptArray(array) {
      for (var i = 0, l = array.length; i < l; i++) {
        this.acceptKey(array, i);

        if (!array[i]) {
          array.splice(i, 1);
          i--;
          l--;
        }
      }
    },

    accept: function accept(object) {
      if (!object) {
        return;
      }

      /* istanbul ignore next: Sanity code */
      if (!this[object.type]) {
        throw new _exception2['default']('Unknown type: ' + object.type, object);
      }

      if (this.current) {
        this.parents.unshift(this.current);
      }
      this.current = object;

      var ret = this[object.type](object);

      this.current = this.parents.shift();

      if (!this.mutating || ret) {
        return ret;
      } else if (ret !== false) {
        return object;
      }
    },

    Program: function Program(program) {
      this.acceptArray(program.body);
    },

    MustacheStatement: visitSubExpression,
    Decorator: visitSubExpression,

    BlockStatement: visitBlock,
    DecoratorBlock: visitBlock,

    PartialStatement: visitPartial,
    PartialBlockStatement: function PartialBlockStatement(partial) {
      visitPartial.call(this, partial);

      this.acceptKey(partial, 'program');
    },

    ContentStatement: function ContentStatement() /* content */{},
    CommentStatement: function CommentStatement() /* comment */{},

    SubExpression: visitSubExpression,

    PathExpression: function PathExpression() /* path */{},

    StringLiteral: function StringLiteral() /* string */{},
    NumberLiteral: function NumberLiteral() /* number */{},
    BooleanLiteral: function BooleanLiteral() /* bool */{},
    UndefinedLiteral: function UndefinedLiteral() /* literal */{},
    NullLiteral: function NullLiteral() /* literal */{},

    Hash: function Hash(hash) {
      this.acceptArray(hash.pairs);
    },
    HashPair: function HashPair(pair) {
      this.acceptRequired(pair, 'value');
    }
  };

  function visitSubExpression(mustache) {
    this.acceptRequired(mustache, 'path');
    this.acceptArray(mustache.params);
    this.acceptKey(mustache, 'hash');
  }
  function visitBlock(block) {
    visitSubExpression.call(this, block);

    this.acceptKey(block, 'program');
    this.acceptKey(block, 'inverse');
  }
  function visitPartial(partial) {
    this.acceptRequired(partial, 'name');
    this.acceptArray(partial.params);
    this.acceptKey(partial, 'hash');
  }

  exports['default'] = Visitor;
  module.exports = exports['default'];

  });

  unwrapExports(visitor);

  var whitespaceControl = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _visitor2 = _interopRequireDefault(visitor);

  function WhitespaceControl() {
    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    this.options = options;
  }
  WhitespaceControl.prototype = new _visitor2['default']();

  WhitespaceControl.prototype.Program = function (program) {
    var doStandalone = !this.options.ignoreStandalone;

    var isRoot = !this.isRootSeen;
    this.isRootSeen = true;

    var body = program.body;
    for (var i = 0, l = body.length; i < l; i++) {
      var current = body[i],
          strip = this.accept(current);

      if (!strip) {
        continue;
      }

      var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot),
          _isNextWhitespace = isNextWhitespace(body, i, isRoot),
          openStandalone = strip.openStandalone && _isPrevWhitespace,
          closeStandalone = strip.closeStandalone && _isNextWhitespace,
          inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;

      if (strip.close) {
        omitRight(body, i, true);
      }
      if (strip.open) {
        omitLeft(body, i, true);
      }

      if (doStandalone && inlineStandalone) {
        omitRight(body, i);

        if (omitLeft(body, i)) {
          // If we are on a standalone node, save the indent info for partials
          if (current.type === 'PartialStatement') {
            // Pull out the whitespace from the final line
            current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
          }
        }
      }
      if (doStandalone && openStandalone) {
        omitRight((current.program || current.inverse).body);

        // Strip out the previous content node if it's whitespace only
        omitLeft(body, i);
      }
      if (doStandalone && closeStandalone) {
        // Always strip the next node
        omitRight(body, i);

        omitLeft((current.inverse || current.program).body);
      }
    }

    return program;
  };

  WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function (block) {
    this.accept(block.program);
    this.accept(block.inverse);

    // Find the inverse program that is involed with whitespace stripping.
    var program = block.program || block.inverse,
        inverse = block.program && block.inverse,
        firstInverse = inverse,
        lastInverse = inverse;

    if (inverse && inverse.chained) {
      firstInverse = inverse.body[0].program;

      // Walk the inverse chain to find the last inverse that is actually in the chain.
      while (lastInverse.chained) {
        lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
      }
    }

    var strip = {
      open: block.openStrip.open,
      close: block.closeStrip.close,

      // Determine the standalone candiacy. Basically flag our content as being possibly standalone
      // so our parent can determine if we actually are standalone
      openStandalone: isNextWhitespace(program.body),
      closeStandalone: isPrevWhitespace((firstInverse || program).body)
    };

    if (block.openStrip.close) {
      omitRight(program.body, null, true);
    }

    if (inverse) {
      var inverseStrip = block.inverseStrip;

      if (inverseStrip.open) {
        omitLeft(program.body, null, true);
      }

      if (inverseStrip.close) {
        omitRight(firstInverse.body, null, true);
      }
      if (block.closeStrip.open) {
        omitLeft(lastInverse.body, null, true);
      }

      // Find standalone else statments
      if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
        omitLeft(program.body);
        omitRight(firstInverse.body);
      }
    } else if (block.closeStrip.open) {
      omitLeft(program.body, null, true);
    }

    return strip;
  };

  WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function (mustache) {
    return mustache.strip;
  };

  WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function (node) {
    /* istanbul ignore next */
    var strip = node.strip || {};
    return {
      inlineStandalone: true,
      open: strip.open,
      close: strip.close
    };
  };

  function isPrevWhitespace(body, i, isRoot) {
    if (i === undefined) {
      i = body.length;
    }

    // Nodes that end with newlines are considered whitespace (but are special
    // cased for strip operations)
    var prev = body[i - 1],
        sibling = body[i - 2];
    if (!prev) {
      return isRoot;
    }

    if (prev.type === 'ContentStatement') {
      return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
    }
  }
  function isNextWhitespace(body, i, isRoot) {
    if (i === undefined) {
      i = -1;
    }

    var next = body[i + 1],
        sibling = body[i + 2];
    if (!next) {
      return isRoot;
    }

    if (next.type === 'ContentStatement') {
      return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
    }
  }

  // Marks the node to the right of the position as omitted.
  // I.e. {{foo}}' ' will mark the ' ' node as omitted.
  //
  // If i is undefined, then the first child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitRight(body, i, multiple) {
    var current = body[i == null ? 0 : i + 1];
    if (!current || current.type !== 'ContentStatement' || !multiple && current.rightStripped) {
      return;
    }

    var original = current.value;
    current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, '');
    current.rightStripped = current.value !== original;
  }

  // Marks the node to the left of the position as omitted.
  // I.e. ' '{{foo}} will mark the ' ' node as omitted.
  //
  // If i is undefined then the last child will be marked as such.
  //
  // If mulitple is truthy then all whitespace will be stripped out until non-whitespace
  // content is met.
  function omitLeft(body, i, multiple) {
    var current = body[i == null ? body.length - 1 : i - 1];
    if (!current || current.type !== 'ContentStatement' || !multiple && current.leftStripped) {
      return;
    }

    // We omit the last node if it's whitespace only and not preceded by a non-content node.
    var original = current.value;
    current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, '');
    current.leftStripped = current.value !== original;
    return current.leftStripped;
  }

  exports['default'] = WhitespaceControl;
  module.exports = exports['default'];

  });

  unwrapExports(whitespaceControl);

  var helpers = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.SourceLocation = SourceLocation;
  exports.id = id;
  exports.stripFlags = stripFlags;
  exports.stripComment = stripComment;
  exports.preparePath = preparePath;
  exports.prepareMustache = prepareMustache;
  exports.prepareRawBlock = prepareRawBlock;
  exports.prepareBlock = prepareBlock;
  exports.prepareProgram = prepareProgram;
  exports.preparePartialBlock = preparePartialBlock;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _exception2 = _interopRequireDefault(exception);

  function validateClose(open, close) {
    close = close.path ? close.path.original : close;

    if (open.path.original !== close) {
      var errorNode = { loc: open.path.loc };

      throw new _exception2['default'](open.path.original + " doesn't match " + close, errorNode);
    }
  }

  function SourceLocation(source, locInfo) {
    this.source = source;
    this.start = {
      line: locInfo.first_line,
      column: locInfo.first_column
    };
    this.end = {
      line: locInfo.last_line,
      column: locInfo.last_column
    };
  }

  function id(token) {
    if (/^\[.*\]$/.test(token)) {
      return token.substring(1, token.length - 1);
    } else {
      return token;
    }
  }

  function stripFlags(open, close) {
    return {
      open: open.charAt(2) === '~',
      close: close.charAt(close.length - 3) === '~'
    };
  }

  function stripComment(comment) {
    return comment.replace(/^\{\{~?!-?-?/, '').replace(/-?-?~?\}\}$/, '');
  }

  function preparePath(data, parts, loc) {
    loc = this.locInfo(loc);

    var original = data ? '@' : '',
        dig = [],
        depth = 0;

    for (var i = 0, l = parts.length; i < l; i++) {
      var part = parts[i].part,

      // If we have [] syntax then we do not treat path references as operators,
      // i.e. foo.[this] resolves to approximately context.foo['this']
      isLiteral = parts[i].original !== part;
      original += (parts[i].separator || '') + part;

      if (!isLiteral && (part === '..' || part === '.' || part === 'this')) {
        if (dig.length > 0) {
          throw new _exception2['default']('Invalid path: ' + original, { loc: loc });
        } else if (part === '..') {
          depth++;
        }
      } else {
        dig.push(part);
      }
    }

    return {
      type: 'PathExpression',
      data: data,
      depth: depth,
      parts: dig,
      original: original,
      loc: loc
    };
  }

  function prepareMustache(path, params, hash, open, strip, locInfo) {
    // Must use charAt to support IE pre-10
    var escapeFlag = open.charAt(3) || open.charAt(2),
        escaped = escapeFlag !== '{' && escapeFlag !== '&';

    var decorator = /\*/.test(open);
    return {
      type: decorator ? 'Decorator' : 'MustacheStatement',
      path: path,
      params: params,
      hash: hash,
      escaped: escaped,
      strip: strip,
      loc: this.locInfo(locInfo)
    };
  }

  function prepareRawBlock(openRawBlock, contents, close, locInfo) {
    validateClose(openRawBlock, close);

    locInfo = this.locInfo(locInfo);
    var program = {
      type: 'Program',
      body: contents,
      strip: {},
      loc: locInfo
    };

    return {
      type: 'BlockStatement',
      path: openRawBlock.path,
      params: openRawBlock.params,
      hash: openRawBlock.hash,
      program: program,
      openStrip: {},
      inverseStrip: {},
      closeStrip: {},
      loc: locInfo
    };
  }

  function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
    if (close && close.path) {
      validateClose(openBlock, close);
    }

    var decorator = /\*/.test(openBlock.open);

    program.blockParams = openBlock.blockParams;

    var inverse = undefined,
        inverseStrip = undefined;

    if (inverseAndProgram) {
      if (decorator) {
        throw new _exception2['default']('Unexpected inverse block on decorator', inverseAndProgram);
      }

      if (inverseAndProgram.chain) {
        inverseAndProgram.program.body[0].closeStrip = close.strip;
      }

      inverseStrip = inverseAndProgram.strip;
      inverse = inverseAndProgram.program;
    }

    if (inverted) {
      inverted = inverse;
      inverse = program;
      program = inverted;
    }

    return {
      type: decorator ? 'DecoratorBlock' : 'BlockStatement',
      path: openBlock.path,
      params: openBlock.params,
      hash: openBlock.hash,
      program: program,
      inverse: inverse,
      openStrip: openBlock.strip,
      inverseStrip: inverseStrip,
      closeStrip: close && close.strip,
      loc: this.locInfo(locInfo)
    };
  }

  function prepareProgram(statements, loc) {
    if (!loc && statements.length) {
      var firstLoc = statements[0].loc,
          lastLoc = statements[statements.length - 1].loc;

      /* istanbul ignore else */
      if (firstLoc && lastLoc) {
        loc = {
          source: firstLoc.source,
          start: {
            line: firstLoc.start.line,
            column: firstLoc.start.column
          },
          end: {
            line: lastLoc.end.line,
            column: lastLoc.end.column
          }
        };
      }
    }

    return {
      type: 'Program',
      body: statements,
      strip: {},
      loc: loc
    };
  }

  function preparePartialBlock(open, program, close, locInfo) {
    validateClose(open, close);

    return {
      type: 'PartialBlockStatement',
      name: open.path,
      params: open.params,
      hash: open.hash,
      program: program,
      openStrip: open.strip,
      closeStrip: close && close.strip,
      loc: this.locInfo(locInfo)
    };
  }

  });

  unwrapExports(helpers);
  helpers.SourceLocation;
  helpers.id;
  helpers.stripFlags;
  helpers.stripComment;
  helpers.preparePath;
  helpers.prepareMustache;
  helpers.prepareRawBlock;
  helpers.prepareBlock;
  helpers.prepareProgram;
  helpers.preparePartialBlock;

  var base = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.parseWithoutProcessing = parseWithoutProcessing;
  exports.parse = parse;
  // istanbul ignore next

  function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _parser2 = _interopRequireDefault(parser);



  var _whitespaceControl2 = _interopRequireDefault(whitespaceControl);



  var Helpers = _interopRequireWildcard(helpers);



  exports.parser = _parser2['default'];

  var yy = {};
  utils.extend(yy, Helpers);

  function parseWithoutProcessing(input, options) {
    // Just return if an already-compiled AST was passed in.
    if (input.type === 'Program') {
      return input;
    }

    _parser2['default'].yy = yy;

    // Altering the shared object here, but this is ok as parser is a sync operation
    yy.locInfo = function (locInfo) {
      return new yy.SourceLocation(options && options.srcName, locInfo);
    };

    var ast = _parser2['default'].parse(input);

    return ast;
  }

  function parse(input, options) {
    var ast = parseWithoutProcessing(input, options);
    var strip = new _whitespaceControl2['default'](options);

    return strip.accept(ast);
  }

  });

  unwrapExports(base);
  base.parseWithoutProcessing;
  base.parse;
  base.parser;

  var compiler = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.Compiler = Compiler;
  exports.precompile = precompile;
  exports.compile = compile;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _exception2 = _interopRequireDefault(exception);





  var _ast2 = _interopRequireDefault(ast);

  var slice = [].slice;

  function Compiler() {}

  // the foundHelper register will disambiguate helper lookup from finding a
  // function in a context. This is necessary for mustache compatibility, which
  // requires that context functions in blocks are evaluated by blockHelperMissing,
  // and then proceed as if the resulting value was provided to blockHelperMissing.

  Compiler.prototype = {
    compiler: Compiler,

    equals: function equals(other) {
      var len = this.opcodes.length;
      if (other.opcodes.length !== len) {
        return false;
      }

      for (var i = 0; i < len; i++) {
        var opcode = this.opcodes[i],
            otherOpcode = other.opcodes[i];
        if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
          return false;
        }
      }

      // We know that length is the same between the two arrays because they are directly tied
      // to the opcode behavior above.
      len = this.children.length;
      for (var i = 0; i < len; i++) {
        if (!this.children[i].equals(other.children[i])) {
          return false;
        }
      }

      return true;
    },

    guid: 0,

    compile: function compile(program, options) {
      this.sourceNode = [];
      this.opcodes = [];
      this.children = [];
      this.options = options;
      this.stringParams = options.stringParams;
      this.trackIds = options.trackIds;

      options.blockParams = options.blockParams || [];

      options.knownHelpers = utils.extend(Object.create(null), {
        helperMissing: true,
        blockHelperMissing: true,
        each: true,
        'if': true,
        unless: true,
        'with': true,
        log: true,
        lookup: true
      }, options.knownHelpers);

      return this.accept(program);
    },

    compileProgram: function compileProgram(program) {
      var childCompiler = new this.compiler(),
          // eslint-disable-line new-cap
      result = childCompiler.compile(program, this.options),
          guid = this.guid++;

      this.usePartial = this.usePartial || result.usePartial;

      this.children[guid] = result;
      this.useDepths = this.useDepths || result.useDepths;

      return guid;
    },

    accept: function accept(node) {
      /* istanbul ignore next: Sanity code */
      if (!this[node.type]) {
        throw new _exception2['default']('Unknown type: ' + node.type, node);
      }

      this.sourceNode.unshift(node);
      var ret = this[node.type](node);
      this.sourceNode.shift();
      return ret;
    },

    Program: function Program(program) {
      this.options.blockParams.unshift(program.blockParams);

      var body = program.body,
          bodyLength = body.length;
      for (var i = 0; i < bodyLength; i++) {
        this.accept(body[i]);
      }

      this.options.blockParams.shift();

      this.isSimple = bodyLength === 1;
      this.blockParams = program.blockParams ? program.blockParams.length : 0;

      return this;
    },

    BlockStatement: function BlockStatement(block) {
      transformLiteralToPath(block);

      var program = block.program,
          inverse = block.inverse;

      program = program && this.compileProgram(program);
      inverse = inverse && this.compileProgram(inverse);

      var type = this.classifySexpr(block);

      if (type === 'helper') {
        this.helperSexpr(block, program, inverse);
      } else if (type === 'simple') {
        this.simpleSexpr(block);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('blockValue', block.path.original);
      } else {
        this.ambiguousSexpr(block, program, inverse);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('ambiguousBlockValue');
      }

      this.opcode('append');
    },

    DecoratorBlock: function DecoratorBlock(decorator) {
      var program = decorator.program && this.compileProgram(decorator.program);
      var params = this.setupFullMustacheParams(decorator, program, undefined),
          path = decorator.path;

      this.useDecorators = true;
      this.opcode('registerDecorator', params.length, path.original);
    },

    PartialStatement: function PartialStatement(partial) {
      this.usePartial = true;

      var program = partial.program;
      if (program) {
        program = this.compileProgram(partial.program);
      }

      var params = partial.params;
      if (params.length > 1) {
        throw new _exception2['default']('Unsupported number of partial arguments: ' + params.length, partial);
      } else if (!params.length) {
        if (this.options.explicitPartialContext) {
          this.opcode('pushLiteral', 'undefined');
        } else {
          params.push({ type: 'PathExpression', parts: [], depth: 0 });
        }
      }

      var partialName = partial.name.original,
          isDynamic = partial.name.type === 'SubExpression';
      if (isDynamic) {
        this.accept(partial.name);
      }

      this.setupFullMustacheParams(partial, program, undefined, true);

      var indent = partial.indent || '';
      if (this.options.preventIndent && indent) {
        this.opcode('appendContent', indent);
        indent = '';
      }

      this.opcode('invokePartial', isDynamic, partialName, indent);
      this.opcode('append');
    },
    PartialBlockStatement: function PartialBlockStatement(partialBlock) {
      this.PartialStatement(partialBlock);
    },

    MustacheStatement: function MustacheStatement(mustache) {
      this.SubExpression(mustache);

      if (mustache.escaped && !this.options.noEscape) {
        this.opcode('appendEscaped');
      } else {
        this.opcode('append');
      }
    },
    Decorator: function Decorator(decorator) {
      this.DecoratorBlock(decorator);
    },

    ContentStatement: function ContentStatement(content) {
      if (content.value) {
        this.opcode('appendContent', content.value);
      }
    },

    CommentStatement: function CommentStatement() {},

    SubExpression: function SubExpression(sexpr) {
      transformLiteralToPath(sexpr);
      var type = this.classifySexpr(sexpr);

      if (type === 'simple') {
        this.simpleSexpr(sexpr);
      } else if (type === 'helper') {
        this.helperSexpr(sexpr);
      } else {
        this.ambiguousSexpr(sexpr);
      }
    },
    ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
      var path = sexpr.path,
          name = path.parts[0],
          isBlock = program != null || inverse != null;

      this.opcode('getContext', path.depth);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      path.strict = true;
      this.accept(path);

      this.opcode('invokeAmbiguous', name, isBlock);
    },

    simpleSexpr: function simpleSexpr(sexpr) {
      var path = sexpr.path;
      path.strict = true;
      this.accept(path);
      this.opcode('resolvePossibleLambda');
    },

    helperSexpr: function helperSexpr(sexpr, program, inverse) {
      var params = this.setupFullMustacheParams(sexpr, program, inverse),
          path = sexpr.path,
          name = path.parts[0];

      if (this.options.knownHelpers[name]) {
        this.opcode('invokeKnownHelper', params.length, name);
      } else if (this.options.knownHelpersOnly) {
        throw new _exception2['default']('You specified knownHelpersOnly, but used the unknown helper ' + name, sexpr);
      } else {
        path.strict = true;
        path.falsy = true;

        this.accept(path);
        this.opcode('invokeHelper', params.length, path.original, _ast2['default'].helpers.simpleId(path));
      }
    },

    PathExpression: function PathExpression(path) {
      this.addDepth(path.depth);
      this.opcode('getContext', path.depth);

      var name = path.parts[0],
          scoped = _ast2['default'].helpers.scopedId(path),
          blockParamId = !path.depth && !scoped && this.blockParamIndex(name);

      if (blockParamId) {
        this.opcode('lookupBlockParam', blockParamId, path.parts);
      } else if (!name) {
        // Context reference, i.e. `{{foo .}}` or `{{foo ..}}`
        this.opcode('pushContext');
      } else if (path.data) {
        this.options.data = true;
        this.opcode('lookupData', path.depth, path.parts, path.strict);
      } else {
        this.opcode('lookupOnContext', path.parts, path.falsy, path.strict, scoped);
      }
    },

    StringLiteral: function StringLiteral(string) {
      this.opcode('pushString', string.value);
    },

    NumberLiteral: function NumberLiteral(number) {
      this.opcode('pushLiteral', number.value);
    },

    BooleanLiteral: function BooleanLiteral(bool) {
      this.opcode('pushLiteral', bool.value);
    },

    UndefinedLiteral: function UndefinedLiteral() {
      this.opcode('pushLiteral', 'undefined');
    },

    NullLiteral: function NullLiteral() {
      this.opcode('pushLiteral', 'null');
    },

    Hash: function Hash(hash) {
      var pairs = hash.pairs,
          i = 0,
          l = pairs.length;

      this.opcode('pushHash');

      for (; i < l; i++) {
        this.pushParam(pairs[i].value);
      }
      while (i--) {
        this.opcode('assignToHash', pairs[i].key);
      }
      this.opcode('popHash');
    },

    // HELPERS
    opcode: function opcode(name) {
      this.opcodes.push({
        opcode: name,
        args: slice.call(arguments, 1),
        loc: this.sourceNode[0].loc
      });
    },

    addDepth: function addDepth(depth) {
      if (!depth) {
        return;
      }

      this.useDepths = true;
    },

    classifySexpr: function classifySexpr(sexpr) {
      var isSimple = _ast2['default'].helpers.simpleId(sexpr.path);

      var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);

      // a mustache is an eligible helper if:
      // * its id is simple (a single part, not `this` or `..`)
      var isHelper = !isBlockParam && _ast2['default'].helpers.helperExpression(sexpr);

      // if a mustache is an eligible helper but not a definite
      // helper, it is ambiguous, and will be resolved in a later
      // pass or at runtime.
      var isEligible = !isBlockParam && (isHelper || isSimple);

      // if ambiguous, we can possibly resolve the ambiguity now
      // An eligible helper is one that does not have a complex path, i.e. `this.foo`, `../foo` etc.
      if (isEligible && !isHelper) {
        var _name = sexpr.path.parts[0],
            options = this.options;
        if (options.knownHelpers[_name]) {
          isHelper = true;
        } else if (options.knownHelpersOnly) {
          isEligible = false;
        }
      }

      if (isHelper) {
        return 'helper';
      } else if (isEligible) {
        return 'ambiguous';
      } else {
        return 'simple';
      }
    },

    pushParams: function pushParams(params) {
      for (var i = 0, l = params.length; i < l; i++) {
        this.pushParam(params[i]);
      }
    },

    pushParam: function pushParam(val) {
      var value = val.value != null ? val.value : val.original || '';

      if (this.stringParams) {
        if (value.replace) {
          value = value.replace(/^(\.?\.\/)*/g, '').replace(/\//g, '.');
        }

        if (val.depth) {
          this.addDepth(val.depth);
        }
        this.opcode('getContext', val.depth || 0);
        this.opcode('pushStringParam', value, val.type);

        if (val.type === 'SubExpression') {
          // SubExpressions get evaluated and passed in
          // in string params mode.
          this.accept(val);
        }
      } else {
        if (this.trackIds) {
          var blockParamIndex = undefined;
          if (val.parts && !_ast2['default'].helpers.scopedId(val) && !val.depth) {
            blockParamIndex = this.blockParamIndex(val.parts[0]);
          }
          if (blockParamIndex) {
            var blockParamChild = val.parts.slice(1).join('.');
            this.opcode('pushId', 'BlockParam', blockParamIndex, blockParamChild);
          } else {
            value = val.original || value;
            if (value.replace) {
              value = value.replace(/^this(?:\.|$)/, '').replace(/^\.\//, '').replace(/^\.$/, '');
            }

            this.opcode('pushId', val.type, value);
          }
        }
        this.accept(val);
      }
    },

    setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
      var params = sexpr.params;
      this.pushParams(params);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      if (sexpr.hash) {
        this.accept(sexpr.hash);
      } else {
        this.opcode('emptyHash', omitEmpty);
      }

      return params;
    },

    blockParamIndex: function blockParamIndex(name) {
      for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
        var blockParams = this.options.blockParams[depth],
            param = blockParams && utils.indexOf(blockParams, name);
        if (blockParams && param >= 0) {
          return [depth, param];
        }
      }
    }
  };

  function precompile(input, options, env) {
    if (input == null || typeof input !== 'string' && input.type !== 'Program') {
      throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.precompile. You passed ' + input);
    }

    options = options || {};
    if (!('data' in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }

    var ast = env.parse(input, options),
        environment = new env.Compiler().compile(ast, options);
    return new env.JavaScriptCompiler().compile(environment, options);
  }

  function compile(input, options, env) {
    if (options === undefined) options = {};

    if (input == null || typeof input !== 'string' && input.type !== 'Program') {
      throw new _exception2['default']('You must pass a string or Handlebars AST to Handlebars.compile. You passed ' + input);
    }

    options = utils.extend({}, options);
    if (!('data' in options)) {
      options.data = true;
    }
    if (options.compat) {
      options.useDepths = true;
    }

    var compiled = undefined;

    function compileInput() {
      var ast = env.parse(input, options),
          environment = new env.Compiler().compile(ast, options),
          templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
      return env.template(templateSpec);
    }

    // Template is only compiled on first use and cached after that point.
    function ret(context, execOptions) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled.call(this, context, execOptions);
    }
    ret._setup = function (setupOptions) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._setup(setupOptions);
    };
    ret._child = function (i, data, blockParams, depths) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled._child(i, data, blockParams, depths);
    };
    return ret;
  }

  function argEquals(a, b) {
    if (a === b) {
      return true;
    }

    if (utils.isArray(a) && utils.isArray(b) && a.length === b.length) {
      for (var i = 0; i < a.length; i++) {
        if (!argEquals(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
  }

  function transformLiteralToPath(sexpr) {
    if (!sexpr.path.parts) {
      var literal = sexpr.path;
      // Casting to string here to make false and 0 literal values play nicely with the rest
      // of the system.
      sexpr.path = {
        type: 'PathExpression',
        data: false,
        depth: 0,
        parts: [literal.original + ''],
        original: literal.original + '',
        loc: literal.loc
      };
    }
  }

  });

  unwrapExports(compiler);
  compiler.Compiler;
  compiler.precompile;
  compiler.compile;

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  var encode$1 = function (number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };

  /**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  var decode$1 = function (charCode) {
    var bigA = 65;     // 'A'
    var bigZ = 90;     // 'Z'

    var littleA = 97;  // 'a'
    var littleZ = 122; // 'z'

    var zero = 48;     // '0'
    var nine = 57;     // '9'

    var plus = 43;     // '+'
    var slash = 47;    // '/'

    var littleOffset = 26;
    var numberOffset = 52;

    // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
    if (bigA <= charCode && charCode <= bigZ) {
      return (charCode - bigA);
    }

    // 26 - 51: abcdefghijklmnopqrstuvwxyz
    if (littleA <= charCode && charCode <= littleZ) {
      return (charCode - littleA + littleOffset);
    }

    // 52 - 61: 0123456789
    if (zero <= charCode && charCode <= nine) {
      return (charCode - zero + numberOffset);
    }

    // 62: +
    if (charCode == plus) {
      return 62;
    }

    // 63: /
    if (charCode == slash) {
      return 63;
    }

    // Invalid base64 digit.
    return -1;
  };

  var base64 = {
  	encode: encode$1,
  	decode: decode$1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */



  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  var encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  var decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

  var base64Vlq = {
  	encode: encode,
  	decode: decode
  };

  var util = createCommonjsModule(function (module, exports) {
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port;
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = exports.isAbsolute(path);

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  exports.isAbsolute = function (aPath) {
    return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
  };

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // It is possible for the path to be above the root. In this case, simply
    // checking whether the root is a prefix of the path won't work. Instead, we
    // need to remove components from the root one by one, until either we find
    // a prefix that fits, or we run out of components to remove.
    var level = 0;
    while (aPath.indexOf(aRoot + '/') !== 0) {
      var index = aRoot.lastIndexOf("/");
      if (index < 0) {
        return aPath;
      }

      // If the only part of the root that is left is the scheme (i.e. http://,
      // file:///, etc.), one or more slashes (/), or simply nothing at all, we
      // have exhausted all components, so the path is not relative to the root.
      aRoot = aRoot.slice(0, index);
      if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
        return aPath;
      }

      ++level;
    }

    // Make sure we add a "../" for each component we removed from the root.
    return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
  }
  exports.relative = relative;

  var supportsNullProto = (function () {
    var obj = Object.create(null);
    return !('__proto__' in obj);
  }());

  function identity (s) {
    return s;
  }

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    if (isProtoString(aStr)) {
      return '$' + aStr;
    }

    return aStr;
  }
  exports.toSetString = supportsNullProto ? identity : toSetString;

  function fromSetString(aStr) {
    if (isProtoString(aStr)) {
      return aStr.slice(1);
    }

    return aStr;
  }
  exports.fromSetString = supportsNullProto ? identity : fromSetString;

  function isProtoString(s) {
    if (!s) {
      return false;
    }

    var length = s.length;

    if (length < 9 /* "__proto__".length */) {
      return false;
    }

    if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
        s.charCodeAt(length - 2) !== 95  /* '_' */ ||
        s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 4) !== 116 /* 't' */ ||
        s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
        s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
        s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
        s.charCodeAt(length - 8) !== 95  /* '_' */ ||
        s.charCodeAt(length - 9) !== 95  /* '_' */) {
      return false;
    }

    for (var i = length - 10; i >= 0; i--) {
      if (s.charCodeAt(i) !== 36 /* '$' */) {
        return false;
      }
    }

    return true;
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0 || onlyCompareOriginal) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0 || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

  function strcmp(aStr1, aStr2) {
    if (aStr1 === aStr2) {
      return 0;
    }

    if (aStr1 === null) {
      return 1; // aStr2 !== null
    }

    if (aStr2 === null) {
      return -1; // aStr1 !== null
    }

    if (aStr1 > aStr2) {
      return 1;
    }

    return -1;
  }

  /**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function compareByGeneratedPositionsInflated(mappingA, mappingB) {
    var cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp !== 0) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp !== 0) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  }
  exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

  /**
   * Strip any JSON XSSI avoidance prefix from the string (as documented
   * in the source maps specification), and then parse the string as
   * JSON.
   */
  function parseSourceMapInput(str) {
    return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
  }
  exports.parseSourceMapInput = parseSourceMapInput;

  /**
   * Compute the URL of a source given the the source root, the source's
   * URL, and the source map's URL.
   */
  function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
    sourceURL = sourceURL || '';

    if (sourceRoot) {
      // This follows what Chrome does.
      if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
        sourceRoot += '/';
      }
      // The spec says:
      //   Line 4: An optional source root, useful for relocating source
      //   files on a server or removing repeated values in the
      //   “sources” entry.  This value is prepended to the individual
      //   entries in the “source” field.
      sourceURL = sourceRoot + sourceURL;
    }

    // Historically, SourceMapConsumer did not take the sourceMapURL as
    // a parameter.  This mode is still somewhat supported, which is why
    // this code block is conditional.  However, it's preferable to pass
    // the source map URL to SourceMapConsumer, so that this function
    // can implement the source URL resolution algorithm as outlined in
    // the spec.  This block is basically the equivalent of:
    //    new URL(sourceURL, sourceMapURL).toString()
    // ... except it avoids using URL, which wasn't available in the
    // older releases of node still supported by this library.
    //
    // The spec says:
    //   If the sources are not absolute URLs after prepending of the
    //   “sourceRoot”, the sources are resolved relative to the
    //   SourceMap (like resolving script src in a html document).
    if (sourceMapURL) {
      var parsed = urlParse(sourceMapURL);
      if (!parsed) {
        throw new Error("sourceMapURL could not be parsed");
      }
      if (parsed.path) {
        // Strip the last path component, but keep the "/".
        var index = parsed.path.lastIndexOf('/');
        if (index >= 0) {
          parsed.path = parsed.path.substring(0, index + 1);
        }
      }
      sourceURL = join(urlGenerate(parsed), sourceURL);
    }

    return normalize(sourceURL);
  }
  exports.computeSourceURL = computeSourceURL;
  });
  util.getArg;
  util.urlParse;
  util.urlGenerate;
  util.normalize;
  util.join;
  util.isAbsolute;
  util.relative;
  util.toSetString;
  util.fromSetString;
  util.compareByOriginalPositions;
  util.compareByGeneratedPositionsDeflated;
  util.compareByGeneratedPositionsInflated;
  util.parseSourceMapInput;
  util.computeSourceURL;

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */


  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet$2() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet$2();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  ArraySet$2.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet$2.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
          return idx;
      }
    } else {
      var sStr = util.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet$2.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  var ArraySet_1 = ArraySet$2;

  var arraySet = {
  	ArraySet: ArraySet_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */



  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList$1() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList$1.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList$1.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList$1.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };

  var MappingList_1 = MappingList$1;

  var mappingList = {
  	MappingList: MappingList_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */



  var ArraySet$1 = arraySet.ArraySet;
  var MappingList = mappingList.MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator$2(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator$2.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator$2.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator$2({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }

        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }

        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator$2.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }

      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator$2.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator$2.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet$1();
      var newNames = new ArraySet$1();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator$2.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      // When aOriginal is truthy but has empty values for .line and .column,
      // it is most likely a programmer error. In this case we throw a very
      // specific error message to try to guide them the right way.
      // For example: https://github.com/Polymer/polymer-bundler/pull/519
      if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
          throw new Error(
              'original.line and original.column are not numbers -- you probably meant to omit ' +
              'the original mapping entirely and only map the generated position. If so, pass ' +
              'null for the original mapping instead of an object with empty or null values.'
          );
      }

      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator$2.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;

      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = '';

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ',';
          }
        }

        next += base64Vlq.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64Vlq.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;

          // lines are stored 0-based in SourceMap spec version 3
          next += base64Vlq.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          next += base64Vlq.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64Vlq.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }

        result += next;
      }

      return result;
    };

  SourceMapGenerator$2.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator$2.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator$2.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };

  var SourceMapGenerator_1 = SourceMapGenerator$2;

  var sourceMapGenerator = {
  	SourceMapGenerator: SourceMapGenerator_1
  };

  var binarySearch = createCommonjsModule(function (module, exports) {
  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  exports.GREATEST_LOWER_BOUND = 1;
  exports.LEAST_UPPER_BOUND = 2;

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next-closest element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element than the one we are searching for, so we return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // Our needle is greater than aHaystack[mid].
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
      }

      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return aHigh < aHaystack.length ? aHigh : -1;
      } else {
        return mid;
      }
    }
    else {
      // Our needle is less than aHaystack[mid].
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
      }

      // we are in termination case (3) or (2) and return the appropriate thing.
      if (aBias == exports.LEAST_UPPER_BOUND) {
        return mid;
      } else {
        return aLow < 0 ? -1 : aLow;
      }
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
    if (aHaystack.length === 0) {
      return -1;
    }

    var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                aCompare, aBias || exports.GREATEST_LOWER_BOUND);
    if (index < 0) {
      return -1;
    }

    // We have found either the exact element, or the next-closest element than
    // the one we are searching for. However, there may be more than one such
    // element. Make sure we always return the smallest of these.
    while (index - 1 >= 0) {
      if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
        break;
      }
      --index;
    }

    return index;
  };
  });
  binarySearch.GREATEST_LOWER_BOUND;
  binarySearch.LEAST_UPPER_BOUND;
  binarySearch.search;

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.

  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  /**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function randomIntInRange(low, high) {
    return Math.round(low + (Math.random() * (high - low)));
  }

  /**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function doQuickSort(ary, comparator, p, r) {
    // If our lower bound is less than our upper bound, we (1) partition the
    // array into two pieces and (2) recurse on each half. If it is not, this is
    // the empty array and our base case.

    if (p < r) {
      // (1) Partitioning.
      //
      // The partitioning chooses a pivot between `p` and `r` and moves all
      // elements that are less than or equal to the pivot to the before it, and
      // all the elements that are greater than it after it. The effect is that
      // once partition is done, the pivot is in the exact place it will be when
      // the array is put in sorted order, and it will not need to be moved
      // again. This runs in O(n) time.

      // Always choose a random pivot so that an input array which is reverse
      // sorted does not cause O(n^2) running time.
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;

      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      // Immediately after `j` is incremented in this loop, the following hold
      // true:
      //
      //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
      //
      //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;

      // (2) Recurse on each half.

      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  /**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  var quickSort_1 = function (ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

  var quickSort$1 = {
  	quickSort: quickSort_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */



  var ArraySet = arraySet.ArraySet;

  var quickSort = quickSort$1.quickSort;

  function SourceMapConsumer$1(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    return sourceMap.sections != null
      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
  }

  SourceMapConsumer$1.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer$1.prototype._version = 3;

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer$1.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer$1.prototype, '_generatedMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer$1.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer$1.prototype, '_originalMappings', {
    configurable: true,
    enumerable: true,
    get: function () {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer$1.prototype._charIsMappingSeparator =
    function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer$1.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };

  SourceMapConsumer$1.GENERATED_ORDER = 1;
  SourceMapConsumer$1.ORIGINAL_ORDER = 2;

  SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer$1.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer$1.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer$1.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };

  /**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */
  SourceMapConsumer$1.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, 'line');

      // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to 0, we thus find the last mapping for
      // the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: line,
        originalColumn: util.getArg(aArgs, 'column', 0)
      };

      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions,
                                    binarySearch.LEAST_UPPER_BOUND);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (aArgs.column === undefined) {
          var originalLine = mapping.originalLine;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we found. Since
          // mappings are sorted, this is guaranteed to find all mappings for
          // the line we found.
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;

          // Iterate until either we run out of mappings, or we run into
          // a mapping for a different line than the one we were searching for.
          // Since mappings are sorted, this is guaranteed to find all mappings for
          // the line we are searching for.
          while (mapping &&
                 mapping.originalLine === line &&
                 mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            });

            mapping = this._originalMappings[++index];
          }
        }
      }

      return mappings;
    };

  var SourceMapConsumer_1 = SourceMapConsumer$1;

  /**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The first parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    if (sourceRoot) {
      sourceRoot = util.normalize(sourceRoot);
    }

    sources = sources
      .map(String)
      // Some source maps produce relative source paths like "./foo.js" instead of
      // "foo.js".  Normalize these first so that future comparisons will succeed.
      // See bugzil.la/1090768.
      .map(util.normalize)
      // Always ensure that absolute sources are internally stored relative to
      // the source root, if the source root is absolute. Not doing this would
      // be particularly problematic when the source root is a prefix of the
      // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
      .map(function (source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
          ? util.relative(sourceRoot, source)
          : source;
      });

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);

    this._absoluteSources = this._sources.toArray().map(function (s) {
      return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
    });

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;

  /**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util.relative(this.sourceRoot, relativeSource);
    }

    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }

    // Maybe aSource is an absolute URL as returned by |sources|.  In
    // this case we can't simply undo the transform.
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }

    return -1;
  };

  /**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */
  BasicSourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);

      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function (s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });

      // Because we are modifying the entries (by converting string sources and
      // names to indices into the sources and names ArraySets), we have to make
      // a copy of the entry or else bad things happen. Shared mutable state
      // strikes again! See github issue #191.

      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];

      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping;
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;

        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;

          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }

          destOriginalMappings.push(destMapping);
        }

        destGeneratedMappings.push(destMapping);
      }

      quickSort(smc.__originalMappings, util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  BasicSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._absoluteSources.slice();
    }
  });

  /**
   * Provide the JIT with a nice shape / hidden class.
   */
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  BasicSourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;

      while (index < length) {
        if (aStr.charAt(index) === ';') {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        }
        else if (aStr.charAt(index) === ',') {
          index++;
        }
        else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;

          // Because each offset is encoded relative to the previous one,
          // many segments often have the same encoding. We can exploit this
          // fact by caching the parsed variable length fields of each segment,
          // allowing us to avoid a second parse if we encounter the same
          // segment again.
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);

          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64Vlq.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }

            if (segment.length === 2) {
              throw new Error('Found a source, but no line and column');
            }

            if (segment.length === 3) {
              throw new Error('Found a source and line, but no column');
            }

            cachedSegments[str] = segment;
          }

          // Generated column.
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;

          if (segment.length > 1) {
            // Original source.
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];

            // Original line.
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;

            // Original column.
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;

            if (segment.length > 4) {
              // Original name.
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }

          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            originalMappings.push(mapping);
          }
        }
      }

      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;

      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  BasicSourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator, aBias) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  BasicSourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  BasicSourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, 'name', null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: name
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
    function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() &&
        !this.sourcesContent.some(function (sc) { return sc == null; });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  BasicSourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }

      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }

      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }

      // This function is used recursively from
      // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
      // don't want to throw if we can't find the source - we just want to
      // return null, so we provide a flag to exit gracefully.
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  BasicSourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, 'source');
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }

      var needle = {
        source: source,
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND)
      );

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          };
        }
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

  /**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The first parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = util.parseSourceMapInput(aSourceMap);
    }

    var version = util.getArg(sourceMap, 'version');
    var sections = util.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();

    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        // The url field will require support for asynchronicity.
        // See https://github.com/mozilla/source-map/issues/16
        throw new Error('Support for url field in sections not implemented.');
      }
      var offset = util.getArg(s, 'offset');
      var offsetLine = util.getArg(offset, 'line');
      var offsetColumn = util.getArg(offset, 'column');

      if (offsetLine < lastOffset.line ||
          (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }
      lastOffset = offset;

      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer$1(util.getArg(s, 'map'), aSourceMapURL)
      }
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;

  /**
   * The version of the source mapping spec that we are consuming.
   */
  IndexedSourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function () {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }
      return sources;
    }
  });

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  IndexedSourceMapConsumer.prototype.originalPositionFor =
    function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      // Find the section containing the generated position we're trying to map
      // to an original position.
      var sectionIndex = binarySearch.search(needle, this._sections,
        function(needle, section) {
          var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }

          return (needle.generatedColumn -
                  section.generatedOffset.generatedColumn);
        });
      var section = this._sections[sectionIndex];

      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }

      return section.consumer.originalPositionFor({
        line: needle.generatedLine -
          (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn -
          (section.generatedOffset.generatedLine === needle.generatedLine
           ? section.generatedOffset.generatedColumn - 1
           : 0),
        bias: aArgs.bias
      });
    };

  /**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
    function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function (s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  IndexedSourceMapConsumer.prototype.sourceContentFor =
    function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      }
      else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based. 
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  IndexedSourceMapConsumer.prototype.generatedPositionFor =
    function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];

        // Only consider this section if the requested source is in the list of
        // sources of the consumer.
        if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line +
              (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column +
              (section.generatedOffset.generatedLine === generatedPosition.line
               ? section.generatedOffset.generatedColumn - 1
               : 0)
          };
          return ret;
        }
      }

      return {
        line: null,
        column: null
      };
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  IndexedSourceMapConsumer.prototype._parseMappings =
    function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];

          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);

          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }

          // The mappings coming from the consumer for the section have
          // generated positions relative to the start of the section, so we
          // need to offset them to be relative to the start of the concatenated
          // generated file.
          var adjustedMapping = {
            source: source,
            generatedLine: mapping.generatedLine +
              (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn +
              (section.generatedOffset.generatedLine === mapping.generatedLine
              ? section.generatedOffset.generatedColumn - 1
              : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name
          };

          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === 'number') {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }

      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };

  var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;

  var sourceMapConsumer = {
  	SourceMapConsumer: SourceMapConsumer_1,
  	BasicSourceMapConsumer: BasicSourceMapConsumer_1,
  	IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
  };

  /* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */

  var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;


  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode$1(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode$1.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode$1();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are accessed by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        // The last line of a file might not have a newline.
        var newLine = getNextLine() || "";
        return lineContents + newLine;

        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ?
              remainingLines[remainingLinesIndex++] : undefined;
        }
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[remainingLinesIndex] || '';
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || '';
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode$1(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode$1.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode$1.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode$1.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode$1.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode$1.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode$1.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode$1.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode$1.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode$1.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator$1(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  var SourceNode_1 = SourceNode$1;

  var sourceNode = {
  	SourceNode: SourceNode_1
  };

  /*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
  var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
  var SourceNode = sourceNode.SourceNode;

  var sourceMap = {
  	SourceMapGenerator: SourceMapGenerator,
  	SourceMapConsumer: SourceMapConsumer,
  	SourceNode: SourceNode
  };

  var codeGen = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;



  var SourceNode = undefined;

  try {
    /* istanbul ignore next */
    if (typeof undefined !== 'function' || !undefined.amd) {
      // We don't support this in AMD environments. For these environments, we asusme that
      // they are running on the browser and thus have no need for the source-map library.
      var SourceMap = sourceMap;
      SourceNode = SourceMap.SourceNode;
    }
  } catch (err) {}
  /* NOP */

  /* istanbul ignore if: tested but not covered in istanbul due to dist build  */
  if (!SourceNode) {
    SourceNode = function (line, column, srcFile, chunks) {
      this.src = '';
      if (chunks) {
        this.add(chunks);
      }
    };
    /* istanbul ignore next */
    SourceNode.prototype = {
      add: function add(chunks) {
        if (utils.isArray(chunks)) {
          chunks = chunks.join('');
        }
        this.src += chunks;
      },
      prepend: function prepend(chunks) {
        if (utils.isArray(chunks)) {
          chunks = chunks.join('');
        }
        this.src = chunks + this.src;
      },
      toStringWithSourceMap: function toStringWithSourceMap() {
        return { code: this.toString() };
      },
      toString: function toString() {
        return this.src;
      }
    };
  }

  function castChunk(chunk, codeGen, loc) {
    if (utils.isArray(chunk)) {
      var ret = [];

      for (var i = 0, len = chunk.length; i < len; i++) {
        ret.push(codeGen.wrap(chunk[i], loc));
      }
      return ret;
    } else if (typeof chunk === 'boolean' || typeof chunk === 'number') {
      // Handle primitives that the SourceNode will throw up on
      return chunk + '';
    }
    return chunk;
  }

  function CodeGen(srcFile) {
    this.srcFile = srcFile;
    this.source = [];
  }

  CodeGen.prototype = {
    isEmpty: function isEmpty() {
      return !this.source.length;
    },
    prepend: function prepend(source, loc) {
      this.source.unshift(this.wrap(source, loc));
    },
    push: function push(source, loc) {
      this.source.push(this.wrap(source, loc));
    },

    merge: function merge() {
      var source = this.empty();
      this.each(function (line) {
        source.add(['  ', line, '\n']);
      });
      return source;
    },

    each: function each(iter) {
      for (var i = 0, len = this.source.length; i < len; i++) {
        iter(this.source[i]);
      }
    },

    empty: function empty() {
      var loc = this.currentLocation || { start: {} };
      return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
    },
    wrap: function wrap(chunk) {
      var loc = arguments.length <= 1 || arguments[1] === undefined ? this.currentLocation || { start: {} } : arguments[1];

      if (chunk instanceof SourceNode) {
        return chunk;
      }

      chunk = castChunk(chunk, this, loc);

      return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
    },

    functionCall: function functionCall(fn, type, params) {
      params = this.generateList(params);
      return this.wrap([fn, type ? '.' + type + '(' : '(', params, ')']);
    },

    quotedString: function quotedString(str) {
      return '"' + (str + '').replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\u2028/g, '\\u2028') // Per Ecma-262 7.3 + 7.8.4
      .replace(/\u2029/g, '\\u2029') + '"';
    },

    objectLiteral: function objectLiteral(obj) {
      // istanbul ignore next

      var _this = this;

      var pairs = [];

      Object.keys(obj).forEach(function (key) {
        var value = castChunk(obj[key], _this);
        if (value !== 'undefined') {
          pairs.push([_this.quotedString(key), ':', value]);
        }
      });

      var ret = this.generateList(pairs);
      ret.prepend('{');
      ret.add('}');
      return ret;
    },

    generateList: function generateList(entries) {
      var ret = this.empty();

      for (var i = 0, len = entries.length; i < len; i++) {
        if (i) {
          ret.add(',');
        }

        ret.add(castChunk(entries[i], this));
      }

      return ret;
    },

    generateArray: function generateArray(entries) {
      var ret = this.generateList(entries);
      ret.prepend('[');
      ret.add(']');

      return ret;
    }
  };

  exports['default'] = CodeGen;
  module.exports = exports['default'];

  });

  unwrapExports(codeGen);

  var javascriptCompiler = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }





  var _exception2 = _interopRequireDefault(exception);





  var _codeGen2 = _interopRequireDefault(codeGen);

  function Literal(value) {
    this.value = value;
  }

  function JavaScriptCompiler() {}

  JavaScriptCompiler.prototype = {
    // PUBLIC API: You can override these methods in a subclass to provide
    // alternative compiled forms for name lookup and buffering semantics
    nameLookup: function nameLookup(parent, name /*,  type */) {
      return this.internalNameLookup(parent, name);
    },
    depthedLookup: function depthedLookup(name) {
      return [this.aliasable('container.lookup'), '(depths, ', JSON.stringify(name), ')'];
    },

    compilerInfo: function compilerInfo() {
      var revision = base$1.COMPILER_REVISION,
          versions = base$1.REVISION_CHANGES[revision];
      return [revision, versions];
    },

    appendToBuffer: function appendToBuffer(source, location, explicit) {
      // Force a source as this simplifies the merge logic.
      if (!utils.isArray(source)) {
        source = [source];
      }
      source = this.source.wrap(source, location);

      if (this.environment.isSimple) {
        return ['return ', source, ';'];
      } else if (explicit) {
        // This is a case where the buffer operation occurs as a child of another
        // construct, generally braces. We have to explicitly output these buffer
        // operations to ensure that the emitted code goes in the correct location.
        return ['buffer += ', source, ';'];
      } else {
        source.appendToBuffer = true;
        return source;
      }
    },

    initializeBuffer: function initializeBuffer() {
      return this.quotedString('');
    },
    // END PUBLIC API
    internalNameLookup: function internalNameLookup(parent, name) {
      this.lookupPropertyFunctionIsUsed = true;
      return ['lookupProperty(', parent, ',', JSON.stringify(name), ')'];
    },

    lookupPropertyFunctionIsUsed: false,

    compile: function compile(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options;
      this.stringParams = this.options.stringParams;
      this.trackIds = this.options.trackIds;
      this.precompile = !asObject;

      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        decorators: [],
        programs: [],
        environments: []
      };

      this.preamble();

      this.stackSlot = 0;
      this.stackVars = [];
      this.aliases = {};
      this.registers = { list: [] };
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];
      this.blockParams = [];

      this.compileChildren(environment, options);

      this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
      this.useBlockParams = this.useBlockParams || environment.useBlockParams;

      var opcodes = environment.opcodes,
          opcode = undefined,
          firstLoc = undefined,
          i = undefined,
          l = undefined;

      for (i = 0, l = opcodes.length; i < l; i++) {
        opcode = opcodes[i];

        this.source.currentLocation = opcode.loc;
        firstLoc = firstLoc || opcode.loc;
        this[opcode.opcode].apply(this, opcode.args);
      }

      // Flush any trailing content that might be pending.
      this.source.currentLocation = firstLoc;
      this.pushSource('');

      /* istanbul ignore next */
      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new _exception2['default']('Compile completed with content left on stack');
      }

      if (!this.decorators.isEmpty()) {
        this.useDecorators = true;

        this.decorators.prepend(['var decorators = container.decorators, ', this.lookupPropertyFunctionVarDeclaration(), ';\n']);
        this.decorators.push('return fn;');

        if (asObject) {
          this.decorators = Function.apply(this, ['fn', 'props', 'container', 'depth0', 'data', 'blockParams', 'depths', this.decorators.merge()]);
        } else {
          this.decorators.prepend('function(fn, props, container, depth0, data, blockParams, depths) {\n');
          this.decorators.push('}\n');
          this.decorators = this.decorators.merge();
        }
      } else {
        this.decorators = undefined;
      }

      var fn = this.createFunctionContext(asObject);
      if (!this.isChild) {
        var ret = {
          compiler: this.compilerInfo(),
          main: fn
        };

        if (this.decorators) {
          ret.main_d = this.decorators; // eslint-disable-line camelcase
          ret.useDecorators = true;
        }

        var _context = this.context;
        var programs = _context.programs;
        var decorators = _context.decorators;

        for (i = 0, l = programs.length; i < l; i++) {
          if (programs[i]) {
            ret[i] = programs[i];
            if (decorators[i]) {
              ret[i + '_d'] = decorators[i];
              ret.useDecorators = true;
            }
          }
        }

        if (this.environment.usePartial) {
          ret.usePartial = true;
        }
        if (this.options.data) {
          ret.useData = true;
        }
        if (this.useDepths) {
          ret.useDepths = true;
        }
        if (this.useBlockParams) {
          ret.useBlockParams = true;
        }
        if (this.options.compat) {
          ret.compat = true;
        }

        if (!asObject) {
          ret.compiler = JSON.stringify(ret.compiler);

          this.source.currentLocation = { start: { line: 1, column: 0 } };
          ret = this.objectLiteral(ret);

          if (options.srcName) {
            ret = ret.toStringWithSourceMap({ file: options.destName });
            ret.map = ret.map && ret.map.toString();
          } else {
            ret = ret.toString();
          }
        } else {
          ret.compilerOptions = this.options;
        }

        return ret;
      } else {
        return fn;
      }
    },

    preamble: function preamble() {
      // track the last context pushed into place to allow skipping the
      // getContext opcode when it would be a noop
      this.lastContext = 0;
      this.source = new _codeGen2['default'](this.options.srcName);
      this.decorators = new _codeGen2['default'](this.options.srcName);
    },

    createFunctionContext: function createFunctionContext(asObject) {
      // istanbul ignore next

      var _this = this;

      var varDeclarations = '';

      var locals = this.stackVars.concat(this.registers.list);
      if (locals.length > 0) {
        varDeclarations += ', ' + locals.join(', ');
      }

      // Generate minimizer alias mappings
      //
      // When using true SourceNodes, this will update all references to the given alias
      // as the source nodes are reused in situ. For the non-source node compilation mode,
      // aliases will not be used, but this case is already being run on the client and
      // we aren't concern about minimizing the template size.
      var aliasCount = 0;
      Object.keys(this.aliases).forEach(function (alias) {
        var node = _this.aliases[alias];
        if (node.children && node.referenceCount > 1) {
          varDeclarations += ', alias' + ++aliasCount + '=' + alias;
          node.children[0] = 'alias' + aliasCount;
        }
      });

      if (this.lookupPropertyFunctionIsUsed) {
        varDeclarations += ', ' + this.lookupPropertyFunctionVarDeclaration();
      }

      var params = ['container', 'depth0', 'helpers', 'partials', 'data'];

      if (this.useBlockParams || this.useDepths) {
        params.push('blockParams');
      }
      if (this.useDepths) {
        params.push('depths');
      }

      // Perform a second pass over the output to merge content when possible
      var source = this.mergeSource(varDeclarations);

      if (asObject) {
        params.push(source);

        return Function.apply(this, params);
      } else {
        return this.source.wrap(['function(', params.join(','), ') {\n  ', source, '}']);
      }
    },
    mergeSource: function mergeSource(varDeclarations) {
      var isSimple = this.environment.isSimple,
          appendOnly = !this.forceBuffer,
          appendFirst = undefined,
          sourceSeen = undefined,
          bufferStart = undefined,
          bufferEnd = undefined;
      this.source.each(function (line) {
        if (line.appendToBuffer) {
          if (bufferStart) {
            line.prepend('  + ');
          } else {
            bufferStart = line;
          }
          bufferEnd = line;
        } else {
          if (bufferStart) {
            if (!sourceSeen) {
              appendFirst = true;
            } else {
              bufferStart.prepend('buffer += ');
            }
            bufferEnd.add(';');
            bufferStart = bufferEnd = undefined;
          }

          sourceSeen = true;
          if (!isSimple) {
            appendOnly = false;
          }
        }
      });

      if (appendOnly) {
        if (bufferStart) {
          bufferStart.prepend('return ');
          bufferEnd.add(';');
        } else if (!sourceSeen) {
          this.source.push('return "";');
        }
      } else {
        varDeclarations += ', buffer = ' + (appendFirst ? '' : this.initializeBuffer());

        if (bufferStart) {
          bufferStart.prepend('return buffer + ');
          bufferEnd.add(';');
        } else {
          this.source.push('return buffer;');
        }
      }

      if (varDeclarations) {
        this.source.prepend('var ' + varDeclarations.substring(2) + (appendFirst ? '' : ';\n'));
      }

      return this.source.merge();
    },

    lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
      return '\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    '.trim();
    },

    // [blockValue]
    //
    // On stack, before: hash, inverse, program, value
    // On stack, after: return value of blockHelperMissing
    //
    // The purpose of this opcode is to take a block of the form
    // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
    // replace it on the stack with the result of properly
    // invoking blockHelperMissing.
    blockValue: function blockValue(name) {
      var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
          params = [this.contextName(0)];
      this.setupHelperArgs(name, 0, params);

      var blockName = this.popStack();
      params.splice(1, 0, blockName);

      this.push(this.source.functionCall(blockHelperMissing, 'call', params));
    },

    // [ambiguousBlockValue]
    //
    // On stack, before: hash, inverse, program, value
    // Compiler value, before: lastHelper=value of last found helper, if any
    // On stack, after, if no lastHelper: same as [blockValue]
    // On stack, after, if lastHelper: value
    ambiguousBlockValue: function ambiguousBlockValue() {
      // We're being a bit cheeky and reusing the options value from the prior exec
      var blockHelperMissing = this.aliasable('container.hooks.blockHelperMissing'),
          params = [this.contextName(0)];
      this.setupHelperArgs('', 0, params, true);

      this.flushInline();

      var current = this.topStack();
      params.splice(1, 0, current);

      this.pushSource(['if (!', this.lastHelper, ') { ', current, ' = ', this.source.functionCall(blockHelperMissing, 'call', params), '}']);
    },

    // [appendContent]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Appends the string value of `content` to the current buffer
    appendContent: function appendContent(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      } else {
        this.pendingLocation = this.source.currentLocation;
      }

      this.pendingContent = content;
    },

    // [append]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Coerces `value` to a String and appends it to the current buffer.
    //
    // If `value` is truthy, or 0, it is coerced into a string and appended
    // Otherwise, the empty string is appended
    append: function append() {
      if (this.isInline()) {
        this.replaceStack(function (current) {
          return [' != null ? ', current, ' : ""'];
        });

        this.pushSource(this.appendToBuffer(this.popStack()));
      } else {
        var local = this.popStack();
        this.pushSource(['if (', local, ' != null) { ', this.appendToBuffer(local, undefined, true), ' }']);
        if (this.environment.isSimple) {
          this.pushSource(['else { ', this.appendToBuffer("''", undefined, true), ' }']);
        }
      }
    },

    // [appendEscaped]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Escape `value` and append it to the buffer
    appendEscaped: function appendEscaped() {
      this.pushSource(this.appendToBuffer([this.aliasable('container.escapeExpression'), '(', this.popStack(), ')']));
    },

    // [getContext]
    //
    // On stack, before: ...
    // On stack, after: ...
    // Compiler value, after: lastContext=depth
    //
    // Set the value of the `lastContext` compiler value to the depth
    getContext: function getContext(depth) {
      this.lastContext = depth;
    },

    // [pushContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext, ...
    //
    // Pushes the value of the current context onto the stack.
    pushContext: function pushContext() {
      this.pushStackLiteral(this.contextName(this.lastContext));
    },

    // [lookupOnContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext[name], ...
    //
    // Looks up the value of `name` on the current context and pushes
    // it onto the stack.
    lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
      var i = 0;

      if (!scoped && this.options.compat && !this.lastContext) {
        // The depthed query is expected to handle the undefined logic for the root level that
        // is implemented below, so we evaluate that directly in compat mode
        this.push(this.depthedLookup(parts[i++]));
      } else {
        this.pushContext();
      }

      this.resolvePath('context', parts, i, falsy, strict);
    },

    // [lookupBlockParam]
    //
    // On stack, before: ...
    // On stack, after: blockParam[name], ...
    //
    // Looks up the value of `parts` on the given block param and pushes
    // it onto the stack.
    lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
      this.useBlockParams = true;

      this.push(['blockParams[', blockParamId[0], '][', blockParamId[1], ']']);
      this.resolvePath('context', parts, 1);
    },

    // [lookupData]
    //
    // On stack, before: ...
    // On stack, after: data, ...
    //
    // Push the data lookup operator
    lookupData: function lookupData(depth, parts, strict) {
      if (!depth) {
        this.pushStackLiteral('data');
      } else {
        this.pushStackLiteral('container.data(data, ' + depth + ')');
      }

      this.resolvePath('data', parts, 0, true, strict);
    },

    resolvePath: function resolvePath(type, parts, i, falsy, strict) {
      // istanbul ignore next

      var _this2 = this;

      if (this.options.strict || this.options.assumeObjects) {
        this.push(strictLookup(this.options.strict && strict, this, parts, type));
        return;
      }

      var len = parts.length;
      for (; i < len; i++) {
        /* eslint-disable no-loop-func */
        this.replaceStack(function (current) {
          var lookup = _this2.nameLookup(current, parts[i], type);
          // We want to ensure that zero and false are handled properly if the context (falsy flag)
          // needs to have the special handling for these values.
          if (!falsy) {
            return [' != null ? ', lookup, ' : ', current];
          } else {
            // Otherwise we can use generic falsy handling
            return [' && ', lookup];
          }
        });
        /* eslint-enable no-loop-func */
      }
    },

    // [resolvePossibleLambda]
    //
    // On stack, before: value, ...
    // On stack, after: resolved value, ...
    //
    // If the `value` is a lambda, replace it on the stack by
    // the return value of the lambda
    resolvePossibleLambda: function resolvePossibleLambda() {
      this.push([this.aliasable('container.lambda'), '(', this.popStack(), ', ', this.contextName(0), ')']);
    },

    // [pushStringParam]
    //
    // On stack, before: ...
    // On stack, after: string, currentContext, ...
    //
    // This opcode is designed for use in string mode, which
    // provides the string value of a parameter along with its
    // depth rather than resolving it immediately.
    pushStringParam: function pushStringParam(string, type) {
      this.pushContext();
      this.pushString(type);

      // If it's a subexpression, the string result
      // will be pushed after this opcode.
      if (type !== 'SubExpression') {
        if (typeof string === 'string') {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },

    emptyHash: function emptyHash(omitEmpty) {
      if (this.trackIds) {
        this.push('{}'); // hashIds
      }
      if (this.stringParams) {
        this.push('{}'); // hashContexts
        this.push('{}'); // hashTypes
      }
      this.pushStackLiteral(omitEmpty ? 'undefined' : '{}');
    },
    pushHash: function pushHash() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }
      this.hash = { values: {}, types: [], contexts: [], ids: [] };
    },
    popHash: function popHash() {
      var hash = this.hash;
      this.hash = this.hashes.pop();

      if (this.trackIds) {
        this.push(this.objectLiteral(hash.ids));
      }
      if (this.stringParams) {
        this.push(this.objectLiteral(hash.contexts));
        this.push(this.objectLiteral(hash.types));
      }

      this.push(this.objectLiteral(hash.values));
    },

    // [pushString]
    //
    // On stack, before: ...
    // On stack, after: quotedString(string), ...
    //
    // Push a quoted version of `string` onto the stack
    pushString: function pushString(string) {
      this.pushStackLiteral(this.quotedString(string));
    },

    // [pushLiteral]
    //
    // On stack, before: ...
    // On stack, after: value, ...
    //
    // Pushes a value onto the stack. This operation prevents
    // the compiler from creating a temporary variable to hold
    // it.
    pushLiteral: function pushLiteral(value) {
      this.pushStackLiteral(value);
    },

    // [pushProgram]
    //
    // On stack, before: ...
    // On stack, after: program(guid), ...
    //
    // Push a program expression onto the stack. This takes
    // a compile-time guid and converts it into a runtime-accessible
    // expression.
    pushProgram: function pushProgram(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },

    // [registerDecorator]
    //
    // On stack, before: hash, program, params..., ...
    // On stack, after: ...
    //
    // Pops off the decorator's parameters, invokes the decorator,
    // and inserts the decorator into the decorators list.
    registerDecorator: function registerDecorator(paramSize, name) {
      var foundDecorator = this.nameLookup('decorators', name, 'decorator'),
          options = this.setupHelperArgs(name, paramSize);

      this.decorators.push(['fn = ', this.decorators.functionCall(foundDecorator, '', ['fn', 'props', 'container', options]), ' || fn;']);
    },

    // [invokeHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // Pops off the helper's parameters, invokes the helper,
    // and pushes the helper's return value onto the stack.
    //
    // If the helper is not found, `helperMissing` is called.
    invokeHelper: function invokeHelper(paramSize, name, isSimple) {
      var nonHelper = this.popStack(),
          helper = this.setupHelper(paramSize, name);

      var possibleFunctionCalls = [];

      if (isSimple) {
        // direct call to helper
        possibleFunctionCalls.push(helper.name);
      }
      // call a function from the input object
      possibleFunctionCalls.push(nonHelper);
      if (!this.options.strict) {
        possibleFunctionCalls.push(this.aliasable('container.hooks.helperMissing'));
      }

      var functionLookupCode = ['(', this.itemsSeparatedBy(possibleFunctionCalls, '||'), ')'];
      var functionCall = this.source.functionCall(functionLookupCode, 'call', helper.callParams);
      this.push(functionCall);
    },

    itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
      var result = [];
      result.push(items[0]);
      for (var i = 1; i < items.length; i++) {
        result.push(separator, items[i]);
      }
      return result;
    },
    // [invokeKnownHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // This operation is used when the helper is known to exist,
    // so a `helperMissing` fallback is not required.
    invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(this.source.functionCall(helper.name, 'call', helper.callParams));
    },

    // [invokeAmbiguous]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of disambiguation
    //
    // This operation is used when an expression like `{{foo}}`
    // is provided, but we don't know at compile-time whether it
    // is a helper or a path.
    //
    // This operation emits more code than the other options,
    // and can be avoided by passing the `knownHelpers` and
    // `knownHelpersOnly` flags at compile-time.
    invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
      this.useRegister('helper');

      var nonHelper = this.popStack();

      this.emptyHash();
      var helper = this.setupHelper(0, name, helperCall);

      var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

      var lookup = ['(', '(helper = ', helperName, ' || ', nonHelper, ')'];
      if (!this.options.strict) {
        lookup[0] = '(helper = ';
        lookup.push(' != null ? helper : ', this.aliasable('container.hooks.helperMissing'));
      }

      this.push(['(', lookup, helper.paramsInit ? ['),(', helper.paramsInit] : [], '),', '(typeof helper === ', this.aliasable('"function"'), ' ? ', this.source.functionCall('helper', 'call', helper.callParams), ' : helper))']);
    },

    // [invokePartial]
    //
    // On stack, before: context, ...
    // On stack after: result of partial invocation
    //
    // This operation pops off a context, invokes a partial with that context,
    // and pushes the result of the invocation back.
    invokePartial: function invokePartial(isDynamic, name, indent) {
      var params = [],
          options = this.setupParams(name, 1, params);

      if (isDynamic) {
        name = this.popStack();
        delete options.name;
      }

      if (indent) {
        options.indent = JSON.stringify(indent);
      }
      options.helpers = 'helpers';
      options.partials = 'partials';
      options.decorators = 'container.decorators';

      if (!isDynamic) {
        params.unshift(this.nameLookup('partials', name, 'partial'));
      } else {
        params.unshift(name);
      }

      if (this.options.compat) {
        options.depths = 'depths';
      }
      options = this.objectLiteral(options);
      params.push(options);

      this.push(this.source.functionCall('container.invokePartial', '', params));
    },

    // [assignToHash]
    //
    // On stack, before: value, ..., hash, ...
    // On stack, after: ..., hash, ...
    //
    // Pops a value off the stack and assigns it to the current hash
    assignToHash: function assignToHash(key) {
      var value = this.popStack(),
          context = undefined,
          type = undefined,
          id = undefined;

      if (this.trackIds) {
        id = this.popStack();
      }
      if (this.stringParams) {
        type = this.popStack();
        context = this.popStack();
      }

      var hash = this.hash;
      if (context) {
        hash.contexts[key] = context;
      }
      if (type) {
        hash.types[key] = type;
      }
      if (id) {
        hash.ids[key] = id;
      }
      hash.values[key] = value;
    },

    pushId: function pushId(type, name, child) {
      if (type === 'BlockParam') {
        this.pushStackLiteral('blockParams[' + name[0] + '].path[' + name[1] + ']' + (child ? ' + ' + JSON.stringify('.' + child) : ''));
      } else if (type === 'PathExpression') {
        this.pushString(name);
      } else if (type === 'SubExpression') {
        this.pushStackLiteral('true');
      } else {
        this.pushStackLiteral('null');
      }
    },

    // HELPERS

    compiler: JavaScriptCompiler,

    compileChildren: function compileChildren(environment, options) {
      var children = environment.children,
          child = undefined,
          compiler = undefined;

      for (var i = 0, l = children.length; i < l; i++) {
        child = children[i];
        compiler = new this.compiler(); // eslint-disable-line new-cap

        var existing = this.matchExistingProgram(child);

        if (existing == null) {
          this.context.programs.push(''); // Placeholder to prevent name conflicts for nested children
          var index = this.context.programs.length;
          child.index = index;
          child.name = 'program' + index;
          this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
          this.context.decorators[index] = compiler.decorators;
          this.context.environments[index] = child;

          this.useDepths = this.useDepths || compiler.useDepths;
          this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
          child.useDepths = this.useDepths;
          child.useBlockParams = this.useBlockParams;
        } else {
          child.index = existing.index;
          child.name = 'program' + existing.index;

          this.useDepths = this.useDepths || existing.useDepths;
          this.useBlockParams = this.useBlockParams || existing.useBlockParams;
        }
      }
    },
    matchExistingProgram: function matchExistingProgram(child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return environment;
        }
      }
    },

    programExpression: function programExpression(guid) {
      var child = this.environment.children[guid],
          programParams = [child.index, 'data', child.blockParams];

      if (this.useBlockParams || this.useDepths) {
        programParams.push('blockParams');
      }
      if (this.useDepths) {
        programParams.push('depths');
      }

      return 'container.program(' + programParams.join(', ') + ')';
    },

    useRegister: function useRegister(name) {
      if (!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },

    push: function push(expr) {
      if (!(expr instanceof Literal)) {
        expr = this.source.wrap(expr);
      }

      this.inlineStack.push(expr);
      return expr;
    },

    pushStackLiteral: function pushStackLiteral(item) {
      this.push(new Literal(item));
    },

    pushSource: function pushSource(source) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
        this.pendingContent = undefined;
      }

      if (source) {
        this.source.push(source);
      }
    },

    replaceStack: function replaceStack(callback) {
      var prefix = ['('],
          stack = undefined,
          createdStack = undefined,
          usedLiteral = undefined;

      /* istanbul ignore next */
      if (!this.isInline()) {
        throw new _exception2['default']('replaceStack on non-inline');
      }

      // We want to merge the inline statement into the replacement statement via ','
      var top = this.popStack(true);

      if (top instanceof Literal) {
        // Literals do not need to be inlined
        stack = [top.value];
        prefix = ['(', stack];
        usedLiteral = true;
      } else {
        // Get or create the current stack name for use by the inline
        createdStack = true;
        var _name = this.incrStack();

        prefix = ['((', this.push(_name), ' = ', top, ')'];
        stack = this.topStack();
      }

      var item = callback.call(this, stack);

      if (!usedLiteral) {
        this.popStack();
      }
      if (createdStack) {
        this.stackSlot--;
      }
      this.push(prefix.concat(item, ')'));
    },

    incrStack: function incrStack() {
      this.stackSlot++;
      if (this.stackSlot > this.stackVars.length) {
        this.stackVars.push('stack' + this.stackSlot);
      }
      return this.topStackName();
    },
    topStackName: function topStackName() {
      return 'stack' + this.stackSlot;
    },
    flushInline: function flushInline() {
      var inlineStack = this.inlineStack;
      this.inlineStack = [];
      for (var i = 0, len = inlineStack.length; i < len; i++) {
        var entry = inlineStack[i];
        /* istanbul ignore if */
        if (entry instanceof Literal) {
          this.compileStack.push(entry);
        } else {
          var stack = this.incrStack();
          this.pushSource([stack, ' = ', entry, ';']);
          this.compileStack.push(stack);
        }
      }
    },
    isInline: function isInline() {
      return this.inlineStack.length;
    },

    popStack: function popStack(wrapped) {
      var inline = this.isInline(),
          item = (inline ? this.inlineStack : this.compileStack).pop();

      if (!wrapped && item instanceof Literal) {
        return item.value;
      } else {
        if (!inline) {
          /* istanbul ignore next */
          if (!this.stackSlot) {
            throw new _exception2['default']('Invalid stack pop');
          }
          this.stackSlot--;
        }
        return item;
      }
    },

    topStack: function topStack() {
      var stack = this.isInline() ? this.inlineStack : this.compileStack,
          item = stack[stack.length - 1];

      /* istanbul ignore if */
      if (item instanceof Literal) {
        return item.value;
      } else {
        return item;
      }
    },

    contextName: function contextName(context) {
      if (this.useDepths && context) {
        return 'depths[' + context + ']';
      } else {
        return 'depth' + context;
      }
    },

    quotedString: function quotedString(str) {
      return this.source.quotedString(str);
    },

    objectLiteral: function objectLiteral(obj) {
      return this.source.objectLiteral(obj);
    },

    aliasable: function aliasable(name) {
      var ret = this.aliases[name];
      if (ret) {
        ret.referenceCount++;
        return ret;
      }

      ret = this.aliases[name] = this.source.wrap(name);
      ret.aliasable = true;
      ret.referenceCount = 1;

      return ret;
    },

    setupHelper: function setupHelper(paramSize, name, blockHelper) {
      var params = [],
          paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
      var foundHelper = this.nameLookup('helpers', name, 'helper'),
          callContext = this.aliasable(this.contextName(0) + ' != null ? ' + this.contextName(0) + ' : (container.nullContext || {})');

      return {
        params: params,
        paramsInit: paramsInit,
        name: foundHelper,
        callParams: [callContext].concat(params)
      };
    },

    setupParams: function setupParams(helper, paramSize, params) {
      var options = {},
          contexts = [],
          types = [],
          ids = [],
          objectArgs = !params,
          param = undefined;

      if (objectArgs) {
        params = [];
      }

      options.name = this.quotedString(helper);
      options.hash = this.popStack();

      if (this.trackIds) {
        options.hashIds = this.popStack();
      }
      if (this.stringParams) {
        options.hashTypes = this.popStack();
        options.hashContexts = this.popStack();
      }

      var inverse = this.popStack(),
          program = this.popStack();

      // Avoid setting fn and inverse if neither are set. This allows
      // helpers to do a check for `if (options.fn)`
      if (program || inverse) {
        options.fn = program || 'container.noop';
        options.inverse = inverse || 'container.noop';
      }

      // The parameters go on to the stack in order (making sure that they are evaluated in order)
      // so we need to pop them off the stack in reverse order
      var i = paramSize;
      while (i--) {
        param = this.popStack();
        params[i] = param;

        if (this.trackIds) {
          ids[i] = this.popStack();
        }
        if (this.stringParams) {
          types[i] = this.popStack();
          contexts[i] = this.popStack();
        }
      }

      if (objectArgs) {
        options.args = this.source.generateArray(params);
      }

      if (this.trackIds) {
        options.ids = this.source.generateArray(ids);
      }
      if (this.stringParams) {
        options.types = this.source.generateArray(types);
        options.contexts = this.source.generateArray(contexts);
      }

      if (this.options.data) {
        options.data = 'data';
      }
      if (this.useBlockParams) {
        options.blockParams = 'blockParams';
      }
      return options;
    },

    setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
      var options = this.setupParams(helper, paramSize, params);
      options.loc = JSON.stringify(this.source.currentLocation);
      options = this.objectLiteral(options);
      if (useRegister) {
        this.useRegister('options');
        params.push('options');
        return ['options=', options];
      } else if (params) {
        params.push(options);
        return '';
      } else {
        return options;
      }
    }
  };

  (function () {
    var reservedWords = ('break else new var' + ' case finally return void' + ' catch for switch while' + ' continue function this with' + ' default if throw' + ' delete in try' + ' do instanceof typeof' + ' abstract enum int short' + ' boolean export interface static' + ' byte extends long super' + ' char final native synchronized' + ' class float package throws' + ' const goto private transient' + ' debugger implements protected volatile' + ' double import public let yield await' + ' null true false').split(' ');

    var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

    for (var i = 0, l = reservedWords.length; i < l; i++) {
      compilerWords[reservedWords[i]] = true;
    }
  })();

  /**
   * @deprecated May be removed in the next major version
   */
  JavaScriptCompiler.isValidJavaScriptVariableName = function (name) {
    return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
  };

  function strictLookup(requireTerminal, compiler, parts, type) {
    var stack = compiler.popStack(),
        i = 0,
        len = parts.length;
    if (requireTerminal) {
      len--;
    }

    for (; i < len; i++) {
      stack = compiler.nameLookup(stack, parts[i], type);
    }

    if (requireTerminal) {
      return [compiler.aliasable('container.strict'), '(', stack, ', ', compiler.quotedString(parts[i]), ', ', JSON.stringify(compiler.source.currentLocation), ' )'];
    } else {
      return stack;
    }
  }

  exports['default'] = JavaScriptCompiler;
  module.exports = exports['default'];

  });

  unwrapExports(javascriptCompiler);

  var handlebars$1 = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _handlebarsRuntime2 = _interopRequireDefault(handlebars_runtime);

  // Compiler imports



  var _handlebarsCompilerAst2 = _interopRequireDefault(ast);







  var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(javascriptCompiler);



  var _handlebarsCompilerVisitor2 = _interopRequireDefault(visitor);



  var _handlebarsNoConflict2 = _interopRequireDefault(noConflict);

  var _create = _handlebarsRuntime2['default'].create;
  function create() {
    var hb = _create();

    hb.compile = function (input, options) {
      return compiler.compile(input, options, hb);
    };
    hb.precompile = function (input, options) {
      return compiler.precompile(input, options, hb);
    };

    hb.AST = _handlebarsCompilerAst2['default'];
    hb.Compiler = compiler.Compiler;
    hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2['default'];
    hb.Parser = base.parser;
    hb.parse = base.parse;
    hb.parseWithoutProcessing = base.parseWithoutProcessing;

    return hb;
  }

  var inst = create();
  inst.create = create;

  _handlebarsNoConflict2['default'](inst);

  inst.Visitor = _handlebarsCompilerVisitor2['default'];

  inst['default'] = inst;

  exports['default'] = inst;
  module.exports = exports['default'];

  });

  unwrapExports(handlebars$1);

  var printer = createCommonjsModule(function (module, exports) {

  exports.__esModule = true;
  exports.print = print;
  exports.PrintVisitor = PrintVisitor;
  // istanbul ignore next

  function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }



  var _visitor2 = _interopRequireDefault(visitor);

  function print(ast) {
    return new PrintVisitor().accept(ast);
  }

  function PrintVisitor() {
    this.padding = 0;
  }

  PrintVisitor.prototype = new _visitor2['default']();

  PrintVisitor.prototype.pad = function (string) {
    var out = '';

    for (var i = 0, l = this.padding; i < l; i++) {
      out += '  ';
    }

    out += string + '\n';
    return out;
  };

  PrintVisitor.prototype.Program = function (program) {
    var out = '',
        body = program.body,
        i = undefined,
        l = undefined;

    if (program.blockParams) {
      var blockParams = 'BLOCK PARAMS: [';
      for (i = 0, l = program.blockParams.length; i < l; i++) {
        blockParams += ' ' + program.blockParams[i];
      }
      blockParams += ' ]';
      out += this.pad(blockParams);
    }

    for (i = 0, l = body.length; i < l; i++) {
      out += this.accept(body[i]);
    }

    this.padding--;

    return out;
  };

  PrintVisitor.prototype.MustacheStatement = function (mustache) {
    return this.pad('{{ ' + this.SubExpression(mustache) + ' }}');
  };
  PrintVisitor.prototype.Decorator = function (mustache) {
    return this.pad('{{ DIRECTIVE ' + this.SubExpression(mustache) + ' }}');
  };

  PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function (block) {
    var out = '';

    out += this.pad((block.type === 'DecoratorBlock' ? 'DIRECTIVE ' : '') + 'BLOCK:');
    this.padding++;
    out += this.pad(this.SubExpression(block));
    if (block.program) {
      out += this.pad('PROGRAM:');
      this.padding++;
      out += this.accept(block.program);
      this.padding--;
    }
    if (block.inverse) {
      if (block.program) {
        this.padding++;
      }
      out += this.pad('{{^}}');
      this.padding++;
      out += this.accept(block.inverse);
      this.padding--;
      if (block.program) {
        this.padding--;
      }
    }
    this.padding--;

    return out;
  };

  PrintVisitor.prototype.PartialStatement = function (partial) {
    var content = 'PARTIAL:' + partial.name.original;
    if (partial.params[0]) {
      content += ' ' + this.accept(partial.params[0]);
    }
    if (partial.hash) {
      content += ' ' + this.accept(partial.hash);
    }
    return this.pad('{{> ' + content + ' }}');
  };
  PrintVisitor.prototype.PartialBlockStatement = function (partial) {
    var content = 'PARTIAL BLOCK:' + partial.name.original;
    if (partial.params[0]) {
      content += ' ' + this.accept(partial.params[0]);
    }
    if (partial.hash) {
      content += ' ' + this.accept(partial.hash);
    }

    content += ' ' + this.pad('PROGRAM:');
    this.padding++;
    content += this.accept(partial.program);
    this.padding--;

    return this.pad('{{> ' + content + ' }}');
  };

  PrintVisitor.prototype.ContentStatement = function (content) {
    return this.pad("CONTENT[ '" + content.value + "' ]");
  };

  PrintVisitor.prototype.CommentStatement = function (comment) {
    return this.pad("{{! '" + comment.value + "' }}");
  };

  PrintVisitor.prototype.SubExpression = function (sexpr) {
    var params = sexpr.params,
        paramStrings = [],
        hash = undefined;

    for (var i = 0, l = params.length; i < l; i++) {
      paramStrings.push(this.accept(params[i]));
    }

    params = '[' + paramStrings.join(', ') + ']';

    hash = sexpr.hash ? ' ' + this.accept(sexpr.hash) : '';

    return this.accept(sexpr.path) + ' ' + params + hash;
  };

  PrintVisitor.prototype.PathExpression = function (id) {
    var path = id.parts.join('/');
    return (id.data ? '@' : '') + 'PATH:' + path;
  };

  PrintVisitor.prototype.StringLiteral = function (string) {
    return '"' + string.value + '"';
  };

  PrintVisitor.prototype.NumberLiteral = function (number) {
    return 'NUMBER{' + number.value + '}';
  };

  PrintVisitor.prototype.BooleanLiteral = function (bool) {
    return 'BOOLEAN{' + bool.value + '}';
  };

  PrintVisitor.prototype.UndefinedLiteral = function () {
    return 'UNDEFINED';
  };

  PrintVisitor.prototype.NullLiteral = function () {
    return 'NULL';
  };

  PrintVisitor.prototype.Hash = function (hash) {
    var pairs = hash.pairs,
        joinedPairs = [];

    for (var i = 0, l = pairs.length; i < l; i++) {
      joinedPairs.push(this.accept(pairs[i]));
    }

    return 'HASH{' + joinedPairs.join(', ') + '}';
  };
  PrintVisitor.prototype.HashPair = function (pair) {
    return pair.key + '=' + this.accept(pair.value);
  };
  /* eslint-enable new-cap */

  });

  unwrapExports(printer);
  printer.print;
  printer.PrintVisitor;

  var empty = {};

  var empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': empty
  });

  var require$$1 = getCjsExportFromNamespace(empty$1);

  // USAGE:
  // var handlebars = require('handlebars');
  /* eslint-disable no-var */

  // var local = handlebars.create();

  var handlebars = handlebars$1['default'];


  handlebars.PrintVisitor = printer.PrintVisitor;
  handlebars.print = printer.print;

  var lib = handlebars;

  // Publish a Node.js require() handler for .handlebars and .hbs files
  function extension(module, filename) {
    var fs = require$$1;
    var templateString = fs.readFileSync(filename, 'utf8');
    module.exports = handlebars.compile(templateString);
  }
  /* istanbul ignore else */
  if (typeof commonjsRequire !== 'undefined' && commonjsRequire.extensions) {
    commonjsRequire.extensions['.handlebars'] = extension;
    commonjsRequire.extensions['.hbs'] = extension;
  }

  var PhaserText = Phaser.GameObjects.Text;

  var CreateText = function CreateText(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles);
    var text = data.text;

    if (view !== undefined) {
      var template = lib.compile(text);
      text = template(view);
    }

    var gameObject = new PhaserText(scene, 0, 0, text, data);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var CreateRoundRectangle = function CreateRoundRectangle(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles);
    var width = data.width === undefined ? 1 : data.width;
    var height = data.height === undefined ? 1 : data.height;
    var gameObject = new RoundRectangle$1(scene, 0, 0, width, height, data.radius);

    if (data.color !== undefined) {
      gameObject.setFillStyle(data.color);
    }

    if (data.strokeColor !== undefined) {
      var strokeWidth = data.strokeWidth;

      if (strokeWidth === undefined) {
        strokeWidth = 2;
      }

      gameObject.setStrokeStyle(strokeWidth, data.strokeColor);
    }

    scene.add.existing(gameObject);
    return gameObject;
  };

  var CreateNinePatch$1 = function CreateNinePatch(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles);
    var gameObject = new NinePatch$1(scene, data);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var CreateNinePatch = function CreateNinePatch(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles);
    var gameObject = new NinePatch(scene, data);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var CreateChild = function CreateChild(scene, data, subKey, view, styles, customBuilders) {
    var childData = data[subKey];

    if (!childData) {
      return undefined;
    }

    var child;
    child = Make(scene, childData, view, styles, customBuilders);
    data[subKey] = child;
    return child;
  };

  var CreateSizer = function CreateSizer(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles);
    var backgroundConfig = data.background;
    delete data.background;

    if (backgroundConfig) {
      if (!Array.isArray(backgroundConfig)) {
        backgroundConfig = [backgroundConfig];
      }

      for (var i = 0, cnt = backgroundConfig.length; i < cnt; i++) {
        var childConfig = backgroundConfig[i];

        if (!childConfig.child) {
          childConfig = {
            child: childConfig
          };
          backgroundConfig[i] = childConfig;
        }

        CreateChild(scene, childConfig, 'child', view, styles, customBuilders);
      }
    }

    var childrenConfig = data.children;
    delete data.children;

    if (childrenConfig) {
      for (var i = 0, cnt = childrenConfig.length; i < cnt; i++) {
        var childConfig = childrenConfig[i];

        if (!childConfig.child) {
          childConfig = {
            child: childConfig
          };
          childrenConfig[i] = childConfig;
        }

        CreateChild(scene, childConfig, 'child', view, styles, customBuilders);
      }
    }

    var gameObject = new Sizer(scene, data);
    scene.add.existing(gameObject);

    if (backgroundConfig) {
      for (var i = 0, cnt = backgroundConfig.length; i < cnt; i++) {
        var childConfig = backgroundConfig[i];
        gameObject.addBackground(childConfig.child, childConfig.padding);
      }
    }

    if (childrenConfig) {
      for (var i = 0, cnt = childrenConfig.length; i < cnt; i++) {
        var childConfig = childrenConfig[i];
        gameObject.add(childConfig.child, childConfig);
      }
    }

    return gameObject;
  };

  var CreateFixWidthSizer = function CreateFixWidthSizer(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles);
    var backgroundConfig = data.background;
    delete data.background;

    if (backgroundConfig) {
      if (!Array.isArray(backgroundConfig)) {
        backgroundConfig = [backgroundConfig];
      }

      for (var i = 0, cnt = backgroundConfig.length; i < cnt; i++) {
        var childConfig = backgroundConfig[i];

        if (!childConfig.child) {
          childConfig = {
            child: childConfig
          };
          backgroundConfig[i] = childConfig;
        }

        CreateChild(scene, childConfig, 'child', view, styles, customBuilders);
      }
    }

    var childrenConfig = data.children;
    delete data.children;

    if (childrenConfig) {
      for (var i = 0, cnt = childrenConfig.length; i < cnt; i++) {
        var childConfig = childrenConfig[i];

        if (!childConfig.child) {
          childConfig = {
            child: childConfig
          };
          childrenConfig[i] = childConfig;
        }

        CreateChild(scene, childConfig, 'child', view, styles, customBuilders);
      }
    }

    var gameObject = new FixWidthSizer(scene, data);
    scene.add.existing(gameObject);

    if (backgroundConfig) {
      for (var i = 0, cnt = backgroundConfig.length; i < cnt; i++) {
        var childConfig = backgroundConfig[i];
        gameObject.addBackground(childConfig.child, childConfig.padding);
      }
    }

    if (childrenConfig) {
      for (var i = 0, cnt = childrenConfig.length; i < cnt; i++) {
        var childConfig = childrenConfig[i];
        gameObject.add(childConfig.child, childConfig);
      }
    }

    return gameObject;
  };

  var CreateLabel = function CreateLabel(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles); // Replace data by child game object

    CreateChild(scene, data, 'background', view, styles, customBuilders);
    CreateChild(scene, data, 'icon', view, styles, customBuilders);
    CreateChild(scene, data, 'text', view, styles, customBuilders);
    CreateChild(scene, data, 'action', view, styles, customBuilders);
    var gameObject = new Label(scene, data);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var CreateChildren = function CreateChildren(scene, data, subKey, view, styles, customBuilders) {
    var childData = data[subKey];

    if (!childData) {
      return undefined;
    }

    if (Array.isArray(childData)) {
      for (var i = 0, cnt = childData.length; i < cnt; i++) {
        CreateChild(scene, childData, i, view, styles, customBuilders);
      }
    } else {
      for (var key in childData) {
        CreateChild(scene, childData, key, view, styles, customBuilders);
      }
    }

    return childData;
  };

  var CreateDialog = function CreateDialog(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles); // Replace data by child game object

    CreateChild(scene, data, 'background', view, styles, customBuilders);
    CreateChild(scene, data, 'toolbarBackground', view, styles, customBuilders);
    CreateChild(scene, data, 'leftToolbarBackground', view, styles, customBuilders);
    CreateChild(scene, data, 'choicesBackground', view, styles, customBuilders);
    CreateChild(scene, data, 'actionsBackground', view, styles, customBuilders);
    CreateChild(scene, data, 'title', view, styles, customBuilders);
    CreateChildren(scene, data, 'toolbar', view, styles, customBuilders);
    CreateChildren(scene, data, 'leftToolbar', view, styles, customBuilders);
    CreateChild(scene, data, 'content', view, styles, customBuilders);
    CreateChild(scene, data, 'description', view, styles, customBuilders);
    CreateChildren(scene, data, 'choices', view, styles, customBuilders);
    CreateChildren(scene, data, 'actions', view, styles, customBuilders);
    var gameObject = new Dialog(scene, data);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var CreateSlider = function CreateSlider(scene, data, view, styles, customBuilders) {
    data = MergeStyle(data, styles); // Replace data by child game object

    CreateChild(scene, data, 'background', view, styles, customBuilders);
    CreateChild(scene, data, 'track', view, styles, customBuilders);
    CreateChild(scene, data, 'indicator', view, styles, customBuilders);
    CreateChild(scene, data, 'thumb', view, styles, customBuilders);
    var gameObject = new Slider$1(scene, data);
    scene.add.existing(gameObject);
    return gameObject;
  };

  var Builders = {
    Image: CreateImage,
    Text: CreateText,
    RoundRectangle: CreateRoundRectangle,
    Ninepatch: CreateNinePatch$1,
    Ninepatch2: CreateNinePatch,
    Sizer: CreateSizer,
    FixWidthSizer: CreateFixWidthSizer,
    Label: CreateLabel,
    Dialog: CreateDialog,
    Slider: CreateSlider
  };

  var Make = function Make(scene, data, view, styles, customBuilders) {
    var type = data.$type;
    var callback;

    if (customBuilders) {
      callback = customBuilders[type];
    }

    if (!callback) {
      callback = Builders[type];
    }

    if (!callback) {
      console.warn("rexUI.Make: Can't create ".concat(type, " game object."));
      return undefined;
    }

    var gameObject = callback(scene, data, view, styles, customBuilders);

    if (data.name) {
      gameObject.setName(data.name);
    }

    return gameObject;
  };

  var YAMLMake = function YAMLMake(scene, data, view, styles, customBuilders) {
    data = ParseYAML(data); // Parsing result of YAML data might be an array, 
    // Only last item will be used to create game object, others are references

    if (Array.isArray(data)) {
      data = data[data.length - 1];
    }

    view = ParseYAML(view);
    styles = ParseYAML(styles);
    var gameObject = Make(scene, data, view, styles, customBuilders);
    return gameObject;
  };

  var Maker = /*#__PURE__*/function () {
    function Maker(scene, styles, customBuilders) {
      _classCallCheck(this, Maker);

      this.setScene(scene);
      this.setStyles(styles);
      this.setCustomBuilders(customBuilders);
    }

    _createClass(Maker, [{
      key: "setScene",
      value: function setScene(scene) {
        this.scene = scene;
        return this;
      }
    }, {
      key: "setStyles",
      value: function setStyles(styles) {
        this.styles = ParseYAML(styles);
        return this;
      }
    }, {
      key: "addStyle",
      value: function addStyle(key, style) {
        if (this.styles === undefined) {
          this.styles = {};
        }

        this.styles[key] = ParseYAML(style);
        return this;
      }
    }, {
      key: "clearStyles",
      value: function clearStyles() {
        this.setStyles();
        return this;
      }
    }, {
      key: "setCustomBuilders",
      value: function setCustomBuilders(customBuilders) {
        this.customBuilders = customBuilders;
        return this;
      }
    }, {
      key: "addCustomBuilder",
      value: function addCustomBuilder(key, customBuilder) {
        if (this.customBuilders === undefined) {
          this.customBuilders = {};
        }

        this.customBuilders[key] = customBuilder;
        return this;
      }
    }, {
      key: "clearCustomBuilder",
      value: function clearCustomBuilder() {
        this.setCustomBuilders();
        return this;
      }
    }, {
      key: "make",
      value: function make(data, view) {
        return YAMLMake(this.scene, data, view, this.styles, this.customBuilders);
      } // Helper method

    }, {
      key: "renderText",
      value: function renderText(text, view) {
        if (text == null) {
          return '';
        }

        var template = lib.compile(text);
        return template(view);
      }
    }]);

    return Maker;
  }();

  ObjectFactory.register('maker', function (styles, customBuilders) {
    return new Maker(this.scene, styles, customBuilders);
  });
  SetValue(window, 'RexPlugins.UI.Maker', Maker);

  var GetValue$2 = Phaser.Utils.Objects.GetValue;

  var CreateInputText = function CreateInputText(text, config) {
    if (config === undefined) {
      config = {};
    }

    var scene = text.scene;
    var style = text.style;
    var backgroundColor = GetValue$2(config, 'backgroundColor', style.backgroundColor);

    if (backgroundColor === null) {
      backgroundColor = 'transparent';
    }

    config.text = GetValue$2(config, 'text', text.text);
    config.fontFamily = GetValue$2(config, 'fontFamily', style.fontFamily);
    config.fontSize = GetValue$2(config, 'fontSize', style.fontSize);
    config.color = GetValue$2(config, 'color', style.color);
    config.backgroundColor = backgroundColor;
    config.direction = GetValue$2(config, 'rtl', style.rtl) ? 'rtl' : 'ltr';
    config.align = GetValue$2(config, 'align', GetHAlign(style)); // Built-in text game object with RTL only has 'right' align

    if (config.direction === 'rtl' && IsTextGameObject(text)) {
      config.align = 'right';
    } // config.paddingLeft = 0;
    // config.paddingRight = 0;
    // config.paddingTop = 0;
    // config.paddingBottom = 0;
    // var valign = GetVAlign(style);
    // switch (valign) {
    //     case 'top':
    //         break;
    //     case 'bottom':
    //         break;
    // }


    var inputText = new InputText(scene, text.x, text.y, GetValue$2(config, 'width', text.width), GetValue$2(config, 'height', text.height), config);
    inputText.setOrigin(text.originX, text.originY);
    scene.add.existing(inputText);
    return inputText;
  };

  var GetHAlign = function GetHAlign(style) {
    if (style.hasOwnProperty('align')) {
      return style.align;
    } else if (style.hasOwnProperty('halign')) {
      return style.halign;
    } else {
      return 'left';
    }
  };

  var GetValue$1 = Phaser.Utils.Objects.GetValue;
  var LastOpenedEditor = undefined;

  var TextEdit = /*#__PURE__*/function (_ComponentBase) {
    _inherits(TextEdit, _ComponentBase);

    var _super = _createSuper(TextEdit);

    function TextEdit(gameObject) {
      var _this;

      _classCallCheck(this, TextEdit);

      // No event emitter
      _this = _super.call(this, gameObject, {
        eventEmitter: false
      }); // this.parent = gameObject;

      _this.inputText = undefined;
      _this.onClose = undefined;
      _this.delayCall = undefined;
      return _this;
    }

    _createClass(TextEdit, [{
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        }

        this.close();

        if (LastOpenedEditor === this) {
          LastOpenedEditor = undefined;
        }

        _get(_getPrototypeOf(TextEdit.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "open",
      value: function open(config, onCloseCallback) {
        if (LastOpenedEditor !== undefined) {
          LastOpenedEditor.close();
        }

        LastOpenedEditor = this;

        if (IsFunction(config)) {
          onCloseCallback = config;
          config = undefined;
        }

        if (onCloseCallback === undefined) {
          onCloseCallback = GetValue$1(config, 'onClose', undefined);
        }

        var onOpenCallback = GetValue$1(config, 'onOpen', undefined);
        var customOnTextChanged = GetValue$1(config, 'onTextChanged', undefined);
        this.inputText = CreateInputText(this.parent, config).on('textchange', function (inputText) {
          var text = inputText.text;

          if (customOnTextChanged) {
            // Custom on-text-changed callback
            customOnTextChanged(this.parent, text);
          } else {
            // Default on-text-changed callback
            this.parent.text = text;
          }
        }, this).setFocus();
        this.parent.setVisible(false); // Set parent text invisible
        // Attach close event

        this.onClose = onCloseCallback;

        if (GetValue$1(config, 'enterClose', true)) {
          this.scene.input.keyboard.once('keydown-ENTER', this.close, this);
        } // Attach pointerdown (outside of input-text) event, at next tick


        this.delayCall = this.scene.time.delayedCall(0, function () {
          this.scene.input.once('pointerdown', this.close, this); // Open editor completly, invoke onOpenCallback

          if (onOpenCallback) {
            onOpenCallback(this.parent);
          }
        }, [], this);
        return this;
      }
    }, {
      key: "close",
      value: function close() {
        LastOpenedEditor = undefined;

        if (!this.inputText) {
          return this;
        }

        this.parent.setVisible(true); // Set parent text visible

        this.inputText.destroy();
        this.inputText = undefined;

        if (this.delayCall) {
          this.delayCall.remove();
          this.delayCall = undefined;
        } // Remove close event


        this.scene.input.keyboard.off('keydown-ENTER', this.close, this);
        this.scene.input.off('pointerdown', this.close, this);

        if (this.onClose) {
          this.onClose(this.parent);
        }

        return this;
      }
    }, {
      key: "isOpened",
      get: function get() {
        return this.inputText !== undefined;
      }
    }, {
      key: "text",
      get: function get() {
        return this.isOpened ? this.inputText.text : this.parent.text;
      }
    }]);

    return TextEdit;
  }(ComponentBase);

  var Edit = function Edit(gameObject, config, onCloseCallback) {
    if (!gameObject._edit) {
      gameObject._edit = new TextEdit(gameObject);
    }

    gameObject._edit.open(config, onCloseCallback);

    return gameObject._edit;
  };

  var TextRunWidthWrap = function TextRunWidthWrap(textObject) {
    var RunWidthWrap = function RunWidthWrap(width) {
      var padding = textObject.padding;
      var wrapWidth = width - padding.left - padding.right;
      var style = textObject.style;

      if (IsTextGameObject(textObject)) {
        style.wordWrapWidth = wrapWidth;
        style.maxLines = 0;
      } else {
        // BBCode text, Tag text
        if (style.wrapMode === 0) {
          // Turn no-wrap to word-wrap
          style.wrapMode = 1;
        }

        style.wrapWidth = wrapWidth;
        style.maxLines = 0;
      }

      textObject.setFixedSize(width, 0); // Redraw text

      return textObject;
    };

    return RunWidthWrap;
  };

  var DynamicTextRunWidthWrap = function DynamicTextRunWidthWrap(textObject) {
    var RunWidthWrap = function RunWidthWrap(width) {
      textObject.setFixedSize(width, 0).runWordWrap();
      return textObject;
    };

    return RunWidthWrap;
  };

  var BitmapTextRunWidthWrap = function BitmapTextRunWidthWrap(textObject) {
    var RunWidthWrap = function RunWidthWrap(width) {
      textObject.setMaxWidth(width);
      return textObject;
    };

    return RunWidthWrap;
  };

  var IsDynamicTextGameObject = function IsDynamicTextGameObject(gameObject) {
    return gameObject instanceof DynamicText;
  };

  var WrapExpandText = function WrapExpandText(textObject, minWidth) {
    if (minWidth === undefined) {
      minWidth = 0;
    }

    textObject._minWidth = minWidth;
    textObject.runWidthWrap = IsDynamicTextGameObject(textObject) ? DynamicTextRunWidthWrap(textObject) : IsBitmapTextGameObject(textObject) ? BitmapTextRunWidthWrap(textObject) : TextRunWidthWrap(textObject);
    return textObject;
  };

  var Delay = function Delay(time, result) {
    if (time === undefined) {
      time = 0;
    }

    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        resolve(result);
      }, time);
    });
  };

  var CreateCover = function CreateCover(gameObject, config) {
    var scene = gameObject.scene;
    var cover = new Cover(scene, config);
    scene.add.existing(cover); // Put cover behind game object

    if (gameObject.isRexContainerLite) {
      gameObject.moveDepthBelow(cover);
    } else {
      scene.children.moveBelow(cover, gameObject);
    }

    return cover;
  };

  var DefaultTransitCallbacks = {
    popUp: function popUp(gameObject, duration) {
      PopUp(gameObject, duration);
    },
    scaleDown: function scaleDown(gameObject, duration) {
      // Don't destroy here
      ScaleDownDestroy(gameObject, duration, undefined, undefined, false);
    },
    fadeIn: function fadeIn(gameObject, duration) {
      FadeIn(gameObject, duration);
    },
    fadeOut: function fadeOut(gameObject, duration) {
      // Don't destroy here
      FadeOutDestroy(gameObject, duration, false);
    }
  };

  var State = /*#__PURE__*/function (_FSM) {
    _inherits(State, _FSM);

    var _super = _createSuper(State);

    function State(parent, config) {
      var _this;

      _classCallCheck(this, State);

      _this = _super.call(this, config);
      _this.parent = parent;

      _this.init();

      return _this;
    }

    _createClass(State, [{
      key: "init",
      value: function init() {
        this.start('IDLE');
      } // IDLE -> TRANS_OPNE

    }, {
      key: "next_IDLE",
      value: function next_IDLE() {
        return 'TRANS_OPNE';
      } // IDLE
      // TRANS_OPNE -> OPEN

    }, {
      key: "next_TRANS_OPNE",
      value: function next_TRANS_OPNE() {
        return 'OPEN';
      }
    }, {
      key: "enter_TRANS_OPNE",
      value: function enter_TRANS_OPNE() {
        var modalBehavior = this.parent;
        modalBehavior.transitionIn();
        modalBehavior.delayCall(modalBehavior.transitInTime, this.next, this);
      }
    }, {
      key: "exit_TRANS_OPNE",
      value: function exit_TRANS_OPNE() {
        var modalBehavior = this.parent;
        modalBehavior.removeDelayCall();
      } // TRANS_OPNE
      // OPEN -> TRANS_CLOSE    

    }, {
      key: "next_OPEN",
      value: function next_OPEN() {
        return 'TRANS_CLOSE';
      }
    }, {
      key: "enter_OPEN",
      value: function enter_OPEN() {
        var modalBehavior = this.parent;
        var duration = modalBehavior.displayTime;

        if (duration >= 0) {
          modalBehavior.delayCall(duration, modalBehavior.requestClose, // callback
          modalBehavior // scope
          );
        }

        modalBehavior.onOpen();
      }
    }, {
      key: "exit_OPEN",
      value: function exit_OPEN() {
        var modalBehavior = this.parent;
        modalBehavior.removeDelayCall();
      } // OPEN
      // TRANS_CLOSE -> CLOSE

    }, {
      key: "next_TRANS_CLOSE",
      value: function next_TRANS_CLOSE() {
        return 'CLOSE';
      }
    }, {
      key: "enter_TRANS_CLOSE",
      value: function enter_TRANS_CLOSE() {
        var modalBehavior = this.parent;
        modalBehavior.transitionOut();
        modalBehavior.delayCall(modalBehavior.transitOutTime, this.next, this);
      }
    }, {
      key: "exit_TRANS_CLOSE",
      value: function exit_TRANS_CLOSE() {
        var modalBehavior = this.parent;
        modalBehavior.removeDelayCall();
      } // TRANS_CLOSE
      // CLOSE

    }, {
      key: "next_CLOSE",
      value: function next_CLOSE() {}
    }, {
      key: "enter_CLOSE",
      value: function enter_CLOSE() {
        var modalBehavior = this.parent;
        modalBehavior.onClose();
      }
    }, {
      key: "exit_CLOSE",
      value: function exit_CLOSE() {} // CLOSE

    }]);

    return State;
  }(FSM);

  var GetValue = Phaser.Utils.Objects.GetValue;
  var Timer = Phaser.Time.TimerEvent;

  var Modal$1 = /*#__PURE__*/function (_ComponentBase) {
    _inherits(Modal, _ComponentBase);

    var _super = _createSuper(Modal);

    function Modal(gameObject, config) {
      var _this;

      _classCallCheck(this, Modal);

      _this = _super.call(this, gameObject, config); // this.parent = gameObject;
      // this.scene
      // Cover : key of modal, to block touch input        

      var coverConfig = GetValue(config, 'cover');
      _this.cover = coverConfig !== false ? CreateCover(gameObject, coverConfig) : undefined; // Close conditions:
      // OK/Cancel buttons, invoke modal.requestClose()

      var manualClose = GetValue(config, 'manualClose', true); // Timeout/any-touch

      if (!manualClose) {
        _this.setDisplayTime(GetValue(config, 'duration.hold', 2000));

        var anyTouchClose = GetValue(config, 'anyTouchClose', true);

        if (anyTouchClose) {
          _this.anyTouchClose();
        }
      } else {
        _this.setDisplayTime(-1);
      }

      _this.setTransitInTime(GetValue(config, 'duration.in', 200));

      _this.setTransitOutTime(GetValue(config, 'duration.out', 200));

      _this.setTransitInCallback(GetValue(config, 'transitIn', TransitionMode.popUp));

      _this.setTransitOutCallback(GetValue(config, 'transitOut', TransitionMode.scaleDown));

      _this.destroyParent = GetValue(config, 'destroy', true);
      _this.timer = new Timer();
      _this._state = new State(_assertThisInitialized(_this), {
        eventEmitter: false
      });
      _this.closeEventData = undefined; // Start

      _this._state.next();

      return _this;
    }

    _createClass(Modal, [{
      key: "state",
      get: function get() {
        return this._state.state;
      }
    }, {
      key: "shutdown",
      value: function shutdown(fromScene) {
        // Already shutdown
        if (this.isShutdown) {
          return;
        } // Registered in anyTouchClose()


        if (!this.cover) {
          this.scene.input.off('pointerup', this.requestClose, this);
        }

        if (this.cover && !fromScene) {
          this.cover.destroy();
          this.cover = undefined;
        }

        this.transitInCallback = undefined;
        this.transitOutCallback = undefined;
        this.closeEventData = undefined;
        this.removeDelayCall();

        _get(_getPrototypeOf(Modal.prototype), "shutdown", this).call(this, fromScene);
      }
    }, {
      key: "anyTouchClose",
      value: function anyTouchClose() {
        if (this.cover) {
          this.cover.once('pointerup', this.requestClose, this);
        } else {
          this.scene.input.once('pointerup', this.requestClose, this);
        }

        return this;
      }
    }, {
      key: "transitionIn",
      value: function transitionIn() {
        var duration = this.transitInTime;
        this.transitInCallback(this.parent, duration);
        var cover = this.cover;

        if (cover) {
          FadeIn(cover, duration, cover.alpha);
        }

        return this;
      }
    }, {
      key: "transitionOut",
      value: function transitionOut() {
        var duration = this.transitOutTime;
        this.transitOutCallback(this.parent, duration);
        var cover = this.cover;

        if (cover) {
          FadeOutDestroy(cover, duration, false);
        }

        return this;
      }
    }, {
      key: "onOpen",
      value: function onOpen() {
        this.emit('open', this.parent, this);
      }
    }, {
      key: "onClose",
      value: function onClose() {
        this.emit('close', this.closeEventData);

        if (this.destroyParent) {
          this.parent.destroy(); // Will invoke `this.destroy()`
        } else {
          this.destroy();
        }
      }
    }, {
      key: "delayCall",
      value: function delayCall(delay, callback, scope) {
        // Invoke callback under scene's 'postupdate' event
        var sceneEE = this.scene.sys.events;
        this.timer = this.scene.time.delayedCall(delay, // delay
        sceneEE.once, // callback
        ['postupdate', callback, scope], // args
        sceneEE // scope
        );
        return this;
      }
    }, {
      key: "removeDelayCall",
      value: function removeDelayCall() {
        if (this.timer) {
          this.timer.remove(false);
          this.timer = undefined;
        }

        return this;
      }
    }, {
      key: "setTransitInTime",
      value: function setTransitInTime(time) {
        this.transitInTime = time;
        return this;
      }
    }, {
      key: "setDisplayTime",
      value: function setDisplayTime(time) {
        this.displayTime = time;
        return this;
      }
    }, {
      key: "setTransitOutTime",
      value: function setTransitOutTime(time) {
        this.transitOutTime = time;
        return this;
      }
    }, {
      key: "setTransitInCallback",
      value: function setTransitInCallback(callback) {
        if (typeof callback === 'string') {
          callback = TransitionMode[callback];
        }

        switch (callback) {
          case TransitionMode.popUp:
            callback = DefaultTransitCallbacks.popUp;
            break;

          case TransitionMode.fadeIn:
            callback = DefaultTransitCallbacks.fadeIn;
            break;
        }

        if (!callback) {
          callback = NOOP;
        }

        this.transitInCallback = callback; // callback = function(gameObject, duration) {}

        return this;
      }
    }, {
      key: "setTransitOutCallback",
      value: function setTransitOutCallback(callback) {
        if (typeof callback === 'string') {
          callback = TransitionMode[callback];
        }

        switch (callback) {
          case TransitionMode.scaleDown:
            callback = DefaultTransitCallbacks.scaleDown;
            break;

          case TransitionMode.fadeOut:
            callback = DefaultTransitCallbacks.fadeOut;
            break;
        }

        if (callback == null) {
          callback = NOOP;
        }

        this.transitOutCallback = callback; // callback = function(gameObject, duration) {}

        return this;
      }
    }, {
      key: "requestClose",
      value: function requestClose(closeEventData) {
        // Only can close modal in OPEN state
        if (this._state.state === 'OPEN') {
          this.closeEventData = arguments.length > 0 ? closeEventData : this.parent;

          this._state.next(); // OPEN -> TRANS_CLOSE 

        }

        return this;
      }
    }]);

    return Modal;
  }(ComponentBase);

  var TransitionMode = {
    popUp: 0,
    fadeIn: 1,
    scaleDown: 0,
    fadeOut: 1
  };

  var Modal = function Modal(gameObject, config) {
    var modalBehavior = new Modal$1(gameObject, config); // Route modal's 'open', 'close' event

    modalBehavior.on('open', function () {
      gameObject.emit('modal.open', modalBehavior);
    });
    modalBehavior.on('close', function (closeEventData) {
      gameObject.emit('modal.close', closeEventData, modalBehavior);
    }); // Reigster 'modal.requestClose' event for invoking modalBehavior.requestClose() method

    gameObject.on('modal.requestClose', modalBehavior.requestClose, modalBehavior);
    modalBehavior.on('close', function () {
      gameObject.off('modal.requestClose', modalBehavior.requestClose, modalBehavior);
    });
    return modalBehavior;
  };

  var ModalPromise = function ModalPromise(gameObject, config) {
    var modalBehavior = Modal(gameObject, config);
    return new Promise(function (resolve, reject) {
      modalBehavior.once('close', function (closeEventData) {
        resolve(closeEventData);
      });
    });
  };

  var ModalClose = function ModalClose(gameObject, closeEventData) {
    gameObject.emit('modal.requestClose', closeEventData);
  };

  var UIPlugin = /*#__PURE__*/function (_Phaser$Plugins$Scene) {
    _inherits(UIPlugin, _Phaser$Plugins$Scene);

    var _super = _createSuper(UIPlugin);

    function UIPlugin(scene, pluginManager) {
      var _this;

      _classCallCheck(this, UIPlugin);

      _this = _super.call(this, scene, pluginManager);
      _this.add = new ObjectFactory(scene);
      return _this;
    }

    _createClass(UIPlugin, [{
      key: "start",
      value: function start() {
        var eventEmitter = this.scene.events;
        eventEmitter.on('destroy', this.destroy, this);
      }
    }, {
      key: "isInTouching",
      value: function isInTouching(gameObject, pointer, preTest, postTest) {
        if (!gameObject.visible) {
          return false;
        }

        return IsPointerInBounds(gameObject, pointer, preTest, postTest);
      }
    }, {
      key: "viewport",
      get: function get() {
        return GetViewport(this.scene, true);
      }
    }, {
      key: "make",
      value: function make(data, view, styles, customBuilders) {
        return YAMLMake(this.scene, data, view, styles, customBuilders);
      }
    }]);

    return UIPlugin;
  }(Phaser.Plugins.ScenePlugin);

  var methods = {
    getParentSizer: GetParent,
    getTopmostSizer: GetTopmostParent,
    hide: Hide,
    show: Show,
    isShown: IsShown,
    edit: Edit,
    wrapExpandText: WrapExpandText,
    waitEvent: WaitEvent,
    waitComplete: WaitComplete,
    delayPromise: Delay,
    setChildrenInteractive: SetChildrenInteractive,
    fadeIn: FadeIn,
    fadeOutDestroy: FadeOutDestroy,
    easeMoveTo: EaseMoveTo,
    easeMoveFrom: EaseMoveFrom,
    modal: Modal,
    modalPromise: ModalPromise,
    modalClose: ModalClose,
    requestDrag: RequestDrag
  };
  Object.assign(UIPlugin.prototype, methods);

  return UIPlugin;

}));
